---
title: 电脑字体显示规则
cover: 'https://source.fomal.cc/img/default_cover_176.webp'
tags: font
description: 介绍电脑上的软件如何选择字体，以及字体的主要分类
abbrlink: d4515193
date: 2025-11-01 16:06:54
categories: [System & Hardware, System Knowledge]

---

## 字体匹配流程
### Linux
#### 基本流程
Linux (或者更准确地说，是大多数现代 Linux 桌面应用) 处理字体的流程：
1. 应用发起请求：一个应用程序（比如你的 VS Code 或浏览器）需要显示文本。它会向系统请求一个字体。这个请求可能是：
   * 通用请求： "我需要一个等宽字体 (monospace)。"
   * 具体请求： "我需要字体 'Fira Code'，字号 12。"
2. 这个请求被发送给 `fontconfig` 库。`fontconfig` 是 Linux 系统上的字体管理中枢。
   * 情况 A：应用请求具体字体 (如 'Fira Code')
     1. fontconfig 会检查系统上是否安装了 'Fira Code'。
     2. 如果找到了：它会把 'Fira Code' 字体文件返回给应用。
     3. 如果没找到：`fontconfig` 会根据它的替换规则（在 `/etc/fonts/conf.d/` 等位置配置）来找一个最接近的替代品。比如，它可能会用你系统上的默认等宽字体来代替。
   * 情况 B：应用请求通用字体 (如 'monospace')
     1. fontconfig 会查找它的配置，找出当前被指定为 'monospace' 类别的默认字体。
     2. `fc-match monospace` 命令查到的正是 `fontconfig` 在这个情况下会返回的结果。

#### Fallback 机制
假设你指定 VS Code 使用 'Fira Code' 字体。'Fira Code' 是一款出色的编程字体，但它不包含中文字符。当你打开一个同时包含代码和中文注释的文件时：
1. VS Code 请求 'Fira Code' 来显示所有文本。
2. `fontconfig` 提供了 'Fira Code'。
3. 当渲染到英文字符 `function` 时，'Fira Code' 里有这些字符，正常显示。
4. 当渲染到中文字符 `“你好”` 时，系统发现 'Fira Code' 里没有这两个字的字形 (glyph)。
5. 此时，fontconfig 会再次介入，自动在你的系统中寻找另一个包含 “你好” 的字体（通常是你配置的默认无衬线字体，比如 `fc-match sans` 返回的 "Noto Sans CJK SC"）。
6. 最后，你在屏幕上看到的 "function 你好" 实际上是由两种不同字体拼接渲染而成的，但看起来天衣无缝。

当然，通常在许多应用的配置文件中，也可以手动规定 fallback 的字体。

### Windows
总体思想和 Linux 相同，只是 Windows 没有一个像 `fontconfig` 一样的库，它的字体处理能力是深度集成在操作系统核心组件中的。

* Linux：`fontconfig` (负责匹配) + `FreeType` (负责渲染)。
* Windows：
  * GDI (Graphics Device Interface)：这是 Windows 传统的字体渲染引擎。
  * DirectWrite：这是现代的、接替 GDI 的文本 API（集成在 DirectX 中）。它提供了更高质量的文本渲染（比如 ClearType 亚像素抗锯齿）和更复杂的字体处理。

同时 Windows 也有一个核心的字体安装位置，就是 `C:\Windows\Fonts` 目录。所有安装的字体都在这里注册。

## 字体管理命令与配置文件 (Linux)
### 字体管理命令
1. `fc-cache`：刷新字体缓存
这是安装或删除字体后需要运行的命令。`fontconfig` 使用缓存来快速查找字体。如果你手动在字体目录（如 `~/.local/share/fonts/`）中添加了新的 `.ttf` 或 `.otf` 文件，系统不会立即知道。

用法：
```bash
fc-cache -f -v
```

* `-f (force)`: 强制重新扫描所有字体目录。
* `-v (verbose)`: 显示详细的扫描过程，让你能看到它正在扫描哪些目录。

2. `fc-list`：列出已安装字体
用于查看系统当前“知道”的所有字体。

```bash
fc-list # 通常会返回字体文件路径、字体家族名称和样式
fc-list | grep "Noto Sans" # 按字体家族名称筛选（例如，查找所有 "Noto Sans" 字体）
```

3. `fc-match`：查询默认字体
用于询问 `fontconfig` 在某个请求下会选择哪个字体。


```bash
fc-match monospace # 查询默认的无衬线体（系统UI最常用）
fc-match sans # 查询默认的衬线体（文档最常用）
```

### 配置文件
#### 字体文件存放目录
需要把字体文件（`.ttf`, `.otf` 等）放在这些地方，`fc-cache` 才会找到它们。

* 系统级目录
  * `/usr/share/fonts/`
  * `/usr/local/share/fonts/`
* 用户级目录
  * `~/.local/share/fonts/`


#### 字体配置文件
* 系统级配置（不应修改）：
  * `/etc/fonts/fonts.conf`：这是主配置文件，它定义了加载其他配置的顺序。你永远不应该直接编辑这个文件，它会在系统更新时被覆盖。
  * `/usr/share/fontconfig/conf.avail/`：这是一个“可用配置”的仓库，存放了大量由系统提供的预设配置（例如，`10-antialias.conf` 用于启用抗锯齿）。
* 系统级配置（激活）：
  * `/etc/fonts/conf.d/`：这个目录下的文件通常是上面 `conf.avail` 目录中文件的符号链接，决定了哪些系统级规则被激活。
* 用户级配置（推荐用于个人自定义）：
  * `~/.config/fontconfig/fonts.conf`：这是你个人进行字体配置的最佳位置。


## 字体分类
### 衬线体 (Serif)
“衬线” (Serif) 指的是字母笔画末端的装饰性小“脚”或短线。
* 特征：笔画有粗细变化，末端有装饰性的衬线。
* 观感：经典、正式、传统、优雅。
* 用途：
  * 印刷品正文：衬线被认为可以引导视线，使大段的印刷文字（如书籍、报纸）更容易阅读。
  * 标题：用于营造一种经典或权威的感觉。

常见例子：
* Times New Roman（泰晤士新罗曼体）：非常经典的报纸和文档字体。
* 思源宋体 / Noto Serif CJK：常见的中日韩衬线体。

### 无衬线体 (Sans Serif)
“Sans” 是法语中“没有”的意思，所以 Sans Serif 就是“没有衬线”的字体。
* 特征：笔画粗细均匀，末端干净利落，没有装饰性的“脚”。
* 观感：现代、简洁、干净、中性。
* 用途：
  * 屏幕显示：在（尤其是低分辨率）屏幕上，简洁的线条比复杂的衬线更容易清晰渲染。这是绝大多数网页、App 和操作系统界面的首选。
  * 标题和Logo：因其简洁醒目，常用于现代品牌的 Logo 和海报标题。

常见例子：
* Helvetica：被誉为“现代主义”的代表，极其（甚至过度）流行。
* Arial：Windows 系统对 Helvetica 的模仿和替代品。
* 思源黑体 / Noto Sans CJK：最常见的中日韩无衬线体（“黑体”就是中文里的无衬线体）。

### 等宽字体 (Monospaced)
* 特征：每个字符（包括字母、符号、空格）都占据完全相同的水平宽度。
* 观感：机械、复古（来自打字机）、功能性强。
* 用途：
  * 编程和终端：这是它的核心用途。由于所有字符等宽，代码可以完美地垂直对齐，极大地增强了代码的可读性，便于区分缩进和结构。
  * 表格数据：用于显示需要对齐的数字或文本。

常见例子：
* DejaVu Sans Mono：在 Linux 系统中非常流行的默认等宽字体。