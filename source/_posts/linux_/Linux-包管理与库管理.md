---
title: Linux 包管理与库管理
cover: 'https://source.fomal.cc/img/default_cover_133.webp'
tags:
  - linux
description: 先介绍 Linux 中的包(package)和库(library)，接着介绍一下 dnf 之类的包管理器，以及用来管理库的 pkg-config。
abbrlink: 12e1f9cc
date: 2024-12-12 02:24:25
---

## 包(package)和库(library)
### 包(Package)
包通常是指一种包含了软件或其组件的归档文件，里面不仅可能包括库(library)文件，还可能包含配置文件、文档、可执行文件等其他资源。包是为了方便安装和管理软件而打包的集合。包管理工具(如 apt、yum、pacman、pip 等)会管理这些包的下载、安装、卸载和更新。

### 库 (Library)
库是指一组可以被其他程序调用的函数、类、模块或组件。库通常是提供给开发者使用的代码集合，它们并不包含应用程序的完整功能，而是提供特定的功能或服务（如图形界面、网络通信、数据处理等）。库可以是动态库（`*.so` 或 `*.dll` 文件）或静态库（`*.a` 或 `*.lib` 文件）。

### 包和库的区别
* 包是集合，库是组件：
  * 包是一个软件或多个软件组件的集合，可能包含库、文档、配置文件、脚本等。
  * 库是提供给程序使用的代码文件，通常用来实现某些功能或服务。
* 包的安装是针对软件或工具的：
  * 包管理工具安装的是一个完整的软件包，其中可能包含库、工具、依赖和配置文件等。
  * 库管理工具（如 `pkg-config`、`pip`）通常会帮助你安装并管理库，供程序开发使用。
* 一个包中可能包含多个库：
  * 一个软件包可能包含一个或多个库文件。例如，在 Linux 上安装 `libglib2.0-dev` 包时，你安装的是 `glib` 库的开发版本，它可能包含多个 `.h` 和 `.so` 文件。

### 实际例子：
* `libglib2.0-dev` 包：
  * 这是一个包，它包含了 `glib-2.0` 库的开发版本，提供了头文件、库文件等，供开发者使用。
  * 安装这个包时，你安装的是 `glib-2.0` 库及其相关开发文件。
* `glib-2.0` 库：
  * 这是一个库，它提供了一组 API，供程序使用。
  * 安装 `libglib2.0-dev` 包时，你会在系统中安装 `glib-2.0` 库及其相关文件，但这只是一个部分内容，包中还包含了其他开发文件。

## 安装包/库
### 包管理器
安装一个包最方便的方式是使用包管理器。不同的发行版选择不同的包管理工具，这些工具可以分为两大类：基于 `.deb` 包的工具和基于 `.rpm` 包的工具。
* dpkg
  * `dpkg` 是 Debian 和基于 Debian 的发行版（如 Ubuntu）的低级包管理工具。它负责安装、卸载和查询 .deb 格式的软件包。
  * 特点
    * `dpkg` 本身不处理依赖关系。如果一个包依赖于其他包，`dpkg` 不会自动安装这些依赖，用户需要手动解决依赖问题。
* APT（Advanced Package Tool）
  * APT 是 Debian 和基于 Debian 的发行版（如 Ubuntu）中用于处理包管理的高级工具，它依赖于 `dpkg`，并且可以自动处理软件包的依赖关系。
  * 特点
    * 自动处理依赖关系。
    * 支持从多个软件源下载和安装包，通常通过配置 `/etc/apt/sources.list` 文件来指定软件源。
    * 强大的缓存机制，在安装和更新时能够提高效率。
    * 支持安装和管理软件包、更新系统和清理未使用的软件包。
* RPM（Red Hat Package Manager）
  * RPM 是 Red Hat 和基于 Red Hat 的发行版（如 CentOS、Fedora、RHEL）的包管理工具。它用于管理 `.rpm` 格式的包。
  * 特点：
    * rpm 主要用于低级别的软件包管理，它并不处理依赖关系。安装 `.rpm `包时，如果存在依赖问题，用户必须手动解决。
    * 支持查询、验证、安装和卸载 `.rpm` 格式的软件包。
    * 对应的高级工具 `yum` 和 `dnf` 会自动处理依赖关系。
* YUM（Yellowdog Updater, Modified）
  * YUM 是 Red Hat 系列发行版（如 CentOS 和 RHEL）的包管理工具，用于安装、更新和卸载 `.rpm` 包。YUM 依赖于 rpm，并能够自动解决软件包的依赖关系。
  * 特点：
    * 自动处理依赖关系。
    * YUM 会从配置的仓库（例如 CentOS, RHEL 的官方仓库或第三方仓库）下载和安装软件包。
    * 可以通过 .repo 文件配置软件源。
    * 提供丰富的插件支持，用于扩展功能，如自动清理缓存等。
*  DNF（Dandified YUM）
   *  DNF 是 YUM 的下一代替代工具，最早在 Fedora 中出现，后来成为 RHEL 和 CentOS 8+ 系统的默认包管理工具。它与 YUM 兼容，但具有更高效的性能和改进的依赖解决机制。*  

| 特性/工具       | **dpkg**          | **APT**          | **RPM**         | **YUM**           | **DNF**           |
|-----------------|-------------------|------------------|-----------------|-------------------|-------------------|
| **基础工具**    | 低级包管理工具     | 高级包管理工具    | 低级包管理工具  | 高级包管理工具    | 高级包管理工具    |
| **包格式**      | `.deb`            | `.deb`           | `.rpm`          | `.rpm`            | `.rpm`            |
| **依赖关系管理** | 无                 | 自动处理依赖关系  | 无               | 自动处理依赖关系  | 自动处理依赖关系  |
| **主要发行版**  | Debian, Ubuntu     | Debian, Ubuntu    | Red Hat, CentOS, Fedora | Red Hat, CentOS, Fedora | Red Hat, CentOS, Fedora |
| **缓存管理**    | 无                 | 有                | 无               | 有                 | 有                 |
| **命令兼容性**  | 无                 | 包含 dpkg 的功能  | 无               | 兼容 RPM          | 兼容 RPM          |



### 通过源码安装
有时，某些库可能没有在包管理器中提供，或者你需要安装特定版本的库。此时，你可以从源代码编译安装。通常你可以从官方网站或开源代码托管平台（如 GitHub）下载源码包。下载后解压并进入目录。

编译和安装：
```bash
# 下载源码并解压：
tar -xzvf <library-name>.tar.gz
cd <library-name>
# 配置编译选项（如果需要的话）：
./configure
# 编译源码：
make
# 安装库：
sudo make install
```

在某些情况下，库可能会被安装到非标准位置。如果是这种情况，你可能需要在编译时设置库路径，或者将库路径添加到系统的库搜索路径（例如通过 `LD_LIBRARY_PATH` 环境变量或编辑 `/etc/ld.so.conf` 文件）。

### 使用 pip 或 conda 安装 Python 库
对于 Python 库，你可以通过 Python 包管理工具 `pip` 或 `conda` 安装。`pip` 是 Python 官方的包管理工具，而 `conda` 是 Anaconda 提供的工具，支持更全面的依赖管理。

## 库管理工具
`pkg-config` 是一个用于管理和查询已安装的库的工具，常用于开发时的编译和链接过程。它的主要功能为：
* 查询库的编译和链接信息： `pkg-config` 会查询指定库的相关信息，如编译时所需的头文件路径、库文件路径、以及链接时的标志等。
* 简化构建过程： 它可以提供标准化的方式来自动获取编译和链接参数，避免开发者手动处理这些信息。
* 避免版本冲突： 在安装多个版本的库时，`pkg-config` 可以帮助选择正确的版本信息，避免错误的库被链接。

### 基本用法
假设你已经安装了一个库，例如 `glib-2.0`，你可以通过 `pkg-config` 获取它的编译和链接信息：

```bash
# 查询编译时需要的参数
pkg-config --cflags glib-2.0
# 这会输出 glib-2.0 所需要的头文件路径，比如：-I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include

# 查询链接时需要的参数：
pkg-config --libs glib-2.0
# 这会输出 glib-2.0 所需的库文件路径和链接参数，比如：-L/usr/lib -lglib-2.0

# 查询库的完整信息：
pkg-config --modversion glib-2.0
# 这会输出安装的 glib-2.0 的版本号，例如：2.70.0
```

### 结合编译使用
在编译程序时，你可以将 `pkg-config` 的输出直接传给编译器或链接器。例如，在编译一个依赖于 `glib-2.0` 的 C 程序时：
```bash
gcc -o myprogram myprogram.c $(pkg-config --cflags --libs glib-2.0)
```

这里，`$(pkg-config --cflags --libs glib-2.0)` 会自动扩展成适当的编译和链接参数，简化了开发流程。

### pkg-config 如何工作
`pkg-config` 查找库文件时，依赖于 `.pc` 文件，这些文件通常位于 `/usr/lib/pkgconfig/` 或 `/usr/share/pkgconfig/` 目录下。因此如果某个新安装的库的 `.pc` 文件不在默认位置，那么可以通过 `PKG_CONFIG_PATH` 环境变量指定库的搜索路径，例如：
```bash
export PKG_CONFIG_PATH=/path/to/libs/pkgconfig:$PKG_CONFIG_PATH
```





