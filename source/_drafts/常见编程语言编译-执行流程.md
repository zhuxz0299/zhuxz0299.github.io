---
title: 常见编程语言编译/执行流程
tags:
  - C/C++
  - Python
  - Java
  - C#
description: 介绍 C/C++、Python、Java、C# 这几种语言如何经过编译/解释之后在电脑上运行
cover: 'https://source.fomal.cc/img/default_cover_152.webp'
---

## C/C++
### 编译过程
{% note info %}
内容来源：[知乎-C/C++程序编译过程为什么要分为四个步骤？](https://zhuanlan.zhihu.com/p/549996872)
{% endnote %}

{% note primary %}
以下内容基于在 Linux 上使用 GCC (GNU Compiler Collection) 编译代码
{% endnote %}

一条简单的 `gcc` 编译命令背后包含了四个步骤：预处理 (Preprocessing)、编译 (Compilation)、汇编 (Assemble)、链接 (Linking)。

<img src='../figure/常见编程语言编译-执行流程/GCC_CompilationProcess.png' width=500 style="display: block; margin-left: auto; margin-right: auto;">

| 步骤   | 命令           | 等价命令 | 输出文件         |
|--------|----------------|----------|------------------|
| 预处理 | cpp            | gcc -E   | .i, .ii          |
| 编译   | cc1, cc1plus   | gcc -S   | .s               |
| 汇编   | as             | gcc -c   | .o, .obj         |
| 链接   | ld             | gcc      | 可执行文件       |


以一个很小的示例分步骤演示上述编译过程，共有 `main.cpp`、`my_math.h`、`my_math.cpp` 3 个文件，其中 `main.cpp` 依赖 `my_math.h`。程序内容分别如下：
```c++
#include<stdio.h>
#include"my_math.h"
int main(){
    int a =10;
    int b=20;
    int s = demo::sum(a, b);
    printf("sum=%d\n", s);
    return 0;
}
```

```c++
#ifndef MY_MATH_H
#define MY_MATH_H
namespace demo{
    int sum(int a, int b);
}
#endif
```

```c++
#include"my_math.h"
namespace demo{
    int sum(int a, int b){
        return a + b;
    }
}
```

#### 步骤1：预处理 (Preprocessing)
主要用于处理 `#` 开头的代码行，比如对宏做展开，对 `include` 的文件做展开，条件编译选项判断，清理注释等。文件以 `.i` 和 `.ii` 结尾。

执行
```bash
cpp main.cpp -o main.i
cpp my_math.cpp -o my_math.i
```

得到的 `.i` 文件内容非常多，例如 `main.i` 共有 896 行，这与代码展开有直接关系。`main.i` 内容结构如下，其中大部分内容都在 `extern "C"` 中：
```cpp
// 省略……
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4


# 29 "/usr/include/stdio.h" 3 4
extern "C" {



# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4
// 省略……
}

# 2 "main.cpp" 2
# 1 "my_math.h" 1



# 3 "my_math.h"
namespace demo{
    int sum(int a, int b);
}
# 3 "main.cpp" 2
int main(){
    int a =10;
    int b=20;
    int S = demo::sum(a, b);
    printf("sum=%d\n", s);
    return 0;
}
```

#### 步骤2：编译 (Compilation)
使用预处理的输出结果作为输入，生成文本格式的平台相关的汇编代码 (assembly code)。文件以 `.s` 结尾。

执行：
```bash
g++ -S main.i -o main.s
g++ -S my_math.i -o my_math.s
```

或者直接使用cc1(用于C代码)或cc1plus(用于C++代码)。

{% note warning %}
注意cc1plus没有在bash默认的搜索路径中。
{% endnote %}

编译得到 `main.s` 文件，内容如下：
```asm
	.file	"main.cpp"
	.text
	.section	.rodata
.LC0:
	.string	"sum=%d\n"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$16, %rsp
	movl	$10, -12(%rbp)
	movl	$20, -8(%rbp)
	movl	-8(%rbp), %edx
	movl	-12(%rbp), %eax
	movl	%edx, %esi
	movl	%eax, %edi
	call	_ZN4demo3sumEii@PLT
	movl	%eax, -4(%rbp)
	movl	-4(%rbp), %eax
	movl	%eax, %esi
	leaq	.LC0(%rip), %rdi
	movl	$0, %eax
	call	printf@PLT
	movl	$0, %eax
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (Ubuntu 10.5.0-1ubuntu1~20.04) 10.5.0"
	.section	.note.GNU-stack,"",@progbits
	.section	.note.gnu.property,"a"
	.align 8
	.long	 1f - 0f
	.long	 4f - 1f
	.long	 5
0:
	.string	 "GNU"
1:
	.align 8
	.long	 0xc0000002
	.long	 3f - 2f
2:
	.long	 0x3
3:
	.align 8
4:
```

#### 步骤3：汇编 (Assemble)
将上一步的汇编代码转换成二进制的机器码，称为 object code。产生的文件叫做目标文件，是二进制格式，文件以 `.o` 或 `.obj` 结尾。

执行：
```bash
as main.s -o main.o
as my_math.s -o my_math.o
```

编译后生成 `main.o`，这是个二进制文件，`file main.o` 命令查看文件属性：
```
main.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
```

#### 步骤4：链接 (Linking)
链接过程将多个目标文以及所需的库文件 (`.so`等) 链接成最终的可执行文件 (executable file)

执行：
```bash
ld -plugin /usr/local/libexec/gcc/x86_64-linux-gnu/12.1.0/liblto_plugin.so -plugin-opt=/usr/local/libexec/gcc/x86_64-linux-gnu/12.1.0/lto-wrapper -plugin-opt=-fresolution=/tmp/ccIJ5Caz.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --eh-frame-hdr -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o /usr/lib/x86_64-linux-gnu/crti.o /usr/local/lib/gcc/x86_64-linux-gnu/12.1.0/crtbegin.o -L/usr/local/lib/gcc/x86_64-linux-gnu/12.1.0 -L/usr/local/lib/gcc/x86_64-linux-gnu/12.1.0/../../../../lib64 -L/lib/x86_64-linux-gnu -L/lib/../lib64 -L/usr/lib/x86_64-linux-gnu -L/usr/local/lib/gcc/x86_64-linux-gnu/12.1.0/../../.. -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/local/lib/gcc/x86_64-linux-gnu/12.1.0/crtend.o /usr/lib/x86_64-linux-gnu/crtn.o main.o my_math.o -o main
```

得到可执行文件 `main`。

{% note default %}
这步太长了，没有自己在电脑上尝试，直接照搬的原文。
{% endnote %}

#### All in One
```bash
g++ main.cpp my_math.cpp -o main # 四合一编译命令。
./main # 执行
```
