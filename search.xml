<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>matplotlib 绘制对数坐标轴</title>
      <link href="/posts/8eb72eaa.html"/>
      <url>/posts/8eb72eaa.html</url>
      
        <content type="html"><![CDATA[<p>使用 <code>matplotlib</code> 绘图时，有时候由于某个变量呈指数式增加，因此需要对数坐标轴。</p><h3 id="二维图像"><a href="#二维图像" class="headerlink" title="二维图像"></a>二维图像</h3><p>绘制二维图像时使用对数坐标轴较为方便，使用 <code>xscale()</code> 或者 <code>yscale()</code> 直接设置即可。</p><p>使用如下代码，可以绘制得到：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">font = &#123;<span class="string">&#x27;family&#x27;</span>: <span class="string">&#x27;Times New Roman&#x27;</span>, <span class="string">&#x27;size&#x27;</span>: <span class="number">12</span>&#125;</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>, **font)</span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">plt.plot(C_values, accuracy_values, marker=<span class="string">&#x27;o&#x27;</span>, color= <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.xscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;C (hyperparameter of SVM)&#x27;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Accuracy in Cross-validation&#x27;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">sns.set_style(<span class="string">&quot;whitegrid&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src='../../figure/matplotlib 绘制对数坐标轴/no_reduction.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="三维图像"><a href="#三维图像" class="headerlink" title="三维图像"></a>三维图像</h3><p>绘制三维图像时较为麻烦，如果直接使用 <code>set_xscale()</code> 之类的函数，会导致图片非常奇怪，因此需要手动设置。例如以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置字体</span></span><br><span class="line">font = &#123;<span class="string">&#x27;family&#x27;</span>: <span class="string">&#x27;Times New Roman&#x27;</span>, <span class="string">&#x27;size&#x27;</span>: <span class="number">12</span>&#125;</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>, **font)</span><br><span class="line">plt.rcParams[<span class="string">&#x27;text.usetex&#x27;</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 3D 图形</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制曲面图</span></span><br><span class="line">n_features, C = np.meshgrid(num_features, C)</span><br><span class="line">accuracy = np.array(accuracy).reshape(n_features.shape)</span><br><span class="line"></span><br><span class="line">ax.plot_trisurf(n_features.flatten(), np.log10(C).flatten(), accuracy.flatten(), cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置坐标轴标签</span></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;n_components&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;Accuracy while training&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置对数坐标轴</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_tick_formatter</span>(<span class="params">val, pos=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;:.0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">10</span>**val)</span><br><span class="line"></span><br><span class="line">ax.yaxis.set_major_formatter(mticker.FuncFormatter(log_tick_formatter))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>在绘制图像时，首先使用 <code>np.log10(C).flatten()</code>，手动将数据取为对数；然后需要手动设置坐标轴数值，这里使用了 <code>ax.yaxis.set_major_formatter()</code> 函数与 <code>mticker.FuncFormatter()</code> 函数，并且自定义了 <code>log_tick_formatter()</code>，用于生成正确的做标数值。最后得到的图片结果如下：</p><p><img src='../../figure/matplotlib 绘制对数坐标轴/feature_selection.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games with Infinite Pure Strategy</title>
      <link href="/posts/2aea43b1.html"/>
      <url>/posts/2aea43b1.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning theory</title>
      <link href="/posts/d6c74530.html"/>
      <url>/posts/d6c74530.html</url>
      
        <content type="html"><![CDATA[<h2 id="GMM-From-generation-process-perspective"><a href="#GMM-From-generation-process-perspective" class="headerlink" title="GMM-From generation process perspective"></a>GMM-From generation process perspective</h2><h3 id="Introduce-a-latent-variable"><a href="#Introduce-a-latent-variable" class="headerlink" title="Introduce a latent variable"></a>Introduce a latent variable</h3><p>我们认为在分类任务中，每个点本身就隐含了属于哪个类的信息，只是我们没有观察到。EM 算法的 E-step 就相当于使用后验概率来求这个信息。我们使用 $\mathbf{z}$ 来表示这个信息，$z_k=1$ 表示某个点 $\mathbf{x}$ 属于 cluster $k$。</p><script type="math/tex; mode=display">\mathbf{z}=(z_{1},\ldots,z_{K})\quad z_{k}\in\{0,1\}\quad\sum_{k}z_{k}=1</script><p>这个变量称为<strong>隐变量</strong>(latent variable)。</p><p>在概率模型中，我们记样本点属于某个 cluster 的概率为 $p(z_k=1)=\pi_k$，或者写为</p><script type="math/tex; mode=display">p(\mathbf{z})=\prod_{k=1}^{K} \pi_k^{z_k}</script><p>假如一个样本已经能够确定属于某个类，我们假设其满足高斯分布：</p><script type="math/tex; mode=display">p(\mathbf{x}|z_k=1)=\mathcal{N}(\mathbf{x}|\boldsymbol{\mu}_k,\boldsymbol{\Sigma}_k)</script><p>但是如果我们并没有该样本点属于某个类的信息，则其概率分布为高斯分布的加权</p><script type="math/tex; mode=display">p(\mathbf{x})=\sum_{\mathbf{z}}p(\mathbf{z})p(\mathbf{x}|\mathbf{z})=\sum_{k=1}^{K}\pi_{k}\mathcal{N}(\mathbf{x}|\boldsymbol{\mu}_{k},\boldsymbol{\Sigma}_{k})</script><h3 id="EM-algorithm-for-maximum-likelihood"><a href="#EM-algorithm-for-maximum-likelihood" class="headerlink" title="EM algorithm for maximum likelihood"></a>EM algorithm for maximum likelihood</h3><h4 id="Details-of-the-EM-Algorithm-for-GMM"><a href="#Details-of-the-EM-Algorithm-for-GMM" class="headerlink" title="Details of the EM Algorithm for GMM"></a>Details of the EM Algorithm for GMM</h4><ol><li>初始化均值 $\mathbf{\mu}_k$，协方差矩阵 $\mathbf{\Sigma}_k$ 以及混合系数(mixing coefficients) $\pi_k$，并且计算 log likelihood 的初始化值</li><li><strong>E step</strong>。<script type="math/tex; mode=display">\gamma(z_{nk})=\frac{\pi_{k}{\mathcal N}(\mathbf{x}_{n}|\boldsymbol{\mu}_{k},\boldsymbol{\Sigma}_{k})}{\sum_{j=1}^{K}\pi_{j}{\mathcal N}(\mathbf{x}_{n}|\boldsymbol{\mu}_{j},\boldsymbol{\Sigma}_{j})}</script></li><li><strong>M step</strong>。<script type="math/tex; mode=display">\begin{array}{rcl}\mathbf{\mu}_k^\mathrm{new}&=&\frac1{N_k}\sum_{n=1}^N\gamma(z_{nk})\mathbf{x}_n\\\\\mathbf{\Sigma}_k^\mathrm{new}&=&\frac1{N_k}\sum_{n=1}^N\gamma(z_{nk})\left(\mathbf{x}_n-\mathbf{\mu}_k^\mathrm{new}\right)\left(\mathbf{x}_n-\mathbf{\mu}_k^\mathrm{new}\right)^\mathrm{T}\\\\\pi_k^\mathrm{new}&=&\frac{N_k}N\end{array}</script>其中<script type="math/tex; mode=display">N_k = \sum_{n=1}^{N} \gamma(z_{nk})</script></li><li>计算 log likelihood 以检查是否收敛<script type="math/tex; mode=display">\ln p(\mathbf{X}|\boldsymbol{\mu},\boldsymbol{\Sigma},\boldsymbol{\pi})=\sum_{n=1}^N\ln\left\{\sum_{k=1}^K\pi_k\mathcal{N}(\mathbf{x}_n|\boldsymbol{\mu}_k,\boldsymbol{\Sigma}_k)\right\}</script></li></ol><h4 id="The-general-EM-algorithm"><a href="#The-general-EM-algorithm" class="headerlink" title="The general EM algorithm"></a>The general EM algorithm</h4><p>给定联合概率分布 $p(\mathbf{X},\mathbf{Z}|\boldsymbol{\theta})$，其中 $\mathbf{X}$ 为所有观测到的样本数据，$\mathbf{Z}$ 为隐变量，$\boldsymbol{\theta}$ 为所有参数。算法的目标是调整参数 $\boldsymbol{\theta}$ 最大化似然函数 $p(\mathbf{X}|\boldsymbol{\theta})$</p><ol><li>选择初始化参数 $\boldsymbol{\theta}^{old}$</li><li><strong>E step</strong>。计算后验概率 $p(\mathbf{Z}|\mathbf{X},\boldsymbol{\theta}^{old})$<script type="math/tex; mode=display">p(\mathbf{Z}|\mathbf{X}, \boldsymbol{\theta}^{old}) = \frac{p(\mathbf{Z})p(\mathbf{X}|\mathbf{Z},\boldsymbol{\theta}^{old})}{p(\mathbf{X}|\boldsymbol{\theta})}</script></li><li><p><strong>M step</strong>。更新参数</p><script type="math/tex; mode=display"> \boldsymbol{\theta^\mathrm{new}}=\underset{\theta}{\operatorname*{\arg\max}}\mathcal{Q}(\boldsymbol{\theta},\boldsymbol{\theta^\mathrm{old}})</script><p> 其中</p><script type="math/tex; mode=display"> \mathcal{Q}(\boldsymbol{\theta},\boldsymbol{\theta^\mathrm{old}})=\sum_\mathbf{Z}p(\mathbf{Z}|\mathbf{X},\boldsymbol{\theta^\mathrm{old}})\ln p(\mathbf{X},\mathbf{Z}|\boldsymbol{\theta}).</script></li><li>检查收敛性，更新参数<script type="math/tex; mode=display">\boldsymbol{\theta}^\mathrm{old}\leftarrow\boldsymbol{\theta}^\mathrm{new}</script></li></ol><h4 id="Derive-an-EM-algorithm-for-BMM"><a href="#Derive-an-EM-algorithm-for-BMM" class="headerlink" title="Derive an EM algorithm for BMM"></a>Derive an EM algorithm for BMM</h4><p>这里将 EM 算法用于伯努利分布上。</p><p>首先写出伯努利分布：$Bern(x|\mu<em>j) = \mu_j^{x} (1-\mu_j)^{1-x}$。<br>BMM：$p(x|\theta)=\sum</em>{j=1}^{K}\alpha<em>j B(x|\mu_j)$。<br>记 $\theta$ 为参数的集合，即 $\theta=\left{ \alpha_j,\mu_j|j=1,2, \ldots ,K , \sum</em>{j=1}^{K}\alpha_j=1\right}$</p><p>E-step:</p><script type="math/tex; mode=display">\begin{aligned}&P(\mathbf{Z}|\mathbf{X}, \theta) = \prod_{t=1}^{N} P(z_t|x_t, \theta)  \\&P(z_t=j|x_t, \theta) \equiv  P(j|x_t, \theta) = \frac{\alpha_j B(x_t|\mu_j)}{P(x_t|\theta)} \bigg|_{\theta=\theta^{old}}\end{aligned}</script><p>M-step:</p><script type="math/tex; mode=display">\begin{aligned}Q(\theta,\theta^{old}) & = \sum_{\mathbf{Z}}P(\mathbf{Z}|\mathbf{X},\theta^{old})\ln P(\mathbf{X},\mathbf{Z}|\theta) \\& =  \sum_{\mathbf{Z}}P(\mathbf{Z}|\mathbf{X},\theta^{old})\ln \prod_{t=1}^{N} P(x_t,z_t|\theta) \\ & = \sum_{t=1}^{N}\sum_{\mathbf{Z}}P(\mathbf{Z}|\mathbf{X},\theta^{old})\ln P(x_t,z_t|\theta) \\& = \sum_{t=1}^{N} \sum_{z_t} P(z_t|x_t, \theta^{old}) \ln P(x_t,z_t|\theta) \quad (\text{use~} P(\mathbf{Z}|\mathbf{X}, \theta) = \prod_{t=1}^{N} P(z_t|x_t, \theta) \text{~and~} \sum_{\mathbf{Z}}=\sum_{z_1}\sum_{z_2}\cdots \sum_{z_{K}}) \\& = \sum_{t=1}^{N} \sum_{j=1}^{K} P(j|x_t,\theta^{old}) \ln [\alpha_j B(x_t|\mu_j)] \\& = \sum_{t=1}^{N} \sum_{j=1}^{K} P(j|x_t,\theta^{old}) [\ln \alpha_j+ \ln B(x_t|\mu_j)] \\& = \sum_{t=1}^{N} \sum_{j=1}^{K} P(j|x_t,\theta^{old}) [\ln \alpha_j+ x_t \ln \mu_j + (1-x_t)\ln (1-\mu_j)] \\\end{aligned}</script><p>接下来通过最大化 $Q$ 来求 $\mu$ 和 $\alpha$。</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial Q}{\partial \mu_j} &= \sum_{t=1}^{N} P(j|x_t,\theta^{old}) (\frac{x_t}{\mu_j}-\frac{1-x_t}{1-\mu_j}) = \sum_{t=1}^{N} P(j|x_t,\theta^{old}) \frac{x_t-\mu_j}{\mu_j(1-\mu_j)} = 0 \\\Rightarrow \mu_j &= \frac{\sum_{t=1}^{N}x_t P(j|x_t,\theta^{old})}{\sum_{t=1}^{N} P(j|x_t,\theta^{old})}\end{aligned}</script><p>对于 $\alpha$，由于 $\alpha$ 还有一个约束，即 $\sum<em>{j=1}^{K}\alpha_j=1$，因此使用拉格朗日乘子法，记 $Q’ = Q + \lambda (\sum</em>{j=1}^{K} \alpha_j - 1)$</p><script type="math/tex; mode=display">\begin{aligned}& \begin{cases}    \displaystyle \frac{\partial Q'}{\partial \alpha_j} = \sum_{t=1}^{N} P(j|x_t,\theta^{old}) \alpha_j^{-1} + \lambda =0 \\    \displaystyle \sum_{j=1}^{K} \alpha_j = 1\end{cases} \\ \Rightarrow & \begin{cases}    \displaystyle \lambda = -\sum_{t=1}^{N} \sum_{j=1}^{K} P(j|x_t,\theta^{old}) = -N \\    \displaystyle \alpha_j = - \frac{1}{N} \sum_{t=1}^{N} P(j|x_t,\theta^{old})\end{cases}\end{aligned}</script><h3 id="Why-EM-never-decreases-the-log-likelihood"><a href="#Why-EM-never-decreases-the-log-likelihood" class="headerlink" title="Why EM never decreases the (log)-likelihood?"></a>Why EM never decreases the (log)-likelihood?</h3><h4 id="Jensen’s-Inequality"><a href="#Jensen’s-Inequality" class="headerlink" title="Jensen’s Inequality"></a>Jensen’s Inequality</h4><p>一个凸函数的性质，这里应用在 $\log$ 函数上<br><img src='../../figure/机器学习笔记/2-Learning-theory/jensen_inequality.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>对于 $\alpha_i\ge 0, \sum \alpha_i=1$，并且 $x_i&gt;0$，有</p><script type="math/tex; mode=display">\log \left( \sum_{i}\alpha_i x_i \right) \ge  \sum_{i}\alpha_i \log(x_i)</script><h4 id="KL-divergence"><a href="#KL-divergence" class="headerlink" title="KL divergence"></a>KL divergence</h4><script type="math/tex; mode=display">KL(p||q) = \sum_{i}q_i \log \frac{q_i}{p_{i}} (\int p(x)\log \frac{p(x)}{q(x)}\mathrm{d}x) \ge 0</script><p>通常用于度量两个分布之间的距离。</p><p><strong>证明 1 (Jenson’s Inequality)</strong>：</p><script type="math/tex; mode=display">KL(p||q) = \sum_{i}q_i \log \frac{q_i}{p_{i}} = - \sum_{i} q_i \log \frac{p_{i}}{q_i}</script><p>利用 Jenson’s Inequality，</p><script type="math/tex; mode=display">\sum_{i} q_i \log \frac{p_{i}}{q_i} \le \log(\sum_{i}q_i \cdot \frac{p_{i}}{q_i}) = 0 \Rightarrow KL(p||q) \ge 0</script><p><strong>证明 2 (Lagrange multiplier)</strong>：</p><script type="math/tex; mode=display">\begin{aligned}E&\stackrel{\mathrm{def}}{=}\textbf{KL}[q\|p]+\lambda\big(1-\sum_iq_i\big)=\sum_iq_i\log\frac{q_i}{p_i}+\lambda\big(1-\sum_iq_i\big)\end{aligned}</script><script type="math/tex; mode=display">\left.    \begin{array}{rcl}    \displaystyle \frac{\partial E}{\partial q_i}&=&\log q_i-\log p_i+1-\lambda=0\Rightarrow\color{red}{q_i=p_i\exp(\lambda-1)}\\ \\    \displaystyle \frac{\partial E}{\partial\lambda}&=&1-\sum_iq_i=0\Rightarrow\color{red}{\sum_iq_i=1}    \end{array}\right\}\Rightarrow q_i=p_i</script><h4 id="EM-as-maximizing-a-variational-lower-bound"><a href="#EM-as-maximizing-a-variational-lower-bound" class="headerlink" title="EM as maximizing a variational lower bound"></a>EM as maximizing a variational lower bound</h4><p>根据 Jensen’s Inequality，$E[\log(x)]\ge \log (E[x])$</p><script type="math/tex; mode=display">\begin{aligned}\log(P(\mathbf{x}|\theta)) & = \log(\sum_{\mathbf{y}}P(\mathbf{x},\mathbf{y}|\theta)) \\& =\log(\sum_{\mathbf{y}}q(\mathbf{y})\frac{P(\mathbf{x},\mathbf{y}|\theta)}{q(\mathbf{y})})  \\&\geq E_{q} [\log(\frac{P(\mathbf{x},\mathbf{y}|\theta)}{q(\mathbf{y})})] \\&= E_q[\log(\frac{P(\mathbf{y}|\mathbf{x},\theta)P(\mathbf{x}|\theta)}{q(\mathbf{y})})] \\&= E_q[\log(P(\mathbf{x}|\theta))]-E_q[\log(\frac{q(\mathbf{y})}{P(\mathbf{y}|\mathbf{x},\theta)})] \\&= E_q[\log(P(\mathbf{x}|\theta))]-KL(q(\mathbf{y})\|P(\mathbf{y}|\mathbf{x},\theta)) \\&= \log(P(\mathbf{x}|\theta)) - KL(q(\mathbf{y})\|P(\mathbf{y}|\mathbf{x},\theta))\end{aligned}</script><p>从上式可以看出，$E<em>{q} [\log(\frac{P(\mathbf{x},\mathbf{y}|\theta)}{q(\mathbf{y})})]$ 和似然函数 $\log(P(\mathbf{x}|\theta))$ 差了一个 $KL(q(\mathbf{y})|P(\mathbf{y}|\mathbf{x},\theta))$，那么可以将 $E</em>{q} [\log(\frac{P(\mathbf{x},\mathbf{y}|\theta)}{q(\mathbf{y})})]$ 看作是 $\log(P(\mathbf{x}|\theta))$ 的下界。对于 Expectation Step，我们做的是让 $q(\mathbf{y})=P(\mathbf{y}|\mathbf{x},\theta)$，即让下界等于似然函数。</p><p>然后考虑</p><script type="math/tex; mode=display">\begin{aligned}\log(P(\mathbf{x}|\theta))& \geq E_{q}[\log(\frac{P(\mathbf{x},\mathbf{y}|\theta)}{q(\mathbf{y})})]  \\& = E_q[\log(P(\mathbf{x},\mathbf{y}|\theta))]-E_q[\log(q(\mathbf{y}))] \\& = E_q[\log(P(\mathbf{x},\mathbf{y}|\theta))]+H(q(\mathbf{y}))\end{aligned}</script><p>可以发现式中 $E<em>q[\log(P(\mathbf{x},\mathbf{y}|\theta))]$ 即为我们在 Maximization Step 中优化的 $Q$ 函数。通过改变 $\theta$ 来最大化 $Q$ 函数，这就相当于提升了似然函数的下界 $E</em>{q} [\log(\frac{P(\mathbf{x},\mathbf{y}|\theta)}{q(\mathbf{y})})]$，同时 $\theta$ 的改变导致了 $P(\mathbf{y}|\mathbf{x},\theta)$ 的变化，使得似然函数再次大于它的下界。</p><p>该过程可由下图展示，其中 $\mathcal{F}$ 函数即为下界 $E_{q} [\log(\frac{P(\mathbf{x},\mathbf{y}|\theta)}{q(\mathbf{y})})]$.<br><img src='../../figure/机器学习笔记/2-Learning-theory/em_never_dec_likelihood.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h2 id="An-alternative-view-of-EM"><a href="#An-alternative-view-of-EM" class="headerlink" title="An alternative view of EM"></a>An alternative view of EM</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>记模型的隐变量为 $Y$，观察到的变量为 $X$，$X$ 和 $Y$ 之间一一对应。</p><p>或者从产生式的模型来理解，给定参数 $\theta$，$Y$ 能够得到分布 $q(Y)=q(y|\theta)$；同时在有了 $Y$ 之后，能够再产生 $X$，同样是按照一个分布来生成 $q(x|y,\theta)$。有了上面两点模型假设，理论上就可以得到联合概率分布：$q(x,y|\theta)=q(x|y,\theta)q(y|\theta)$，以及 $x$ 的概率分布 $q(x|\theta)=\int q(x,y|\theta)\mathrm{d}y$</p><p>建立了模型之后，我们希望能够拿模型来拟合数据，使得误差最小，即 likelihood 最大。</p><p>将数据记为 $\mathbf{X}<em>{N}=\left{ x_1,x_2, \ldots x</em>{N} \right}$，那么可以利用 $\delta$ 函数写出数据的分布：$p(x)=\delta(x-x_n)$。得到了数据之后，我们希望能够回推，即使用 $X$ 来推得 $Y$。将这个逆过程记为分布 $p(y|x)$。</p><p>此时可以得到两个联合概率分布：</p><script type="math/tex; mode=display">p(y|x)p(x) \quad q(x|y,\theta) q(y|\theta)</script><p>其中 $p(x)$ 给定，$q(x|y,\theta) q(y|\theta)$ 由模型给出，而 $p(y|x)$ 未知。由于我们希望模型能够刻画数据，因此两个联合概率分布的距离要尽量小。此时就可以使用 KL divergence 来刻画这件事：</p><script type="math/tex; mode=display">\min_{p(y|x), \theta} KL(p(y|x)p(x) || q(x|y,\theta)q(y|\theta))</script><p>再利用贝叶斯，$q(x|y,\theta) q(y|\theta) = q(x|\theta)q(y|x,\theta)$。那么从直观上看，可以让 $q(x|\theta)$ 和 $p(x)$ 匹配，让 $q(y|x,\theta)$ 和 $p(y|x)$ 匹配。</p><p><img src='../../figure/机器学习笔记/2-Learning-theory/em_overview.jpg' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="E-step-and-M-step"><a href="#E-step-and-M-step" class="headerlink" title="E-step and M-step"></a>E-step and M-step</h3><p>首先单独考察 $q(x|\theta)$ 和 $p(x)$</p><script type="math/tex; mode=display">\begin{aligned}& \min_{\theta} KL(p(x)||q(x|\theta)) \\= & \int p(x) \log \frac{p(x)}{q(x|\theta)} \mathrm{d}x \\= & \int p(x) \log p(x) \mathrm{d}x - \int p(x) \log q(x|\theta) \mathrm{d}x\end{aligned}</script><p>考虑到 $p(x)$ 为 $\delta(x-x_n)$ 的形式，以及 $\int p(x) \log p(x) \mathrm{d}x$ 为常数，则</p><script type="math/tex; mode=display">-\int p(x) \log q(x|\theta) \mathrm{d}x = -\log q(x_n|\theta)</script><p>但是以上最大似然的形式通常不好求，因此再考虑对 $p(y|x)p(x)$ 和 $q(x|y,\theta)q(y|\theta)$ 求 KL divergence。</p><script type="math/tex; mode=display">\begin{aligned}KL(p||q) & = KL(p(y|x)p(x) || q(x|y,\theta)q(y|\theta)) \\ & = \int p(y|x) p(x) \log \frac{p(y|x)p(x)}{q(x|y,\theta)q(y|\theta)}\mathrm{d}y \mathrm{d}x \\& = \int p(y|x) p(x) \log \frac{p(y|x)p(x)}{q(y|x,\theta)q(y|\theta)} \mathrm{d}y \mathrm{d}x \\& = \int_{x} p(x) \int_{y} p(y|x) \log \frac{p(y|x)}{q(y|x,\theta)}\mathrm{d}y \mathrm{d}x + \int_{x} p(x) \int_{y} p(y|x) \log \frac{p(x)}{q(x|\theta)} \mathrm{d}y \mathrm{d}x \\& = \int_{x} p(x) \int_{y} p(y|x) \log \frac{p(y|x)}{q(y|x,\theta)}\mathrm{d}y \mathrm{d}x + \int_{x} p(x) \int_{y} p(y|x) \left( \log p(x) - \log q(x|\theta) \right) \mathrm{d}y \mathrm{d}x \\& = \int_{x} p(x) [KL(p(y|x) || q(y|x,\theta)) - \log q(x|\theta)] \mathrm{d}x + \int_{x} p(x) \log p(x) \mathrm{d}x\end{aligned}</script><p><strong>E-step</strong> 的目标就是将上式中 $KL(p(y|x) || q(y|x,\theta))$ 最小化。同时上式还可以写成</p><script type="math/tex; mode=display">-KL(p||q) = \int p(y|x_n) \log \frac{q(x_n|y,\theta)q(y|\theta)}{p(y|x_n)} \mathrm{d}y + \int p(y|x) p(x) \log \frac{1}{p(x)} \mathrm{d}y \mathrm{d}x</script><p>可以看出式子的第一项就是 Q-function 的形式，<strong>M-step</strong> 最大化 Q-function，也即是在最小化 $p,q$ 之间的 KL divergence。</p><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><ul><li>If in the E-step, the posterior $p(y|x)$ cannot be computed analytically, then do you have any ideas to tackle this problem?</li></ul><p>在 E-step 中，后验通常不好计算，因为</p><script type="math/tex; mode=display">q(y|x,\theta) = \frac{q(x|y,\theta)q(y|\theta)}{q(x|\theta)}</script><p>中，分布通常需要积分才能获得，很有可能得不到解析解。</p><ol><li>一种近似的方式是 sampling，即使用计算机进行分布的模拟，然后采样得到概率分布。</li><li>可以给 $p(y|x)$ 假设一个简单的分布 $p(y|x,\phi)$，比如假设为高斯分布 $G(y|\mu(x),\Sigma(x))$。此时优化问题就从原来的 $\min<em>{p(y|x), \theta} KL(p(y|x)p(x) || q(x|y,\theta)q(y|\theta))$ 转变为 $\min</em>{\phi, \theta} KL(p(y|x)p(x) || q(x|y,\theta)q(y|\theta))$。</li></ol><ul><li>If in the M-step, the optimization by the Q function cannot be solved by letting the derivative equation equal to zero, then do you have any ideas to tackle this problem?</li></ul><p>虽然无法使得 $\frac{\partial Q}{\partial \theta}=0$，但是可以用梯度下降法来优化 $\theta$。</p><h2 id="Model-Selection"><a href="#Model-Selection" class="headerlink" title="Model Selection"></a>Model Selection</h2><p>不难发现，K-mean 算法和 GMM 算法都无法确定 cluster 的数量 $K$ 取多少合适，如果仅从优化结果来看，两者都是当 $K$ 越大时效果越好。因此我们需要一个算法来选择 $K$。</p><p>类比日常生活，做一件事时，我们希望使用更少的时间精力来达到比较好的效果，即边际效应。在模型中，使用足够多的高斯 (以GMM为例) 固然使得 likelihood 更大，但是会增加模型复杂度，增加了计算成本以及过拟合的风险。因此可以把模型的复杂度作为 penalty。</p><ul><li>Akaike’s Information Criterion (<strong>AIC</strong>): $\ln p(X<em>n|\hat{\Theta}</em>{K})-d_k$</li><li>Bayesian Information Criterion (<strong>BIC</strong>): $\ln p(X<em>n|\hat{\Theta}</em>{K})-\frac{1}{2}d_k \ln N$<ul><li>$d_k$: number of free parameters</li><li>$N$: sample size</li></ul></li></ul><p>算法的工作流程为：</p><ol><li>对于 $k=1,2, \ldots ,K<em>{\max</em>{}}$，计算最大似然：<script type="math/tex; mode=display">\widehat{\Theta}_{ML}(k)=\operatorname{argmax}\log[P(X|\Theta,k)]</script></li><li>在确定了参数之后，再选择 $k$ 使得 selection criterion (AIC, BIC) 最大：<script type="math/tex; mode=display">K^*=\underset{k}{\operatorname*{argmax}}J(\widehat{\Theta}_{ML}(k))</script></li></ol>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kernel Trick</title>
      <link href="/posts/71181c07.html"/>
      <url>/posts/71181c07.html</url>
      
        <content type="html"><![CDATA[<p>前面的特征降维是为了解决 overfitting 的问题，而 kernel trick 是为了提升维度，解决 underfitting 的问题。</p><p>比如下图中左侧，数据分布在二维空间中，此时无法使用线性分类器将数据分开；但是如果升维至右图所示三维空间，就能很容易的进行分类。<br><img src='../../figure/数据科学基础笔记/3-Kernel-Trick/kernel_trick.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h2 id="Kernel-SVM"><a href="#Kernel-SVM" class="headerlink" title="Kernel SVM"></a>Kernel SVM</h2><h3 id="Linear-SVM"><a href="#Linear-SVM" class="headerlink" title="Linear SVM"></a>Linear SVM</h3><h4 id="Hard-margin"><a href="#Hard-margin" class="headerlink" title="Hard margin"></a>Hard margin</h4><script type="math/tex; mode=display">\begin{aligned}\min_{\mathbf{w},b}\quad&\frac{1}{2}\|\mathbf{w}\|^2\\\mathrm{s.t.}\quad&y_i(\mathbf{w}^T\mathbf{x}_i+b)\geq1,\quad\forall i.\end{aligned}</script><p>下图中三条线的方程为：$\mathbf{w}^T\mathbf{x}+b=-1, \mathbf{w}^T\mathbf{x}+b=0, \mathbf{w}^T\mathbf{x}+b=1$。优化的目标是希望图中 margin 最大化。<br><img src='../../figure/数据科学基础笔记/3-Kernel-Trick/hard_margin_svm.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="Soft-margin"><a href="#Soft-margin" class="headerlink" title="Soft margin"></a>Soft margin</h4><p>有些时候数据并不适合或者并不能被完美的分开，此时就需要引入 soft margin。</p><script type="math/tex; mode=display">\begin{aligned}\min_{\mathbf{w},b,\xi_i}\quad &\frac12\|\mathbf{w}\|^2+C\sum_i\xi_i\\\mathrm{s.t.}\quad &y_i(\mathbf{w}^T\mathbf{x}_i+b)\geq1-\xi_i,\quad\forall i,\\&\xi_i\geq0,\quad\forall i.\end{aligned}</script><p><img src='../../figure/数据科学基础笔记/3-Kernel-Trick/soft_margin_svm.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>如果式子中 $C\rightarrow \infty$，soft margin 就会重新退化到 hard margin。</p><h3 id="Non-linear-SVM"><a href="#Non-linear-SVM" class="headerlink" title="Non-linear SVM"></a>Non-linear SVM</h3><p>使用升维函数 $\phi$，将样本 $\mathbf{x}_i$ 替换为 $\phi(\mathbf{x}_i)$。</p><script type="math/tex; mode=display">\begin{aligned}\min_{\mathbf{w},b,\xi_i}\quad&\frac12\|\mathbf{w}\|^2+C\sum_i\xi_i\\\mathrm{s.t.}\quad&y_i(\mathbf{w}^T\phi(\mathbf{x}_i)+b)\geq1-\xi_i,\quad\forall i,\\&\xi_i\geq0,\quad\forall i.\end{aligned}</script><p><img src='../../figure/数据科学基础笔记/3-Kernel-Trick/nonlinear_svm.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="Elevate-to-finite-dimension"><a href="#Elevate-to-finite-dimension" class="headerlink" title="Elevate to finite dimension"></a>Elevate to finite dimension</h4><p>可以手工设计升维函数，比如：</p><script type="math/tex; mode=display">\phi(\mathbf{x})=\phi([x_1,x_2])=[1, x_1, x_2, x_1x_2, x_1^{2}, x_2^{2}]</script><p>可以看出转换后的式子中含有 $0$ 阶项，$1$ 阶项，$2$ 阶项，所以升维函数设计的自由度是非常高的。</p><h4 id="Elevate-to-infinite-dimension"><a href="#Elevate-to-infinite-dimension" class="headerlink" title="Elevate to infinite dimension"></a>Elevate to infinite dimension</h4><p>在应用中用的都是一些常见的转换函数。同时很多 $\phi(\mathbf{x})$ 没有显示的形式，而是使用 $K(\mathbf{x},\mathbf{y})=\phi(\mathbf{x})^{\mathrm{T}}\phi(\mathbf{y})$ 来表示。</p><ul><li>Linear Kernel: $K(\mathbf{x},\mathbf{y})=\mathbf{x}^{\mathrm{T}}\mathbf{y}$ (即没有变化)</li><li>Polynomial kernel: $K(\mathbf{x},\mathbf{y})=(\mathbf{x}^T\mathbf{y}+c)^d$</li><li>Gaussian kernel (RBF kernel): $K(\mathbf{x},\mathbf{y})=\exp(\displaystyle -\frac{|\mathbf{x}-\mathbf{y}|^2}{2\sigma^2})$</li><li>Sigmoid kernel: $K(\mathbf{x},\mathbf{y})=\tanh(\alpha \mathbf{x}^{\mathrm{T}}\mathbf{y}+c)$</li><li>Inverse multi-quadratic kernel: $K(\mathbf{x},\mathbf{y})=\displaystyle \frac{1}{\sqrt{\left| \mathbf{x}-\mathbf{y} \right|_{} 2 \sigma^{2}+c^{2}}}$</li></ul><h3 id="Dual-form-of-SVM"><a href="#Dual-form-of-SVM" class="headerlink" title="Dual form of SVM"></a>Dual form of SVM</h3><p>支持向量机的具体推导可以参考<a href="https://zhuxz0299.github.io/posts/5f9d1835.html">文章</a>，此处仅做求解。</p><p>Primal form：</p><script type="math/tex; mode=display">\begin{aligned}\min_{\mathbf{w},b,\xi_i}\quad&\frac12\|\mathbf{w}\|^2+C\sum_i\xi_i\\\mathrm{s.t.}\quad&y_i(\mathbf{w}^T\phi(\mathbf{x}_i)+b)\geq1-\xi_i,\quad\forall i,\\&\xi_i\geq0,\quad\forall i.\end{aligned}</script><p>写出拉格朗日方程</p><script type="math/tex; mode=display">\mathcal{L}_{\mathbf{w},b,\xi_i}=\frac12\|\mathbf{w}\|^2+C\sum_i\xi_i-\sum_i\alpha_i\left(y_i(\mathbf{w}^T\phi(\mathbf{x}_i)+b)-1+\xi_i\right)-\sum_i\beta_i\xi_i</script><p>对自变量求导并带入</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial\mathcal{L}}{\partial\mathbf{w}}&=\mathbf{w}-\sum_i\alpha_iy_i\phi(\mathbf{x}_i)=\mathbf{0}\quad\Rightarrow\quad\mathbf{w}=\sum_i\alpha_iy_i\phi(\mathbf{x}_i)\\\frac{\partial\mathcal{L}}{\partial b}&=-\sum_i\alpha_iy_i=0\quad \Rightarrow \quad\sum_i\alpha_iy_i=0\\\frac{\partial\mathcal{L}}{\partial\xi_i}&=C-\alpha_i-\beta_i=0\quad \Rightarrow \quad\alpha_i+\beta_i=C\end{aligned}</script><p>得到对偶问题</p><script type="math/tex; mode=display">\begin{aligned}\min_{\alpha_i}&\quad\frac{1}{2}\sum_i\sum_j\alpha_i\alpha_jy_iy_jK(\mathbf{x}_i,\mathbf{x}_j)-\sum_i\alpha_i \quad(K(\mathbf{x}_i,\mathbf{x}_j)=\phi(\mathbf{x}_i)^T\phi(\mathbf{x}_j))\\\text{s.t.}&\quad\sum_i\alpha_iy_i=0,\\&\quad0\leq\alpha_i\leq C,\quad\forall i.\end{aligned}</script><h2 id="Kernel-trick-for-other-machine-learning-models"><a href="#Kernel-trick-for-other-machine-learning-models" class="headerlink" title="Kernel trick for other machine learning models"></a>Kernel trick for other machine learning models</h2><p>Kernel in logistic regression:</p><script type="math/tex; mode=display">\min_{\mathbf{w},b}\sum_j\frac1{1+\exp^{y_j(\mathbf{w}^T\phi(\mathbf{x}_j)+b)}}</script><p>利用 representation theorem $\mathbf{w}=\sum_{i}\alpha_i \phi(\mathbf{x}_i)$，得到</p><script type="math/tex; mode=display">\begin{aligned}\min_{\alpha_i}\sum_j\frac1{1+\exp^{y_j(\sum_i\alpha_i{K(\mathbf{x}_i,\mathbf{x_j})}+b)}}\end{aligned}</script><h2 id="Kernel-properties"><a href="#Kernel-properties" class="headerlink" title="Kernel properties"></a>Kernel properties</h2><ul><li><p>Symmetry</p><script type="math/tex; mode=display">  K(\mathbf{x},\mathbf{y})=K(\mathbf{y},\mathbf{x})</script></li><li><p>Cauchy-Schwarz Inequality</p><script type="math/tex; mode=display">  K(\mathbf{x},\mathbf{y})^2\leq K(\mathbf{x},\mathbf{x})K(\mathbf{y},\mathbf{y})</script><script type="math/tex; mode=display">  K(\mathbf x,\mathbf y)^2=(\mathbf x^T\mathbf y)^2\leq\|\mathbf x\|^2\|\mathbf y\|^2=(\mathbf x^T\mathbf x)(\mathbf y^T\mathbf y)=K(\mathbf x,\mathbf x)K(\mathbf y,\mathbf y)</script></li><li><p>Closure property</p><script type="math/tex; mode=display">  K(\mathbf{x},\mathbf{y})=c\cdot K_1(\mathbf{x},\mathbf{y})</script><script type="math/tex; mode=display">  K(\mathbf{x},\mathbf{y})=c+K_1(\mathbf{x},\mathbf{y})</script><script type="math/tex; mode=display">  K(\mathbf{x},\mathbf{y})=K_1(\mathbf{x},\mathbf{y})+K_2(\mathbf{x},\mathbf{y})</script><script type="math/tex; mode=display">  K(\mathbf{x},\mathbf{y})=K_1(\mathbf{x},\mathbf{y})\cdot K_2(\mathbf{x},\mathbf{y})</script></li></ul>]]></content>
      
      
      <categories>
          
          <category> data science </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Distance Metric</title>
      <link href="/posts/c8391a3e.html"/>
      <url>/posts/c8391a3e.html</url>
      
        <content type="html"><![CDATA[<h2 id="Distance-between-two-samples"><a href="#Distance-between-two-samples" class="headerlink" title="Distance between two samples"></a>Distance between two samples</h2><h3 id="Minkowski-distance"><a href="#Minkowski-distance" class="headerlink" title="Minkowski distance"></a>Minkowski distance</h3><p>即 $L_p$ distance。</p><script type="math/tex; mode=display">\begin{gathered}d(\mathbf{x},\mathbf{y}) =\left(\sum_i|x_i-y_i|^p\right)^{\frac1p} \\=(\sum_{i}|d_{i}|^{p})^{\frac1p} \end{gathered}</script><p>以下是几个比较重要的 $p$</p><ul><li>$p=\infty$，切比雪夫距离。$d(\bm{x},\bm{y})=\max_{i}\left\vert x_i-y_i \right\vert$</li><li>$p=2$，欧氏距离。$d(\bm{x},\bm{y})=\sqrt{\sum_{i}(x_i-y_i)^{2}}$</li><li>$p=1$，曼哈顿距离。$d(\bm{x},\bm{y})=\sum_{i}\left\vert x_i-y_i \right\vert$</li></ul><h3 id="Cosine-distance"><a href="#Cosine-distance" class="headerlink" title="Cosine distance"></a>Cosine distance</h3><p>通常和 cosine similarity 一起出现。</p><p>比较最常见的欧氏距离和余弦距离：</p><script type="math/tex; mode=display">\begin{aligned}&d_{euc}(\mathbf{x},\mathbf{y})=\|\mathbf{x}-\mathbf{y}\|=\sqrt{\|\mathbf{x}\|^2+\|\mathbf{y}\|^2-2\mathbf{x}^T\mathbf{y}} \\&Sim_{cos}(\mathbf{x},\mathbf{y})=\frac{\mathbf{x}^T\mathbf{y}}{\|\mathbf{x}\|\|\mathbf{y}\|}\end{aligned}</script><p>当 $\left| x \right|<em>{}=\left| y \right|</em>{}=1$，有</p><script type="math/tex; mode=display">d_{euc}(\mathbf{x},\mathbf{y})=\sqrt{2-2\mathbf{x}^T\mathbf{y}}=\sqrt{2-2sim_{cos}(\mathbf{x},\mathbf{y})}</script><h3 id="Metric-learning"><a href="#Metric-learning" class="headerlink" title="Metric learning"></a>Metric learning</h3><ul><li>What if different dimension are heterogeneous?<br>比如有向量 $\bm{u}$，一个维度为身高，另一个维度为体重。那么直接计算距离 $\left| \bm{u}<em>{1}-\bm{u}</em>{2} \right|_{}$ 是不合理的。此时可以考虑使用 Z-score normalization。</li><li>What if different dimension are heterogeneous?<br><img src='../../figure/数据科学基础笔记/2-Distance-Metric/sample_heterogeneous.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></li></ul><p>此时可以考虑将两个不同样本的特征从不同空间投影到相同的空间: $d(\bm{x},\bm{y}) \Rightarrow d(\bm{P}\bm{x},\bm{P}\bm{y})$<br><img src='../../figure/数据科学基础笔记/2-Distance-Metric/feature_projection.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="Mahalanobis-distance"><a href="#Mahalanobis-distance" class="headerlink" title="Mahalanobis distance"></a>Mahalanobis distance</h4><p>首先引入欧氏距离的拓展：马氏距离。</p><ul><li>欧氏距离：<script type="math/tex; mode=display">d(\mathbf{x},\mathbf{y})=\|\mathbf{x}-\mathbf{y}\|=\sqrt{(\mathbf{x}^T-\mathbf{y}^T)(\mathbf{x}-\mathbf{y})}</script></li><li>马氏距离：<script type="math/tex; mode=display">d(\mathbf{P}\mathbf{x},\mathbf{P}\mathbf{y})=\|\mathbf{P}\mathbf{x}-\mathbf{P}\mathbf{y}\|=\sqrt{(\mathbf{x}^T-\mathbf{y}^T)\mathbf{P}^T\mathbf{P}(\mathbf{x}-\mathbf{y})}=\sqrt{(\mathbf{x}^T-\mathbf{y}^T)\mathbf{M}(\mathbf{x}-\mathbf{y})}</script></li></ul><h4 id="Metric-learning-1"><a href="#Metric-learning-1" class="headerlink" title="Metric learning"></a>Metric learning</h4><p>即学习 $M$，得到更好地距离度量。</p><script type="math/tex; mode=display">\begin{aligned}\max_{\mathbf{M}}&\sum_{(\mathbf{x}_i,\mathbf{x}_j)\in\mathcal{D}}d_M^2(\mathbf{x}_i,\mathbf{x}_j)\\\mathrm{s.t.}&\sum_{(\mathbf{x}_i,\mathbf{x}_j)\in\mathcal{S}}d_M^2(\mathbf{x}_i,\mathbf{x}_j)\leq1,\\&\mathbf{M}\succeq\mathbf{0}.\end{aligned}</script><p>式中 $\mathcal{D}$ 意为 different，表示 $\bm{x}_i,\bm{x}_j$ 属于不同种类；$\mathcal{S}$ 意为 same，表示 $\bm{x}_i,\bm{x}_j$ 属于相同种类。$\mathbf{M}\succeq\mathbf{0}$ 表示 $\mathbf{M}$ 为半正定矩阵。<br><img src='../../figure/数据科学基础笔记/2-Distance-Metric/metric_learning.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="Earth-Mover’s-Distance-EMD"><a href="#Earth-Mover’s-Distance-EMD" class="headerlink" title="Earth Mover’s Distance (EMD)"></a>Earth Mover’s Distance (EMD)</h3><p>首先把两个样本转化为两个集合</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{S}&=\{(\mathbf{x}_1^s,w_1^s),(\mathbf{x}_2^s,w_2^s),\ldots,(\mathbf{x}_m^s,w_m^s)\}\\[1ex]\mathcal{T}&=\{(\mathbf{x}_1^t,w_1^t),\ldots,(\mathbf{x}_n^t,w_n^t)\}\end{aligned}</script><p>式中 $(\bm{x}^{s}_{1},w_1^{s})$ 是一个 pair，可以理解为一个属性和这个属性的占比。</p><p>比如考虑两张图片的距离，集合中的 pair 可以理解为颜色以及颜色在图片中的占比。<br><img src='../../figure/数据科学基础笔记/2-Distance-Metric/color_histogram.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>算法可以按照如下图片理解：<br><img src='../../figure/数据科学基础笔记/2-Distance-Metric/emd.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>我们需要将左侧的土堆推到右边的坑中。左侧每个土堆的即某种属性的占比；右侧每个坑的容量则是另一个样本中的某个属性的占比。一个土堆到一个坑之间的距离可以理解为两个属性的特征向量的距离。总的距离就是最小的运输代价：</p><script type="math/tex; mode=display">\begin{aligned}\begin{aligned}\min_{f_{ij}}\end{aligned}& \begin{aligned}\sum_{i=1}^m\sum_{j=1}^nf_{ij}d_{ij}\end{aligned}  \\\text{s.t.}& \begin{aligned}f_{ij}\geq0,\quad1\leq i\leq m,1\leq j\leq n,\end{aligned}  \\&\begin{aligned}\sum_{j=1}^nf_{ij}\le w_i^s,\quad1\le i\le m,\end{aligned} \\&\begin{aligned}\sum_{i=1}^mf_{ij}\leq w_j^t,\quad1\leq j\leq n,\end{aligned} \\&\begin{aligned}\sum_{i=1}^m\sum_{j=1}^nf_{ij}=\min(\sum_{i=1}^mw_i^s,\sum_{j=1}^nw_j^t).\end{aligned}\end{aligned}</script><h2 id="Application-of-distance"><a href="#Application-of-distance" class="headerlink" title="Application of distance"></a>Application of distance</h2><h3 id="Retrieval"><a href="#Retrieval" class="headerlink" title="Retrieval"></a>Retrieval</h3><p>检索问题，在以图搜图等应用中会用到。比如下面的图希望找到最接近五角星的一个样本。<br><img src='../../figure/数据科学基础笔记/2-Distance-Metric/retrieval.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="Classifica-KNN"><a href="#Classifica-KNN" class="headerlink" title="Classifica: KNN"></a>Classifica: KNN</h3><p>KNN 即找到离目标样本点最近的 $k$ 个样本点，然后判断目标样本点属于哪一类。<br><img src='../../figure/数据科学基础笔记/2-Distance-Metric/knn.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="Verification"><a href="#Verification" class="headerlink" title="Verification"></a>Verification</h3><p>判断两个样本点是否属于同一个种类。可以应用于人脸识别，比如判断两个样本点之间的距离是否会大于某个阈值。<br><img src='../../figure/数据科学基础笔记/2-Distance-Metric/verification.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="Outlier-detection"><a href="#Outlier-detection" class="headerlink" title="Outlier detection"></a>Outlier detection</h3><p>找到 outlier。可以对于每个样本，计算离它最近的其他样本的距离。<br><img src='../../figure/数据科学基础笔记/2-Distance-Metric/outlier_detection.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><h2 id="Distance-between-two-distributions"><a href="#Distance-between-two-distributions" class="headerlink" title="Distance between two distributions"></a>Distance between two distributions</h2><p>想要计算两个分布之间的距离，可以先得到概率分布，然后计算概率分布的距离。<br><img src='../../figure/数据科学基础笔记/2-Distance-Metric/two_distribution.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><ul><li>Canberra distance: $d(\mathbf{p},\mathbf{q})=\sum_{i=1}^d\frac{|p_i-q_i|}{p_i+q_i}$</li><li>Chi-Square distance: $d(\mathbf{p},\mathbf{q})=\sum_{i=1}^d\frac{(p_i-q_i)^2}{p_i}$</li><li>Intersection between two histograms: $d(\mathbf{p},\mathbf{q})=\sum_{i=1}^d\min(p_i,q_i)$</li></ul><p>但是使用概率分布进行距离度量是比较粗糙的度量方式，忽略了 $x_i,x_j$ 两两样本之间的关系。</p><h3 id="Maximum-Mean-Discrepancy-MMD"><a href="#Maximum-Mean-Discrepancy-MMD" class="headerlink" title="Maximum Mean Discrepancy (MMD)"></a>Maximum Mean Discrepancy (MMD)</h3><p>计算两个数据分布中心的欧氏距离。同样是比较粗糙的距离度量方式。<br><img src='../../figure/数据科学基础笔记/2-Distance-Metric/mmd.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></p><script type="math/tex; mode=display">D_{MMD}=[\sum_{i}x_{i}p(x_{i})-\sum_{i}x_{i}q(x_{i})]^{2}</script><h3 id="Kullback-Leibler-KL-divergence"><a href="#Kullback-Leibler-KL-divergence" class="headerlink" title="Kullback-Leibler(KL) divergence"></a>Kullback-Leibler(KL) divergence</h3><script type="math/tex; mode=display">\begin{aligned}D_{KL}(p|q)& =\sum_ip(x_i)\log\frac{p(x_i)}{q(x_i)}  \\&\begin{aligned}&=-\sum_ip(x_i)\log q(y_i)+\sum_ip(x_i)\log p(x_i)\end{aligned} \\&=H(p,q)-H(p)\end{aligned}</script><p>上式中 $H(p,q)$ 表示 $p,q$ 之间的交叉熵，$H(p)$ 为样本 $p$ 的熵。</p><p>但是 KL divergence 是不对称的，即 $d(p,q)\neq d(p,q)$，因此衍生出了一些解决不对称问题的度量方式。</p><ul><li>Jeffrey divergence<script type="math/tex; mode=display">\begin{aligned}D_{JD}& \begin{aligned}=D_{KL}(p||q)+D_{KL}(q||p)\end{aligned}  \\&\begin{aligned}=\sum_ip(x_i)\log\frac{p(x_i)}{q(x_i)}+\sum_iq(x_i)\log\frac{q(x_i)}{p(x_i)}\end{aligned}\end{aligned}</script></li><li>Jensen-Shannon(JS) divergence<script type="math/tex; mode=display">\begin{aligned}D_{JD}& \begin{aligned}=\frac{1}{2}D_{KL}\left(p||\frac{1}{2}(p+q)\right)+\frac{1}{2}D_{KL}\left(q||\frac{1}{2}(p+q)\right)\end{aligned}  \\&\begin{aligned}&=\sum_i\frac{1}{2}p(x_i)\log\frac{p(x_i)}{\frac{1}{2}(p(x_i)+q(x_i))}+\frac{1}{2}\sum_iq(x_i)\log\frac{q(x_i)}{\frac{1}{2}(p(x_i)+q(x_i))}\end{aligned}\end{aligned}</script></li></ul><h3 id="Bregman-divergence"><a href="#Bregman-divergence" class="headerlink" title="Bregman divergence"></a>Bregman divergence</h3><p>这是一个广义的距离度量方式，可以通过修改参数 $\varphi$ 来变成其他的距离度量方式。</p><script type="math/tex; mode=display">\begin{aligned}&\mathbf{p}=[p(x_{1}),p(x_{2}),\ldots,p(x_{n})] \\&\mathbf{q}=[q(x_1),q(x_2),\ldots,q(x_n)] \\&D_\varphi(p,q)=\varphi(\mathbf{p})-\varphi(\mathbf{q})-(\mathbf{p}-\mathbf{q})^T\nabla\varphi(\mathbf{q}) \\\end{aligned}</script><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>比如 $\varphi(\mathbf{z})=\frac{1}{2}\mathbf{z}^{\mathrm{T}}\mathbf{z}$ 时，</p><script type="math/tex; mode=display">\begin{aligned}D_\varphi(\mathbf{p},\mathbf{q})~&=\varphi(\mathbf{p})-\varphi(\mathbf{q})-(\mathbf{p}-\mathbf{q})^T\nabla\varphi(\mathbf{q}) \\&= \frac{1}{2} \left\| \mathbf{p}-\mathbf{q} \right\|_{}^{2}\end{aligned}</script><p>变成欧式距离。<br><img src='../../figure/数据科学基础笔记/2-Distance-Metric/bregman_divergence1.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>当 $\varphi(\mathbf{z})=\mathbf{z}^T\log\mathbf{z}$ 时，</p><script type="math/tex; mode=display">\begin{aligned}D_\varphi(\mathbf{p},\mathbf{q})& =\varphi(\mathbf{p})-\varphi(\mathbf{q})-(\mathbf{p}-\mathbf{q})^T\nabla\varphi(\mathbf{q})  \\&\begin{aligned}&=\sum_ip(x_i)\log\frac{p(x_i)}{q(x_i)}-\sum_ip(x_i)+\sum_iq(x_i)\end{aligned}\end{aligned}</script><p>得到的就是标准的 KL divergence。<br><img src='../../figure/数据科学基础笔记/2-Distance-Metric/bregman_divergence2.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p>]]></content>
      
      
      <categories>
          
          <category> data science </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Zero-sum Game</title>
      <link href="/posts/3235c627.html"/>
      <url>/posts/3235c627.html</url>
      
        <content type="html"><![CDATA[<h2 id="LP-Duality"><a href="#LP-Duality" class="headerlink" title="LP Duality"></a>LP Duality</h2><p>Prime problem:</p><script type="math/tex; mode=display">\begin{aligned}\max_{\mathbf{x}} \mathbf{c}^{\mathrm{T}}\mathbf{x}\\s.t. \quad \mathbf{A}\mathbf{x}\le \mathbf{b}\\\mathbf{x}\ge 0\end{aligned}</script><p>Interpretation:</p><ul><li>$x_i$: amount of product $i$ produced</li><li>$b_i$: amount of raw material of type $i$ available</li><li>$a_{ij}$: amount of raw material $i$ used to produced $1$ unit of product $j$</li><li>$c_j$: profit from $1$ unit of product $j$</li></ul><p>Dual problem:</p><script type="math/tex; mode=display">\begin{aligned}\min_{y} \mathbf{b}^{\mathrm{T}}\mathbf{y} \\s.t. \quad \mathbf{A}^{\mathrm{T}}\mathbf{y}\ge \mathbf{c}\\\mathbf{y}\ge 0\end{aligned}</script><ul><li>$y_i$ 可以理解为单位原材料 $i$ 的售价</li><li>$\mathbf{A}^{\mathrm{T}}\mathbf{y}\ge \mathbf{c}$ 是因为只有当直接售卖原材料的收益大于产品利润是，才会出售</li><li>$\min_{y} \mathbf{b}^{\mathrm{T}}\mathbf{y}$ 是买家希望最小化支出</li></ul><p>有结论：<br>$\mathbf{b}^{\mathrm{T}}\mathbf{y}^{<em>}=\mathbf{c}^{\mathrm{T}}\mathbf{x}^{</em>}$</p><p>Strong Duality of LP:<br>If the primal and dual are feasible, then both have the same optimal objective value. (feasible 表示有解)</p><h3 id="Farka’s-lemma"><a href="#Farka’s-lemma" class="headerlink" title="Farka’s lemma"></a>Farka’s lemma</h3><p>Exactly one of the following statements is true:</p><ul><li>$\exists \mathbf{x}\ge 0,\quad s.t. ~\mathbf{A}\mathbf{x}=\mathbf{b}$</li><li>$\exists \mathbf{y}, \quad s.t. ~\mathbf{y}^{\mathrm{T}}\mathbf{A}\ge 0 \text{ and } \mathbf{y}^{\mathrm{T}}\mathbf{b}&lt;0 $</li></ul><h4 id="Geometric-Interpretation-of-Fraka’s"><a href="#Geometric-Interpretation-of-Fraka’s" class="headerlink" title="Geometric Interpretation of Fraka’s"></a>Geometric Interpretation of Fraka’s</h4><p>考虑二维的情形，记组成 $\mathbf{A}$ 的向量为 $\mathbf{a}_1,\mathbf{a}_2$<br><img src='../../figure/博弈论笔记/frakas_lemma.jpg' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>如果想要满足第一个条件，那么向量 $\mathbf{b}$ 应当在图像中高亮区域内；但是如果要满足第二个条件，则需要找到 $\mathbf{y}$，使得向量 $\mathbf{a}_1,\mathbf{a}_2$ 和 $\mathbf{b}$ 应当正好在直线 $\mathbf{y}^{\mathrm{T}}\mathbf{x}=0$ 的两侧。因此此两个条件只能有一个满足。</p><h4 id="Proof-of-Duality"><a href="#Proof-of-Duality" class="headerlink" title="Proof of Duality"></a>Proof of Duality</h4><p>要证明 $\mathbf{b}^{\mathrm{T}}\mathbf{y}^{<em>}=\mathbf{c}^{\mathrm{T}}\mathbf{x}^{</em>}$，可以先证明左边小于等于右边，再证明右边小于等于左边。</p><script type="math/tex; mode=display">\mathbf{c}^{\mathrm{T}}\mathbf{x}=\mathbf{x}^{\mathrm{T}}\mathbf{c}\le \mathbf{x}^{\mathrm{T}}\mathbf{A}^{\mathrm{T}}\mathbf{y} \le \mathbf{b}^{\mathrm{T}}\mathbf{y}</script><p>现在希望证明 $\mathbf{c}^{\mathrm{T}}\mathbf{x}^{<em>}\ge \mathbf{b}^{\mathrm{T}}\mathbf{y}^{</em>}$</p><p>记 $\mathbf{c}^{\mathrm{T}}\mathbf{x}^{<em>}=\Delta$，由于 $\mathbf{x}^{</em>}$ 为最优解，因此</p><script type="math/tex; mode=display">\not \exists \mathbf{c}^{\mathrm{T}}\mathbf{x}\ge \Delta+\varepsilon (\forall \varepsilon>0), \mathbf{A}\mathbf{x}\le \mathbf{b}, \mathbf{x}\ge 0</script><p>我们使用 $\alpha_0, \mathbf{\alpha}$ 将不等式写为等式</p><script type="math/tex; mode=display">-\mathbf{c}^{\mathrm{T}}\mathbf{x}+\alpha_0  = -\Delta + \varepsilon, \mathbf{A}\mathbf{x}+\mathbf{\alpha} = \mathbf{b}, \alpha_0, \mathbf{\alpha}, \mathbf{x}\ge 0</script><p>将其写为矩阵形式</p><script type="math/tex; mode=display">\begin{pmatrix}     -\mathbf{c}^{\mathrm{T}} & 1 & \mathbf{0} \\    \mathbf{A} & \mathbf{0} & \mathbf{I}\end{pmatrix} \begin{pmatrix}     \mathbf{x} \\ \alpha_0 \\ \mathbf{\alpha} \end{pmatrix} =\begin{pmatrix}     -\Delta - \varepsilon \\ \mathbf{b}\end{pmatrix}</script><p>由 Farkas’ lemma，因为上述方程不存在解，因此</p><script type="math/tex; mode=display">\exists \lambda_0\ge 0, \mathbf{\lambda}_1 \ge 0</script><p>使得</p><script type="math/tex; mode=display">-\mathbf{c}^{\mathrm{T}}\lambda_0 + \mathbf{\lambda}_1^{\mathrm{T}}\mathbf{A}\ge 0 \text{ and } -(\Delta+\varepsilon)\lambda_0 + \mathbf{\lambda}_1^{\mathrm{T}}\mathbf{b} < 0 \\\Rightarrow \frac{1}{\lambda_0} \mathbf{\lambda}_1^{\mathrm{T}}\mathbf{A} \ge \mathbf{c}^{\mathrm{T}} \text{ and } \frac{1}{\lambda_0}\mathbf{\lambda}_1^{\mathrm{T}}\mathbf{b}<\Delta + \varepsilon</script><p>令 $y = \mathbf{\lambda}_1 / \lambda_0$，那么对于 $\forall \varepsilon&gt;0$，都有 $\mathbf{y^{*}}^{\mathrm{T}}\mathbf{b} \le \mathbf{y}^{\mathrm{T}}\mathbf{b}&lt;\Delta+\varepsilon$，因此</p><script type="math/tex; mode=display">\mathbf{y^{*}}^{\mathrm{T}}\mathbf{b}\le \Delta=\mathbf{c}^{\mathrm{T}}\mathbf{x}^{*}</script><h3 id="Another-explanation-of-Duality"><a href="#Another-explanation-of-Duality" class="headerlink" title="Another explanation of Duality"></a>Another explanation of Duality</h3><p>将原问题写为：</p><script type="math/tex; mode=display">\begin{aligned}\max_{\mathbf{x}} \mathbf{c}^{\mathrm{T}}\mathbf{x}\\s.t. \quad \mathbf{a}_1^{\mathrm{T}} \mathbf{x}\le b_1\\\mathbf{a}_2^{\mathrm{T}} \mathbf{x}\le b_2 \\\cdots \\\mathbf{a}_n^{\mathrm{T}} \mathbf{x}\le b_n \\\mathbf{x}\ge 0\end{aligned}</script><p>引入一系列系数 $y_1,y_2, \ldots ,y_n&gt;0$，则有</p><script type="math/tex; mode=display">y_1 \mathbf{a}_1^{\mathrm{T}}\mathbf{x} \le b_1 y_1\\y_2 \mathbf{a}_2^{\mathrm{T}}\mathbf{x} \le b_2 y_2\\\cdots \\y_n \mathbf{a}_n^{\mathrm{T}}\mathbf{x} \le b_n y_n</script><p>假如满足条件 $y_1 \mathbf{a}_1^{\mathrm{T}} + y_2 \mathbf{a}_2^{\mathrm{T}} + \cdots + y_n \mathbf{a}_n^{\mathrm{T}}\ge \mathbf{c}^{\mathrm{T}}$，即 $\mathbf{A}^{\mathrm{T}}\mathbf{y}\ge \mathbf{c}$，则有</p><script type="math/tex; mode=display">\mathbf{c}^{\mathrm{T}}\mathbf{x} \le (y_1 \mathbf{a}_1^{\mathrm{T}} + y_2 \mathbf{a}_2^{\mathrm{T}} + \cdots + y_n \mathbf{a}_n^{\mathrm{T}})\mathbf{x} \le \mathbf{b}^{\mathrm{T}}\mathbf{y}</script><p>从而得到了对偶问题。</p><p>从直观上来说，就是希望 $\mathbf{c}$ 能够被 $\mathbf{a}_1,\mathbf{a}_2, \ldots \mathbf{a}_n$ 的线性组合得到，从而就可以确定 $\mathbf{c}^{\mathrm{T}}\mathbf{x}$ 的上界；同理，这个上界也是 $\mathbf{b}^{\mathrm{T}}\mathbf{y}$ 的下界。</p><h2 id="Two-player-zero-sum-Game"><a href="#Two-player-zero-sum-Game" class="headerlink" title="Two-player zero sum Game"></a>Two-player zero sum Game</h2><ul><li>Two player p1,p2</li><li>Payoff to p1 = - Payoff to p2</li></ul><p>Let:</p><ul><li>$A(i,j)$ is the payoff to p1 when $i$ is p1’s action, $j$ is p2’s action.</li><li>$x$: prob distribution over p1’s actions</li><li>$y$: prob distribution over p2’s actions</li></ul><script type="math/tex; mode=display">\Rightarrow u_1(x,y)=\sum_{ij}A(i,j)x_i y_j = \mathbf{x}^{\mathrm{T}}\mathbf{A}\mathbf{y}\\u_2(x,y) = -u_1(x,y)</script><p>Thus a NE $(x^{<em>},y^{</em>})$ satisfies</p><script type="math/tex; mode=display">\begin{aligned}&(x^{*})^{\mathrm{T}}A y^{*} \ge x ^{\mathrm{T}} A y^{*}\\\text{and~} &(x^{*})^{\mathrm{T}} A y^{*}\le (x^{*})^{\mathrm{T}}A y\end{aligned}</script><p>我们称 $(x^{<em>},y^{</em>})$ 是 saddle point</p><h3 id="Minmax-Theorem"><a href="#Minmax-Theorem" class="headerlink" title="Minmax Theorem"></a>Minmax Theorem</h3><ol><li><script type="math/tex; mode=display"> \min_{y} \max_{x} x^{\mathrm{T}}Ay = \max_{x} \min_{y} x^{\mathrm{T}}Ay  \tag{1}</script><p> 上述结果得到的值我们称其为 game 的 value。</p></li><li><script type="math/tex; mode=display"> \max_{x}(\min_{y}x^{\mathrm{T}}Ay) \tag{2.1}</script><script type="math/tex; mode=display"> \min_{y}(\max_{x}x^{\mathrm{T}}Ay) \tag{2.2}</script><p> $x^{<em>}$ solves (2.1), $y^{</em>}$ solves (2.2). Then</p><ul><li>$(x^{<em>},y^{</em>})$ is NE</li><li>$(x^{<em>})^{\mathrm{T}}Ay^{</em>}$ is the value of the game</li></ul></li><li>If $(x^{<em>},y^{</em>})$ is a NE<ul><li>$(x^{<em>})^{\mathrm{T}}Ay^{</em>}$ is the value of the game</li><li>$x^{<em>}$ solves (2.1), $y^{</em>}$ solves (2.2)</li></ul></li></ol><p>以上三个条件得到的 $(x^{<em>},y^{</em>})$ 都是相同的。</p><h4 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h4><ol><li><p>Suppose p1 wants to maximize its worst case payoff</p><script type="math/tex; mode=display"> \max_{x} \min_{y} x^{\mathrm{T}}Ay\\ = \max_{x} \min_{j} (x^{\mathrm{T}}A)_{j}</script><p> 问题转化为 LP 问题，可以用 LP Duality 来解</p><script type="math/tex; mode=display"> \max_{x,v_1} v_1 \\ \tag{LP1} s.t. \quad v_1\le (x^{\mathrm{T}}A)_{j}  ,\forall j\\ x\ge 0</script><p> Similarly, p2’s problem is </p><script type="math/tex; mode=display"> \min_{y,v_2} v_2 \\ \tag{LP2} s.t. \quad v_2\ge (Ay)_{i}, \forall i \\ y\ge 0</script><p> Thus by strong duality, we have $v_1^{<em>}=v_2^{</em>}$, or </p><script type="math/tex; mode=display"> \max_{x}\min_{y}x^{\mathrm{T}}Ay=\min_{y}\max_{x}x^{\mathrm{T}}Ay</script></li><li><p>Let $x^{\star }$ be a solution of LP1. From the constraint</p><script type="math/tex; mode=display"> \begin{aligned}v_1^\star\leq(x^{\star\mathrm{T}}A)_j\forall j\end{aligned}</script><p> Multiply $y_j^\star$ and sum over $j$, we get</p><script type="math/tex; mode=display"> \begin{aligned}\sum_jv_1^\star y_j^\star\leq\sum_j(x^{\star\mathrm{T}}A)_jy_j^\star\end{aligned}</script><script type="math/tex; mode=display"> \Rightarrow v_{1}^{\star}\leq x^{\star\mathrm{T}}Ay^{\star}</script><p> where $y^{\star }$ is the solution of LP2. Similarly, we can show that</p><script type="math/tex; mode=display"> v_{2}^{\star}\geq x^{\star\mathrm{T}}Ay^{\star}</script><p> Since $v<em>{1}^{\star }= v</em>{2}^{\star }$, we have</p><script type="math/tex; mode=display"> x^{\star\mathrm{T}}Ay^{\star}=\max_{x}\min_{y}x^{\mathrm{T}}Ay=\min_{y}\max_{x}x^{\mathrm{T}}Ay</script><p> Then we can show that $( x^\star , y^\star )$ is a NE.</p><script type="math/tex; mode=display"> \operatorname*{min}_{y}x^\mathrm{\star T}Ay=\operatorname*{max}_{x}\operatorname*{min}_{y}x^\mathrm{T}Ay=\operatorname*{min}_{y}\operatorname*{max}_{x}x^\mathrm{T}Ay=\operatorname*{max}_{x}x^\mathrm{T}Ay^{\star} \ge x^{\star \mathrm{T}}Ay^{\star}</script><p> $\Rightarrow y^\star$ solves $\min<em>{y} \max</em>{x} x^\mathrm{T} Ay$</p><p> Similarly, $x^{<em>}$ solves $\max<em>{x}\min</em>{y}x^{\mathrm{T}}Ay$. So $(x^{</em>},y^{*})$ is a NE.</p></li><li><p>Suppose $(x^{<em>},y^{</em>})$ is a NE, then</p><script type="math/tex; mode=display"> x^{* {\mathrm{T}}} A y^{*} = \min_{y} x^{* {\mathrm{T}}} A y \le \max_{x} \min_{y} x^{\mathrm{T}}Ay</script><p> Similarly, </p><script type="math/tex; mode=display"> x^{* {\mathrm{T}}}A y^{*} = \max_{x} x^{\mathrm{T}}Ay\ge \min_{y} \max_{x} x^{\mathrm{T}}Ay</script><script type="math/tex; mode=display"> \Rightarrow\min_y\max_xx^{\mathrm{T}}Ay\leq x^{\star\mathrm{T}}Ay^{\star}\leq\max_x\min_yx^{\mathrm{T}}Ay</script><p> Considering</p><script type="math/tex; mode=display"> \begin{aligned}\min_y\max_xf(x,y)\geq\max_x\min_yf(x,y)\end{aligned}</script><p> So</p><script type="math/tex; mode=display"> \min_{y}x^{\star\mathsf{T}}Ay=x^{\star\mathsf{T}}Ay^{\star}=\max_{x}\min_{y}x^{\mathsf{T}}Ay\geq\min_{y}x^{\mathsf{T}}Ay\forall x</script><p> $\Rightarrow x^{<em>}$ maximizes $\min_{y}x^{\mathrm{T}}Ay$. Similarly, $y^{</em>}$ minimizes $\max_{x}x^{\mathrm{T}}Ay$</p></li></ol><h4 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h4><p>$(x^{<em>},y^{</em>})$, $(\tilde{x},\tilde{y})$ are NE, then $(x^{<em>},\tilde{y})$, $(\tilde{x},y^{</em>})$ are also NE.</p><h2 id="None-Zero-Sum-Game"><a href="#None-Zero-Sum-Game" class="headerlink" title="None Zero Sum Game"></a>None Zero Sum Game</h2><p>$u<em>i(a_i,a</em>{-i})$ payoff to p1, $a<em>i\in A_i$ (discrete, finite)<br>$p</em>{i}(a<em>i)=\operatorname{Pr}(\text{player } i \text{ plays } a_i)$<br>$u_i(p</em>{i},p<em>{-i})=E(\text{payoff to } p</em>{i})$</p><h3 id="Theorem-A-NE-exists"><a href="#Theorem-A-NE-exists" class="headerlink" title="Theorem: A NE exists."></a>Theorem: A NE exists.</h3><p>Let $C \subseteq{\mathbb{R}^{n}}$ be a convex, closed, bounded set. Let $f: C \rightarrow C$ be a continuous function. The $f$ has a fixed point, i.e. $\exists x \in C, x=f(x)$。从直观上来说，就是符合条件的 $y=f(x)$ 与 $y=x$ 必定有交点。</p><p>Let $p=(p<em>1,p_2, \ldots ,p_n)$ be a set of strategies.<br>Define $r_i(a_i)=(u_i(a_i,p</em>{-i})-u<em>i(p</em>{i},p<em>{-i}))^{+}$，这个变量表示的是从策略 $p</em>{i}$ 变化到 $a<em>i$ 之后收益的增加量。我们希望能找到 $p</em>{i}^{*}$，使得 $\forall a_i$，有 $r_i(a_i)=0$，此时就能够得到一个纳什均衡。</p><p>Define</p><script type="math/tex; mode=display">f_i(p_{i}(a_i)) = \frac{p_{i}(a_i)+r_i(a_i)}{\sum_{\alpha}(p_{i}(\alpha)+r_i(\alpha))}</script><p>$p<em>{i}(a_i)$ 表示的是对于策略 $p</em>{i}$，选中 $a<em>i$ 的概率。可以看出这个式子相当于求出 $p</em>{i}(a_i)+r_i(a_i)$ 在所有可能中的权重。</p><p>记</p><script type="math/tex; mode=display">f(p) = \begin{pmatrix}     f_1(p_1) \\ f_2(p_2) \\ \vdots \\ f_n(p_n)\end{pmatrix}</script><ol><li>注意到 $p=(p_1,p_2, \ldots p_n) \subseteq[0,1]^{n}$，$p \in $ closed, bounded, convex set</li><li>$f$ 是一个连续函数</li></ol><p>所以存在一个 fixed point $p$，$p=f(p)$，此时利用 $f$ 的表达式，应当有</p><script type="math/tex; mode=display">p_{i}(a_i) = \frac{p_{i}(a_i)+r_i(a_i)}{\sum_{\alpha}(p_{i}(\alpha)+r_i(\alpha))}</script><p>同样的，我们希望证明 $r_i(a_i)=0$。</p><p>First, we claim that for each $i$, $\exists a_i, s.t.~ r_i(a_i)=0$.<br>Suppose for some $i$, $r_i(a_i)&gt;0, \forall a_i$ </p><script type="math/tex; mode=display">\Rightarrow u_i(a_i,p_{-i})>u_i(p_{i},p_{-i}) ,\forall a_i</script><script type="math/tex; mode=display">\Rightarrow \sum_{a_i\in A_i}p_{i}(a_i) u_i(p_{i},p_{-i}) > u_i(p_{i},p_{-i})</script><script type="math/tex; mode=display">\Leftrightarrow u_i(p_{i},p_{-i})>u_i(p_{i},p_{-i})</script><p>which is contradictory.</p><p>Fix $i$, let $a_i$ be $r_i(a_i)=0$</p><script type="math/tex; mode=display">p_{i}(a_i) = \frac{p_{i}(a_i)}{\sum_{\alpha}(p_{i}(\alpha)+ r_i(\alpha))}</script><script type="math/tex; mode=display">\Rightarrow \sum_{\alpha\in A_i} p_{i}(\alpha) + \sum_{\alpha \in A_i}r_i(a_i)=1</script><script type="math/tex; mode=display">\Rightarrow \sum_{\alpha \in A_i}r_i(\alpha) = 0</script><p>Thus, $\forall \alpha\in A_i, r_i(\alpha)=0$</p><h3 id="Proof-using-the-kakvtani-fixed-point-theorem"><a href="#Proof-using-the-kakvtani-fixed-point-theorem" class="headerlink" title="Proof using the kakvtani fixed point theorem"></a>Proof using the kakvtani fixed point theorem</h3><p>Let $C$ be a closed, bounded, convex subset of $\mathbb{R}^{n}$. Let $f$ be a corresponding mapping each point in $C$ to a subset of $C$.</p><script type="math/tex; mode=display">f: C \rightarrow 2^{C}</script><p>需要证明这一点是因为之前遇到过 $p \in BP(p)$，这也是一个从 point 到 subset 的映射。</p><p>Suppose that:</p><ol><li>$f(x)\neq \emptyset~\forall x$, </li><li>$f(x)$ is a convex set $\forall x$</li><li>$f$ has a closed graph. ($f$ has a closed graph if all sequence $\left{ x_n \right} \in C$ and $\left{ y_n \right}$, $(x_n,y_n)\rightarrow(x,y)$ with $y_n\in f(x_n)$, $\Rightarrow y\in f(x)$).</li></ol><p>Then $f$ has a fixed point in $C$, $x\in f(x)$.</p><p>To estalish the existance of a solution to </p><script type="math/tex; mode=display">p\in BP(p)</script><p>where</p><script type="math/tex; mode=display">p=\begin{pmatrix}     p_1\\ p_2\\ \vdots \\ p_{n}\end{pmatrix}  \quadBP(p) = \begin{pmatrix}     BP(p_{-1}) \\ BP(p_{-2}) \\ \vdots \\ BP(p_{-n})\end{pmatrix}</script><p>We will verify BP has all the properties required in the kakvtani FP theorem.</p><ol><li>$BP(p)$ is a non-empty for each $p$. 这是显然的，因为在别人给出了策略的情况下，我们总能找到最大化自身收益的策略。</li><li>根据 convex 的定义。If $p<em>{i}^{*}, \tilde{p</em>{i}} \in BP(p<em>{-i})$, $\alpha p</em>{i}^{*}+(1-\alpha)\tilde{p<em>{i}} \in BP(p</em>{-i})$。这也是显然的。由以下 $u_i$ 的定义<script type="math/tex; mode=display">u_i(p_{i},p_{-i}) = \sum_{a} u_i(a_i, a_{-i}) p_1(a_1) p_2(a_2) \cdots  p_n(a_n)</script>从线性的特征可以看出 <script type="math/tex; mode=display">u_i(p_{i},p_{-i}) = u_i(\tilde{p_{i}},p_{-i}) = \alpha u_i(p_{i},p_{-i}) + (1-\alpha) u_i(\tilde{p_{i}},p_{-i}) = u_i(\alpha p_{i}^{*}+(1-\alpha)\tilde{p_{i}},p_{-i})</script></li><li>Let $(p<em>{i}^{(n)}, p</em>{-i}^{(n)}) \rightarrow (p<em>{i}, p</em>{-i})$ and  $p<em>{i}^{(n)} \in  BP</em>{i}(p<em>{-i}^{(n)})$<br> Suppose that $p</em>{i} \not \in BP<em>{i}(p</em>{-i})$. Then $\exists \hat{p}_i$ and $\varepsilon&gt;0$<script type="math/tex; mode=display"> u_i(\hat{p}_i,p_{-i})\ge  u_i(p_{i},p_{-i}) + \varepsilon</script> <strong>$\hat{p}<em>i$ is a better response for $p</em>{-i}^{(n)}$ (for some $n$) then $p_{i}^{(n)}$ thus contradictory</strong>.<br> For sufficiently large $n$, <script type="math/tex; mode=display"> \begin{aligned} u_i(\hat{p}_i,p_{-i}^{(n)}) &\ge  u_i(\hat{p}_i,p_{-i}) - \frac{\varepsilon}{2}  \\ &\ge u_i(p_{i},p_{-i}) + \varepsilon -\frac{\varepsilon}{2} \\ &\ge  u_i(p_{i}^{(n)}, p_{-i}^{(n)}) - \frac{\varepsilon}{4} + \frac{\varepsilon}{2} \\ &=u_i(p_{i}^{(n)},p_{-i}^{(n)}) + \frac{\varepsilon}{4} \end{aligned}</script></li></ol>]]></content>
      
      
      <categories>
          
          <category> game theory </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 scp 传输文件</title>
      <link href="/posts/fdcecd69.html"/>
      <url>/posts/fdcecd69.html</url>
      
        <content type="html"><![CDATA[<p>scp 是 secure copy 的缩写, scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>参考<a href="https://www.runoob.com/linux/linux-comm-scp.html">菜鸟教程</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [可选参数] file_source file_target </span><br></pre></td></tr></table></figure><p>常用的参数有：</p><ul><li>-p：保留原文件的修改时间，访问时间和访问权限。</li><li>-q： 不显示传输进度条。</li><li>-r： 递归复制整个目录。</li><li>-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li><li>-P port：注意是大写的P, port是指定数据传输用到的端口号</li></ul><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>将 <code>/home/space/music/1.mp3</code> 复制到服务器的 <code>/home/root/others/music</code> 文件夹下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music </span><br></pre></td></tr></table></figure></p><p>将 <code>/home/space/music/1.mp3</code> 复制到服务器的 <code>/home/root/others/music</code> 文件夹下并重命名：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music/001.mp3</span><br></pre></td></tr></table></figure></p><p>如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 4588 remote@www.runoob.com:/usr/local/sin.sh /home/administrator</span><br></pre></td></tr></table></figure></p><h2 id="在同一局域网内并且IP使用了NAT"><a href="#在同一局域网内并且IP使用了NAT" class="headerlink" title="在同一局域网内并且IP使用了NAT"></a>在同一局域网内并且IP使用了NAT</h2><p>如果两台计算机在同一局域网内，并且IP使用了NAT技术，公网IP相同，那么如果依然指定端口号并且使用公网IP，则会无法连接。此时需要使用私有IP。</p><p>可以通过 <code>ifconfig</code> 命令查询网络情况，找到IP地址：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eno1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">    inet 192.168.1.65  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">    inet6 fe80::6934:bdca:ea9f:a54c  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">    ether 3c:ec:ef:af:8b:c8  txqueuelen 1000  (以太网)</span><br><span class="line">    RX packets 219744940  bytes 321364062938 (321.3 GB)</span><br><span class="line">    RX errors 0  dropped 119923  overruns 0  frame 0</span><br><span class="line">    TX packets 30847625  bytes 2581137691 (2.5 GB)</span><br><span class="line">    TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></p><p>然后在使用 scp 时使用私有IP，并且不用指定端口。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> scp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Strategy-form Game</title>
      <link href="/posts/a4a6120d.html"/>
      <url>/posts/a4a6120d.html</url>
      
        <content type="html"><![CDATA[<ul><li>player/agent: $n$</li><li>(pure) stratety/action: $a_i\in A_i$ ($A_i$ 是一个离散的有限集合)<ul><li>(mixed) strategy: $p<em>{i}$，即在 $A_i$ 上的概率分布。并且 $p</em>{i}(a)=\operatorname{Pr}(\text{player i plays action } a)$</li></ul></li><li>utility/payoff for user i: $u_i(a_1,a_2, \ldots ,a_n)$<ul><li>对于 mixed strategy $(p<em>1, p_2, \ldots ,p</em>{n})$ 来说，utility 应该为(此处假设了 mixed strategy 的概率独立同分布)<script type="math/tex; mode=display">\sum_{a_1\in A_1}\sum_{a_2\in A_2}\cdots \sum_{a_{n}\in A_{n}} u_i(a_1,a_2, \ldots ,a_n)p_1(a_1)p_2(a_2)\cdots p_n(a_n)</script></li><li>上式可以简记为 $u<em>i(p</em>{i},-p_{i})$</li></ul></li></ul><p>Best response for player i:<br>给定其他 agent 的策略 $p<em>{-i}$，记 Best response 为 $BP</em>{i}(p_{-i})$，有</p><script type="math/tex; mode=display">BP_{i}(p_{-i}) = \argmax_{p_{i}} u_i(p_{i},p_{-i})</script><ul><li>$BP<em>{i}(p</em>{-i})$ 可能是一个集合。 (有多个满足条件的 $p_{i}$)</li><li>$BP<em>{i}(p</em>{-i})$ 是一个 convex set。 (即假如 $p<em>1,p_2 \in BP</em>{i}(p<em>{-i})$，那么 $p_3=\alpha p_1+(1-\alpha)p_2, \alpha \in (0,1)$，仍满足 $p_3\in BP</em>{i}(p_{-i})$)。</li></ul><h2 id="纳什均衡"><a href="#纳什均衡" class="headerlink" title="纳什均衡"></a>纳什均衡</h2><p>纳什均衡 (Nash Equilibrium)：用于刻画 $n$ 个 agent 的策略<br>如果 $u<em>i(p</em>{i},p<em>{-i}^{*})\le u_i(p</em>{i}^{<em>},p_{-i}^{</em>}), \forall i,p_{i}$，那么 $p^{<em>}=(p_1^{</em>},p_2^{<em>}, \ldots ,p_n^{</em>})$ 是一个纳什均衡。</p><p>由于 $p<em>{i}^{*}\in BP</em>{i}(p_{-i}^{*})$，那么可以写出</p><script type="math/tex; mode=display">\begin{pmatrix}     p_1^{*} \\ p_2^{*} \\ \vdots \\ p_n^{*} \end{pmatrix} \in \begin{pmatrix}     BP_1(p_{-1}^{*})  \\ BP_2(p_{-2}^{*}) \\ \vdots \\ BP_{n}(p_{-n}^{*})\end{pmatrix} \Rightarrowp^{*} \in  BP(p^{*})</script><p>因此算子 $BP$ 如果有不动点(fixed point)，那么存在纳什均衡。在数学上可以证明上述不动点总是存在的，因此纳什均衡也总是有 mixed strategy。</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>partner game</p><ul><li>player：p1,p2</li><li>actions: work hard, be lazy ($W,L$)</li><li>utility:<br>  | (p1,p2) | $W$     | $L$    |<br>  | ———- | ———- | ——— |<br>  | $W$     | (10,10) | (-5,5) |<br>  | $L$     | (5,-5)  | (0,0)  |</li></ul><p>满足纳什均衡的 pure strategy 有 $(W,W)$ 和 $(L,L)$。<br>对于 mixed strategy，设 p1 work 的概率为 $x$, lazy 的概率为 $1-x$；p2 work 和 lazy 的概率则为 $y$ 和 $1-y$。此时两个 player 的 utility 为：</p><script type="math/tex; mode=display">\begin{aligned}u_1 &= 10xy+(-5)x(1-y)+5(1-x)y+0(1-x)(1-y) = 10xy+5y-5x = 5x(2y-1) + 5y \\u_2 &= 5y(2x-1) + 5x\end{aligned}</script><script type="math/tex; mode=display">\Rightarrow x^{*}=\begin{cases}    1 \text{~ if y > 1/2} \\    0 \text{~ if y < 1/2} \\    [0,1] \text{~ if y = 1/2} \\\end{cases} \quad y^{*}=\begin{cases}    1 \text{~ if x > 1/2} \\    0 \text{~ if x < 1/2} \\    [0,1] \text{~ if x = 1/2} \\\end{cases}</script><p>由图像可得最终结果为 $(1 /2, 1/2)$</p><p><img src='../../figure/博弈论笔记/partner_game.jpg' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><h2 id="Dominant-amp-Dominated-Strategy"><a href="#Dominant-amp-Dominated-Strategy" class="headerlink" title="Dominant &amp; Dominated Strategy"></a>Dominant &amp; Dominated Strategy</h2><h3 id="Dominant-Strategy"><a href="#Dominant-Strategy" class="headerlink" title="Dominant Strategy"></a>Dominant Strategy</h3><p>A strategy is a dominant strategy for player $i$ if </p><script type="math/tex; mode=display">u_i(a_i,a_{-i})\le u_i(a_i^{*},a_{-i}) \quad \forall a_i, a_{-i}</script><p>可以看出这个条件比纳什均衡更强。</p><p>A strategy profile $A=(a_1^{<em>},a_2^{</em>}, \ldots ,a_n^{<em>})$ is a dominant strategy equilibrium if $a_i^{</em>}$ is a dominant strategy for each player $i$.</p><p>DSE(Dominant Strategy Equilibrium)并不是总是存在的，而 NE 却总是存在的。</p><h4 id="prisoner-dilemma-Example"><a href="#prisoner-dilemma-Example" class="headerlink" title="prisoner dilemma Example"></a>prisoner dilemma Example</h4><ul><li>player：p1,p2</li><li>actions: confess, deny ($C,D$)</li><li>utility:<br>  | (p1,p2) | $C$     | $D$     |<br>  | ———- | ———- | ———- |<br>  | $C$     | (-3,-3) | (0,-5)  |<br>  | $D$     | (-5,0)  | (-1,-1) |</li></ul><p>在这个例子中，无论对手选择的是什么，选择 $C$ 总是对自己更加有利的。因此 $(C,C)$ 不仅是一个 pure strategy NE，同时也是 Dominant Strategy。</p><h3 id="Dominated-Strategy"><a href="#Dominated-Strategy" class="headerlink" title="Dominated Strategy"></a>Dominated Strategy</h3><p>A strategy  $a_i$ is a dominated strategy for player $i$ if $\exists a_i’$</p><script type="math/tex; mode=display">u_i(a_i',a_{-i}) > u_i(a_i,a_{-i}) \quad \forall a_{-i}</script><p>因此假如一个 game 里存在 dominated strategy，我们就可以直接将这个策略去掉。</p><h4 id="prisoner-dilemma-Example-1"><a href="#prisoner-dilemma-Example-1" class="headerlink" title="prisoner dilemma Example"></a>prisoner dilemma Example</h4><p>还是上面的例子，但是让第一个囚徒加上自杀(suicide)的选项：</p><div class="table-container"><table><thead><tr><th>(p1,p2)</th><th>$C$</th><th>$D$</th></tr></thead><tbody><tr><td>$C$</td><td>(-3,-3)</td><td>(0,-5)</td></tr><tr><td>$D$</td><td>(-5,0)</td><td>(-1,-1)</td></tr><tr><td>S</td><td>(-100,-3)</td><td>(-100,0)</td></tr></tbody></table></div><p>此时 $S$ 对于 $C$ 来说就是一个 dominated strategy。</p><h2 id="Correlated-Equilibrium"><a href="#Correlated-Equilibrium" class="headerlink" title="Correlated Equilibrium"></a>Correlated Equilibrium</h2><p>Let $P(a)$ be a (joint) probability distribution over $a\in A_1\times A_2\times \cdots \times A_n$, then $P^{*}(a)$ is a correlated equilibrium (CE) if </p><script type="math/tex; mode=display">\sum_{a_{-i}}p^{*}(a_{-i}|a_i)\times u_i(a_i,a_{-i}) \ge  \sum_{a_{-i}} p^{*}(a_{-i}|a_i)\times u_i(a_i',a_{-i}) \quad \forall a_i,a_i'</script><p>这里表示所有的 player 都没有动机去 deviate。</p><p>上面的式子经过数学变换之后同样可以写为</p><script type="math/tex; mode=display">\sum_{a_{-i}}p^{*}(a_{-i}, a_i)\times u_i(a_i,a_{-i}) \ge  \sum_{a_{-i}} p^{*}(a_{-i}, a_i)\times u_i(a_i',a_{-i}) \quad \forall a_i,a_i'</script><p>我们希望能够调整 $P(a)$ 使得结果更优，因此这是个优化问题：</p><script type="math/tex; mode=display">\max_{} \sum_{} p^{*}(a) u_i(a) \\\sum_{a\in A} p^{*}(a)=1 \\p^{*}(a)\ge 0</script><p>可以看出这是个线性规划，有多项式复杂度的方法可以求解。但是 MNE(Mixed Nash Equilibrium) 是没有特定解法的。因此 Correlated Equilibrium 更弱。</p><h3 id="Traffic-light-game-Example"><a href="#Traffic-light-game-Example" class="headerlink" title="Traffic light game Example"></a>Traffic light game Example</h3><h4 id="Example1"><a href="#Example1" class="headerlink" title="Example1"></a>Example1</h4><div class="table-container"><table><thead><tr><th>(p1,p2)</th><th>$Go$</th><th>$Yield$</th></tr></thead><tbody><tr><td>$Go$</td><td>(-10,-10)</td><td>(5,0)</td></tr><tr><td>$Yield$</td><td>(0,5)</td><td>(-1,-1)</td></tr></tbody></table></div><p>可以得到</p><ul><li>pure NE: $(G,Y)$, $(Y,G)$</li><li>mixed NE: $x=\operatorname{Pr}(\text{player 1 plays G}), y=\operatorname{Pr}(\text{player 2 plays G})$<ul><li>$x^{<em>}=y^{</em>}=3 /8$</li></ul></li><li>the expected payoff to p1 is $-15 /32$</li></ul><p>上述情况是两个人的选择是独立的。但是假如出现了红绿灯，那么就会影响两个 player 的选择。假设</p><script type="math/tex; mode=display">\operatorname{Pr}(G,Y)=0.5 \quad \operatorname{Pr}(Y,G)=0.5</script><p>其中 $(G,Y)$ 表示红绿灯推荐 player 1 往前走，player 2 停下。</p><p>那么此时我们需要考虑两个 player 是否会遵守红绿灯。</p><ul><li>If p1 is told to play $G$, it knows that p2 is playing $Y$</li><li>If p1 is told to play $Y$, it knows that p2 is playing $G$</li></ul><p>the expected payoff to p1 is $3/2$</p><p>可以得知两个 player 都会遵守。</p><h4 id="Example2"><a href="#Example2" class="headerlink" title="Example2"></a>Example2</h4><p>假如红绿灯的情况更加复杂</p><script type="math/tex; mode=display">\operatorname{Pr}(G,Y)=0.55 \quad \operatorname{Pr}(Y,G)=0.4 \quad \operatorname{Pr}(Y,Y)=0.05</script><ul><li>If p1 is told to play $G$, it knows that p2 is playing $Y$</li><li>If p1 is told to play $Y$, it knows the probability of p2 playing $Y$ is $1/9$; $G$ is $8 /9$。<ul><li>If p1 stick to $Y$, its expected payoff is $1 /9 \times (-1) + 8 /9 \times 0 = -1/ 9$</li><li>If p1 stick to $Y$, its expected payoff is $1 /9 \times 5 + 8 /9 \times (-10) = -75/ 9$</li></ul></li></ul><p>因此 player 仍然会选择 $Y$。</p>]]></content>
      
      
      <categories>
          
          <category> game theory </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Introduction</title>
      <link href="/posts/ed318fdc.html"/>
      <url>/posts/ed318fdc.html</url>
      
        <content type="html"><![CDATA[<h2 id="Game-Theory"><a href="#Game-Theory" class="headerlink" title="Game Theory"></a>Game Theory</h2><p>所有的智能体(agent)在同一个环境中，且都是自私理性(self-interested)的，博弈论研究这些智能体的行为。</p><p>这门课需要回答的问题：</p><ul><li>What to expect? 即 game 的最终状态，比如生态系统中生物最后的稳态分布。</li><li>How good is it? 即最终的 game 的状态是否是好的状态。</li><li>Can it be controlled? 即我们能否控制这个 game 使之达到一个好的状态。</li></ul><p><img src='../../figure/博弈论笔记/academic_foundatoins.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h2 id="3-Board-Goals"><a href="#3-Board-Goals" class="headerlink" title="3 Board Goals"></a>3 Board Goals</h2><h3 id="Games-and-Equilibria"><a href="#Games-and-Equilibria" class="headerlink" title="Games and Equilibria"></a>Games and Equilibria</h3><p>Understand outcomes arising from interaction of intelligent and self-interested agents.</p><p>需要知道：</p><ul><li>是否存在均衡(equilibria)？</li><li>均衡是否唯一？</li><li>如何得到均衡？</li></ul><h4 id="Prisoner’s-Dilemma"><a href="#Prisoner’s-Dilemma" class="headerlink" title="Prisoner’s Dilemma"></a>Prisoner’s Dilemma</h4><p><img src='../../figure/博弈论笔记/prisoner_dilemma.png' width=240 style="display: block; margin-left: auto; margin-right: auto;"></p><p>无论另一个人选什么，选择 C(confess) 对于自己来说结果总是更优的，因此两者都 confess 是唯一的均衡(equilibria)状态。但是对于两个囚徒而言，这个结果并不是最优的。</p><h4 id="Static-Games-with-Complete-Information"><a href="#Static-Games-with-Complete-Information" class="headerlink" title="Static Games with Complete Information"></a>Static Games with Complete Information</h4><ul><li>Model for strategic games: matrix games (Prisoner’s Dilemma) and continuous games (Cournot Game)</li><li>Solution concepts: equilibrium hierarchy (几个 equilibrium 是从强到弱的关系)<ul><li>Dominant and Dominated Strategies </li><li>Pure Nash Equilibrium (NE) and Mixed Nash Equilibrium</li><li>Correlated Equilibrium</li></ul></li><li>Existence of NE: a fixed point of best-response correspondences.<ul><li>For finite games, Nash’s Theorem shows the existence of a mixed NE using fixed-point theorems.</li><li>For continuous games, show the existence of pure NE under convexity assumption.</li><li>For general continuous games, Glicksberg’s Theorem shows the existence of mixed NE.</li><li>For discontinous games, existence of a mixed equilibrium established under some assumptions.</li></ul></li><li>Uniqueness of NE using “strict diagonal concavity”</li></ul><p><strong>没太搞懂</strong></p><h3 id="Price-of-Anarchy"><a href="#Price-of-Anarchy" class="headerlink" title="Price of Anarchy"></a>Price of Anarchy</h3><p>Analyze quality of the outcome arising from strategic interaction, i.e. OPT vs NE.</p><p>即分析的是在博弈论中，每个个体的自私性对于整个系统总的结果的影响。</p><h4 id="Braess’-Paradox"><a href="#Braess’-Paradox" class="headerlink" title="Braess’ Paradox"></a>Braess’ Paradox</h4><p><img src='../../figure/博弈论笔记/braess_paradox.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>假设总共有 $60$ 个人需要从起点 $s$ 到终点 $t$。对于图上标的两个 $x$ minutes 的路径，我们假设 $x=n$，其中 $n$ 为走在这条路上的人数。那么每个人在追求自己时间最小化的情况下，两条路最终都会有 $30$ 个人，所有人的总时间都是 $90$ 分钟。</p><p>但是如果中间又新修了一条路<br><img src='../../figure/博弈论笔记/braess_paradox_2.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>会发现所有人都会走 $x$ minutes 的那条路，导致 $x=60$。那么所有人从 $s$ 到 $t$ 的时间变成了 $120$ 分钟，结果反而更差了，这是作为 game 的结果。而在新的情况下，这个系统整体的最优解依然是像原来一样，时间应当为 $90$ 分钟，这是作为 optimization 的结果。</p><p>于是我们可以得到新的情况的 Price of Anarchy (PoA) 为</p><script type="math/tex; mode=display">\frac{worst~NE}{OPT} = \frac{2}{1.5} = \frac{4}{3}</script><p>PoA 就是用来衡量 game 的结果(outcome)的质量(quality)，希望越小越好。</p><h3 id="Mechanism-Design"><a href="#Mechanism-Design" class="headerlink" title="Mechanism Design"></a>Mechanism Design</h3><p>Designing rules to ensure “good” outcome under strategic interaction among selfish agents. </p><p>即如何设计 game 的规则(rule)，使得最后的结果是好的，即让 PoA 更小。</p><h2 id="More-on-Game-Theory"><a href="#More-on-Game-Theory" class="headerlink" title="More on Game Theory"></a>More on Game Theory</h2><p>Optimization Theory: </p><ul><li>Maximize $\sum_{i}u_i(x)$</li><li>Subject to $x\in \bm{X} \subset \mathbb{R}^{n}$</li></ul><p>假设最后的解为 $x^{*}$，这就是一个 optimal 的解。</p><p>Game Theory:</p><ul><li>共有 $n$ 个 agent，每个 agent 选择一个 $x_i \in \mathbb{R}$ 使得自己的 utility $u_i(x)$ 最大。其中 $u_i(x)$ 也可以写成<script type="math/tex; mode=display">u_i(x_i,x_{-i}), \quad x_{-i} = (x_1, \ldots ,x_{i-1}, x_{i+1}, \ldots , x_n)</script></li></ul><p>在多个 agent 的共同作用下，也可以得到一个解，或者说是一个 equilibrium，记为 $\hat{x}^{*}$。</p><h3 id="Example-Resource-Allocation"><a href="#Example-Resource-Allocation" class="headerlink" title="Example: Resource Allocation"></a>Example: Resource Allocation</h3><p>资源有限，需要竞争。假设总共的资源为 $1$，有 $3$ 个 agent 来竞争，并且这三个 agent 的 utility 分别为：</p><script type="math/tex; mode=display">u_0(x_0)=\log(x_0) \quad u_1(x_1)=3\log(x_1) \quad u_2(x_2)=4\log(x_2)</script><p>Optimization Problem:</p><script type="math/tex; mode=display">\max_{x_0+x_1+x_2\le 1} \log x_0 + 3 \log x_1 + 4 \log x_2</script><p>可以解得最优情况为 $x_0^{<em>}=1 / 8, x_1^{</em>}=3/8, x_2^{*}=1 /2$，总的 utility 约为 $-3.39$。</p><p>Game Problem:<br>系统不知道每个 agent 实际的 utility。每个 agent 为了最大化自己的 utility，都 report $u<em>0(x)=u_1(x)=u_2(x)=4\log x$ (假设这个就是最大值)。那么最终做出的分配就为 $\hat{x}</em>{0}^{<em>}=\hat{x}_{1}^{</em>}=\hat{x}_{2}^{*}=1 /3$，导致实际的总 utility 约为 $-3.82$</p><p>strategy</p>]]></content>
      
      
      <categories>
          
          <category> game theory </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Feature Engineering</title>
      <link href="/posts/20a3e8df.html"/>
      <url>/posts/20a3e8df.html</url>
      
        <content type="html"><![CDATA[<h2 id="Feature-Engineering"><a href="#Feature-Engineering" class="headerlink" title="Feature Engineering"></a>Feature Engineering</h2><h3 id="Data-to-information"><a href="#Data-to-information" class="headerlink" title="Data to information"></a>Data to information</h3><p>给定数据(data) $\rightarrow$ 提取特征(feature) $\rightarrow$ 得到信息(information)。<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/data_to_information.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="Traditional-machine-learning-and-deep-learning"><a href="#Traditional-machine-learning-and-deep-learning" class="headerlink" title="Traditional machine learning and deep learning"></a>Traditional machine learning and deep learning</h4><p><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/traditional_ml_and_dl.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><ul><li>Traditional machine learing<ul><li>Hand-craft feature</li><li>Not end-to-end</li></ul></li><li>Deep learning<ul><li>Learnable feature</li><li>End-to-end</li></ul></li></ul><h3 id="Extract-key-information-as-feature"><a href="#Extract-key-information-as-feature" class="headerlink" title="Extract key information as feature"></a>Extract key information as feature</h3><ul><li>Q: What is feature?</li><li>A: Key information</li></ul><p>比如对于一张图片，初始的特征(naive feature)存在很多冗余，即对特定的任务来说没有用。因此需要做特征提取，抓住有用的信息。<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/feature_extractor.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="How-to-extract-robust-features"><a href="#How-to-extract-robust-features" class="headerlink" title="How to extract robust features"></a>How to extract robust features</h4><p>比如在图片中要识别一只猫，我们希望 feature extractor 对于大小、旋转角度等无关因素是鲁棒的。</p><ul><li>From data perspective<ul><li>数据增广，增加训练集的多样性<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/enrich_training_set.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></li></ul></li><li>From model perspective<ul><li>在传统的机器学习中，需要设置一个比较好的特征提取器。</li><li>在深度学习中，特征提取是隐式的，那么就需要设计神经网络的层。</li></ul></li></ul><h4 id="Scale-Invariant-Feature-Transform-SIFT"><a href="#Scale-Invariant-Feature-Transform-SIFT" class="headerlink" title="Scale-Invariant Feature Transform (SIFT)"></a>Scale-Invariant Feature Transform (SIFT)</h4><p>在深度学习之前最流行的特征提取的方式。<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/sift.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><ul><li>首先分成两个分组，表示大尺度和小尺度</li><li>然后对图片做高斯模糊，得到高斯金字塔(Gaussian pyramid)，比如图中从下到上图片依次更加模糊，那么也就就会依次丢失一些信息</li><li>让高斯金字塔的相邻两层做差，得到 Difference of Gaussian (<strong>DoG</strong>)。</li><li>不同层的 DoG 表示了不同层次的细节信息。同时结合不同尺度，我们就得到了不同层次，不同尺度的细节信息。</li></ul><p>然后需要在 DoG 中检测出局部最大值和最小值，这些都是比较关键的点，对应图片中的 key point (如轮廓点、拐点等)。<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/keypoint_in_dog.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>找到关键点之后，需要提取这些关键点的描述子(descriptor)。在 SIFT 中，找到关键点之后，会在关键点的邻域取一个 $16\times 16$ 像素的 patch，每一个 patch 中又分出 $16$ 个 subpatch。在每个 subpatch 中有 $16$ 个像素，对每个像素求梯度(gradient)，定义 $8$ 个梯度方向，从而每个 subpatch 都能得到一个梯度直方图(gradient histogram)。<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/get_descriptor.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>一个直方图对应一个 $8$ 维的向量，因为共有 $16$ 个直方图，因此拼接之后能够得到 $16\times 8$ 维的特征向量，作为整个 patch 的描述。即该关键点的描述子。</p><ul><li>梯度方向：便于分辨拐点、边缘等比较重要的地方</li><li>分 subpatch：保持了空间上的信息。假如只有一个 patch，那么就无法保持某个像素邻域的空间信息。</li></ul><p>SIFT 方法可以通过某些拓展来解决图像偏转的问题。在获得 key point 的 descriptor 之后，可以找到一个像素梯度最多的方向，即寻找图片的主导方向(dominant direction)。然后可以通过 dominant direction 让图片转回来。<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/rotation_invariant.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="Feature-extraction-in-deep-learning"><a href="#Feature-extraction-in-deep-learning" class="headerlink" title="Feature extraction in deep learning"></a>Feature extraction in deep learning</h4><p>涉及较多数学原理，略。</p><h3 id="Post-processing-on-features"><a href="#Post-processing-on-features" class="headerlink" title="Post-processing on features"></a>Post-processing on features</h3><p>即提取完特征之后，在分类器进行分类之前，可以对特征进行处理。</p><h4 id="L-p-normalization"><a href="#L-p-normalization" class="headerlink" title="$L_{p}$ normalization"></a>$L_{p}$ normalization</h4><p>对于一个向量 $\bm{x}=(x_1, x_2, \ldots ,x_n)$</p><ul><li>$L<em>p$ norm: $(\sum</em>{i}\left\vert x_i \right\vert^{p} )^{\frac{1}{p}}$</li><li>$L<em>p$ normalization: $\displaystyle \bm{\tilde{x}} = \frac{\bm{x}}{(\sum</em>{i}\left\vert x_i \right\vert ^{p})^{\frac{1}{p}}}$</li></ul><p>$\bm{\tilde{x}}$ 就是进行了 $L_p$ normalization 之后的特征。</p><p>下图是 $p$ 取不同值时二维的 $\bm{\tilde{x}}$ 的形状：<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/lp_norm.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="Z-score-normalization"><a href="#Z-score-normalization" class="headerlink" title="Z-score normalization"></a>Z-score normalization</h4><p>还是拿二维的特征向量 $\bm{x}=(x_1,x_2)$ 举例。假如有很多特征向量，那么我们可以得到这些特征向量 $\bm{x}$ 的分布，以及分量 $x_1$ 和 $x_2$ 的分布 $p(x_1)$ 和 $p(x_2)$。<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/z_score.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>假如 $p(x_1)$ 和 $p(x_2)$ 相差过大，可能会影响分类器的性能，因此我们希望拉近两个维度的分布。此时可以使用 z-score normalization。记 $x_1,x_2$ 的均值，标准差分别为 $\mu_1,\mu_2$ 和 $\sigma_1,\sigma_2$，在 z-score normalization 后，有：</p><script type="math/tex; mode=display">\tilde{x_1} = \frac{x_1-\mu_1}{\sigma_1}， \quad \tilde{x_2} = \frac{x_2-\mu_2}{\sigma_2}</script><p>Z-score normalization 和 $L_p$ normalization 可以叠加使用。</p><h3 id="How-to-preserve-spatial-information"><a href="#How-to-preserve-spatial-information" class="headerlink" title="How to preserve spatial information"></a>How to preserve spatial information</h3><p>时间信息和空间信息的保留方式类似。</p><p>对于之前提到的 SIFT，如果最后对所有关键点的特征向量做平均；或者在卷积神经网络中做全局池化(Global Average Pooling, GAP)，那么将会损失很多空间信息。</p><h4 id="Spatial-pyramid"><a href="#Spatial-pyramid" class="headerlink" title="Spatial pyramid"></a>Spatial pyramid</h4><p>保留空间信息一个常见的方式是空间金字塔(Spatial pyramid)，即将整张图片分为不同的层级，每个层级有不同的 scale。<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/spatial_pyramid.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>比如首先将图片等分为 $16$ 个 patch，每个 patch 得到一个 $256$ 维的特征，共有 $16\times 256$ 维的特征；然后如果分为 $4$ 个 patch，有 $4\times 256$ 维的特征；最后考虑整张图片，有 $256$ 维的特征。最终将所有得到的特征按顺序拼接起来，拼接的顺序就能够保持图片的空间信息。</p><h4 id="Position-embedding"><a href="#Position-embedding" class="headerlink" title="Position embedding"></a>Position embedding</h4><p>embedding 同样也指的是表征某种信息的意思，比如 feature vector 也称为 feature embedding。feature embedding 保留的是内容的信息；而 position embedding 保留的则是空间位置的信息。<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/position_embedding.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>比如上图把一张图划分成若干 patch，每个 patch 都能通过特征提取得到 feature embedding，同时也可以按照位置得到一个 position embedding，这里采用的是最简单的 $(x,y)$ 的形式。然后将两个向量进行拼接，形成总的向量之后再进行 post-processing。最后如果再做 average pooling，空间信息就不会被丢失。</p><p>当然 position embedding 可以根据实际情况有更加复杂的编码方式。</p><h2 id="Curse-of-High-dimension"><a href="#Curse-of-High-dimension" class="headerlink" title="Curse of High-dimension"></a>Curse of High-dimension</h2><p>在处理数据的特征时，特征的维度可能会非常高，而高维的特征则会带来很多弊端。</p><ul><li>空间和时间复杂度非常大，增加空间和时间上的开销</li><li>需要更多的数据覆盖整个空间<br>  <img src='../../figure/数据科学基础笔记/1-Feature-Engineering/more_sample_fill_space.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></li><li>模型的复杂度会很高($f(\bm{x})=\bm{w}^{\mathrm{T}}\bm{x}+\bm{b}$)<ul><li>过高的模型复杂度容易导致过拟合</li></ul></li><li>对于一个高维的物体，它的体积主要集中在表面上<ul><li>比如对于一个 $d$ 维超立方体，体积为 $V<em>{d}(r)=r^{d}$，$\displaystyle \lim</em>{d \to \infty}\frac{V<em>{d}(1-\varepsilon)}{V</em>{d}(1)}=\lim_{d \to \infty}(1-\varepsilon)^{d}=0$</li></ul></li><li>对于高维空间中均匀分布的点，每两个点之间的距离变大，但是方差变小，即两点之间距离的差异越来越小。<br>  <img src='../../figure/数据科学基础笔记/1-Feature-Engineering/pairewise_distance.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"><ul><li>这会导致距离度量(distance metric)逐渐失效，但是有很多分类器是基于距离度量的。比如 KNN 分类器，在维度很高的情况下，新的测试样本(五角星)就不容易归类。<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/KNN_example.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></li></ul></li></ul><h2 id="Dimensionality-Reduction"><a href="#Dimensionality-Reduction" class="headerlink" title="Dimensionality Reduction"></a>Dimensionality Reduction</h2><p>考虑到高维特征的种种弊端，因此需要知道如何对特征进行有效的降维。记原本的特征为 $\bm{f}$，降维之后的特征为 $\bm{f}’$。特征降维的方法主要如下：</p><ul><li>特征选择(feature selection): $\bm{f}’=\bm{m} \circ \bm{f}$，其中 $\bm{m}$ 是一个掩码(mask)，表示选择某些特征</li><li>特征投影(feature projection): $\bm{f}’=\bm{P}\bm{f}$，关键在于学习投影的矩阵 $\bm{P}$。比如 $\bm{f}$ 的维度为 $d_1$，投影矩阵 $\bm{P}$ 的形状为 $d_2\times d_1$，并且 $d_2&lt;d_1$，那么就能实现特征降维。</li><li>特征学习(feature learning): $\bm{f}’=\min_{\bm{f}’}L(\bm{f},\bm{f}’)$。这里 $L$ 是一个损失函数，这里的优化可以理解为希望 $\bm{f}’$ 能够保留尽量多的 $\bm{f}$ 的信息。</li></ul><h3 id="Feature-selection"><a href="#Feature-selection" class="headerlink" title="Feature selection"></a>Feature selection</h3><p>比如希望预测肺病的可能性，然后有以下一系列数据。我们希望选取一些最有用的特征。<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/feature_selection.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></p><p>这里我们可以把选择的掩码 $\bm{m}$ 看成一系列二值变量组成的向量，比如 $\bm{m}=(1, 0, 1, 1, \ldots , 0)$，假如 $\bm{m}$ 是 $k$ 维的，那么 $\bm{m}$ 共有 $2^{k}$ 种可能性，搜索空间非常大，不可能一个个枚举。</p><p>特征选择的流程如下：<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/feature_selection_flowchart.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>此处需要研究的重点在于应当使用怎样的 Feature Selector。</p><h4 id="Forward-selection"><a href="#Forward-selection" class="headerlink" title="Forward selection"></a>Forward selection</h4><p><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/forward_selection.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><p>Forward selection 也只是一个框架，其中的 <code>FINDNEXT</code> 会对算法的性能有不小的影响。</p><h4 id="Backward-selection"><a href="#Backward-selection" class="headerlink" title="Backward selection"></a>Backward selection</h4><p><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/backward_selection.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="Genetic-algorithm"><a href="#Genetic-algorithm" class="headerlink" title="Genetic algorithm"></a>Genetic algorithm</h4><p><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/generic_algorithm.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="Feature-Projection"><a href="#Feature-Projection" class="headerlink" title="Feature Projection"></a>Feature Projection</h3><ul><li>Linear projection $\bm{f}’=\bm{P}\bm{f}$<ul><li>Principle Component Analysis (PCA)</li><li>Linear Discriminative Analysis (LDA)</li></ul></li><li>Nonlinear projection $\bm{f}’=p(\bm{f})$<ul><li>Kernel PCA</li><li>Auto-encoder</li></ul></li></ul><h4 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h4><p>假如有一系列样本，每一个样本都是一个二维的特征向量，可以画出一个散点图。在下图中，直观上可以看出这些特征有一个主导的方向。接下来需要从数学上来定义这个主导的方向。(主导方向两两之间正交)<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/find_principle_component.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>PCA在数学上有两种等价的描述</p><ul><li>Maximum variance direction: when $\bm{X}$ is decentralized. (decentralized:让所有样本的每个维度的均值为 $0$)<ul><li>$\displaystyle \frac{1}{n}\sum_{i=1}^{n}(\bm{v}^{\mathrm{T}}\bm{x_i})^{2}=\frac{1}{n}\bm{v}^{\mathrm{T}}\bm{X}\bm{X}^{\mathrm{T}}\bm{v}$</li></ul></li><li>Minimum reconstruction error<ul><li>$\displaystyle \frac{1}{n}\sum<em>{i=1}^{n}\left| \bm{x_i}-(\bm{v}^{\mathrm{T}}\bm{x_i})\bm{v} \right|</em>{}^{2}$</li></ul></li></ul><p>从最大方差的角度出发，此时的主导方向 $\bm{v}$ 可以通过拉格朗日乘子法来求：</p><script type="math/tex; mode=display">\begin{aligned}\max_{\bm{v}}\quad &\bm{v}^{\mathrm{T}}\bm{X}\bm{X}^{\mathrm{T}}\bm{v} \\s.t.\quad &\bm{v}^{\mathrm{T}}\bm{v}=1\end{aligned}</script><p>得到拉格朗日形式</p><script type="math/tex; mode=display">\mathcal{L}_\mathbf{v}=\mathbf{v}^T\mathbf{X}\mathbf{X}^T\mathbf{v}+\lambda(1-\mathbf{v}^T\mathbf{v})</script><script type="math/tex; mode=display">\frac{\partial\mathcal{L}_\mathbf{v}}{\partial\mathbf{v}}=\mathbf{X}\mathbf{X}^T\mathbf{v}-\lambda\mathbf{v}=\mathbf{0} \\\Rightarrow \mathbf{X}\mathbf{X}^T\mathbf{v}=\lambda\mathbf{v}</script><p>最后的结果可以联想到特征分解。<br>那么对情况进行拓展，假如希望将 $d$ 维的数据降到 $k$ 维，可以看出直接取矩阵 $\bm{X}\bm{X}^{\mathrm{T}}$ 特征值最大的几个特征向量即可。</p><h4 id="Kernel-PCA"><a href="#Kernel-PCA" class="headerlink" title="Kernel PCA"></a>Kernel PCA</h4><script type="math/tex; mode=display">\begin{aligned}&\phi(\mathbf{X})=[\phi(\mathbf{x}_1),\phi(\mathbf{x}_2),\ldots,\phi(\mathbf{x}_n)]\\&\mathbf{v}=\phi(\mathbf{X})\alpha\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}&&&\mathbf{X}\mathbf{X}^{T}\mathbf{v}=\lambda\mathbf{v} \\&\Longrightarrow && \phi(\mathbf{X})\phi(\mathbf{X})^{T}\phi(\mathbf{X})\boldsymbol{\alpha}=\lambda\phi(\mathbf{X})\boldsymbol{\alpha}  \\&\Longrightarrow && \phi(\mathbf{X})^{T}\phi(\mathbf{X})\phi(\mathbf{X})^{T}\phi(\mathbf{X})\boldsymbol{\alpha}=\lambda\phi(\mathbf{X})^{T}\phi(\mathbf{X})\boldsymbol{\alpha}  \\&\Longrightarrow && \mathbf{K}\mathbf{K}\alpha=\lambda\mathbf{K}\boldsymbol{\alpha}  \\&\Longrightarrow  &&\mathbf{K}\alpha=\lambda\boldsymbol{\alpha}\end{aligned}</script><h4 id="Linear-Discriminative-Analysis-LDA"><a href="#Linear-Discriminative-Analysis-LDA" class="headerlink" title="Linear Discriminative Analysis (LDA)"></a>Linear Discriminative Analysis (LDA)</h4><p>和 PCA 不同，LDA 利用了类别的信息。LDA 希望找到一个投影方向，能够让类内的距离最小化，类间的距离最大化。比如在下图中，假如投影到纵坐标上，那么会导致两个类无法区分；但是如果把类投影到横坐标上，那么就能够得到很好的区分。<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/lda.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></p><p>假设两个类的均值分别为 $\bm{\mu_1},\bm{\mu_2}$，方差为 $\bm{\sigma_1}^{2},\bm{\sigma_2}^{2}$</p><script type="math/tex; mode=display">\begin{aligned}J(\mathbf{v})& =\frac{(\mathbf{v}^{T}\boldsymbol{\mu}_{1}-\mathbf{v}^{T}\boldsymbol{\mu}_{2})^{2}}{\boldsymbol{\sigma}_{1}^{2}+\boldsymbol{\sigma}_{2}^{2}}  \\&=\frac{(\mathbf{v}^T\boldsymbol{\mu}_1-\mathbf{v}^T\boldsymbol{\mu}_2)^2}{\sum_{i=1}^{C_1}(\mathbf{v}^T\mathbf{x}_{1,i}-\mathbf{v}^T\boldsymbol{\mu}_1)^2+\sum_{i=1}^{C_2}(\mathbf{v}^T\mathbf{x}_{2,i}-\mathbf{v}^T\boldsymbol{\mu}_2)^2} \\&=\frac{\mathbf{v}^T(\boldsymbol{\mu}_1-\boldsymbol{\mu}_2)(\boldsymbol{\mu}_1-\boldsymbol{\mu}_2)^T\mathbf{v}}{\mathbf{v}^T\left(\sum_{i=1}^{C_1}(\mathbf{x}_{1,i}-\boldsymbol{\mu}_1)(\mathbf{x}_{1,i}-\boldsymbol{\mu}_1)^T+\sum_{i=1}^{C_2}(\mathbf{x}_{2,i}-\boldsymbol{\mu}_2)(\mathbf{x}_{2,i}-\boldsymbol{\mu}_2)^T\right)\mathbf{v}} \\&=\frac{\mathbf{v}^T\mathbf{S}_B\mathbf{v}}{\mathbf{v}^T\mathbf{S}_W\mathbf{v}}\end{aligned}</script><p>对上式求极值</p><script type="math/tex; mode=display">J(\mathbf{v})={\frac{\mathbf{v}^{T}\mathbf{S}_{B}\mathbf{v}}{\mathbf{v}^{T}\mathbf{S}_{W}\mathbf{v}}},\quad{\frac{\partial J(\mathbf{v})}{\partial\mathbf{v}}}=0 \Rightarrow (\mathbf{v}^T\mathbf{S}_B\mathbf{v})\mathbf{S}_W\mathbf{v}=(\mathbf{v}^T\mathbf{S}_W\mathbf{v})\mathbf{S}_B\mathbf{v}</script><p>又因为 $\mathbf{S}<em>{B}=(\boldsymbol{\mu}</em>{1}-\boldsymbol{\mu}<em>{2})\left(\boldsymbol{\mu}</em>{1}-\boldsymbol{\mu}<em>{2}\right)^{T}$，因此 $\bm{S}</em>{B}\bm{v}$ 的方向和 $\bm{\mu_1}-\bm{\mu_2}$ 相同。除去常数项 $\mathbf{v}^T\mathbf{S}_B\mathbf{v}$ 和 $\mathbf{v}^T\mathbf{S}_W\mathbf{v}$，最终得到投影向量的方向为</p><script type="math/tex; mode=display">\mathbf{v}\propto\mathbf{S}_W^{-1}(\boldsymbol{\mu}_1-\boldsymbol{\mu}_2)</script><h4 id="Auto-encoder"><a href="#Auto-encoder" class="headerlink" title="Auto-encoder"></a>Auto-encoder</h4><p><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/auto_network.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>图中的 bottleneck 就是降维之后的特征。</p><h3 id="Feature-learning"><a href="#Feature-learning" class="headerlink" title="Feature learning"></a>Feature learning</h3><p>前两种函数优化的是投影函数，feature leaning 需要优化的是特征本身。</p><h4 id="Stochastic-Neighborhood-Embedding-SNE"><a href="#Stochastic-Neighborhood-Embedding-SNE" class="headerlink" title="Stochastic Neighborhood Embedding (SNE)"></a>Stochastic Neighborhood Embedding (SNE)</h4><p>这种方法基于希望降维之后的特征能够保持样本之间的关系(如距离关系)。</p><p>$\bm{x}\rightarrow \tilde{\bm{x}}$：希望保持第 $i$ 个样本和第 $j$ 个样本的转移概率(transition probability，可以理解为相似度)。</p><script type="math/tex; mode=display">\begin{gathered}p(j|i)=\frac{\exp(-\|\mathbf{x}_i-\mathbf{x}_j\|^2)}{\sum_{k\neq i}\exp(-\|\mathbf{x}_i-\mathbf{x}_k\|^2)} \\q(j|i)=\frac{\exp(-\|\tilde{\mathbf{x}}_i-\tilde{\mathbf{x}}_j\|^2)}{\sum_{k\neq i}\exp(-\|\tilde{\mathbf{x}}_i-\tilde{\mathbf{x}}_k\|^2)} \end{gathered}</script><p>希望 $p(j|i)$ 和 $q(j|i)$ 比较接近。定义</p><script type="math/tex; mode=display">L=\sum_iKL(P_i||Q_i)=\sum_i\sum_jp(j|i)\log\frac{p(j|i)}{q(j|i)}</script><ul><li>其中 $P<em>{i}$ 表示任意样本转移到第 $i$ 个样本的概率，可以写为 $P</em>{i}=[p(1|i),p(2|i), \ldots ,p(n|i)]$，$Q_i$ 同理。</li><li>$KL$ 即 KL divergence，是一种常用的距离度量的方法。</li></ul><p>对于表达式 $L$</p><ul><li>我们的目标是最小化 $L$</li><li>我们的优化对象为 $\tilde{\bm{x}}$</li></ul><p>t-SNE 是 SNE 的一种拓展，将 $L$ 的表达式中的高斯分布换为 student-t 分布。student-t 分布的优点在于其函数图像是 heavy tail，对于 outlier，即两边的数据容忍度比较高。<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/t_sne.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>在研究中，t-SNE 通常用于做数据的可视化。即将一个高维的数据降到二维，然后就可以在图上画出来。</p><h4 id="Local-Linear-Embedding-LLE"><a href="#Local-Linear-Embedding-LLE" class="headerlink" title="Local Linear Embedding (LLE)"></a>Local Linear Embedding (LLE)</h4><p>选择一个样本点 $x_i$，考虑其邻域 $N(i)$。Linear 表示的就是这个样本点可以通过邻域点的线性组合得到。<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/local_linear_embedding.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>首先希望能够通过 $w<em>{ij}$ 得到样本之间的关系，此时需要优化来得到 $w</em>{ij}$：</p><script type="math/tex; mode=display">\begin{aligned}\min_{\mathbf{W}}&\quad\|\mathbf{x}_i-\sum_{j\in N(i)}w_{ij}\mathbf{x}_j\|^2\\\text{s.t.}&\quad\sum_jw_{ij}=1\end{aligned}</script><p>然后将样本 $\bm{x}_i$ transfer 之后得到 $\bm{y}_i$，希望所有样本 $\bm{Y}$ 也能保持 $\bm{X}$ 之间的关系。因此需要优化 $\bm{Y}$：</p><script type="math/tex; mode=display">\begin{aligned}\min_{\mathbf{Y}}~&\|\mathbf{y}_i-\sum_{j\in N(i)}w_{ij}\mathbf{y}_j\|^2\\\mathrm{s.t.}~&\mathbf{Y}^T\mathbf{Y}=\mathbf{I}\end{aligned}</script><h4 id="Sparse-Coding"><a href="#Sparse-Coding" class="headerlink" title="Sparse Coding"></a>Sparse Coding</h4><p>希望得到 $\bm{Y}$ 的稀疏表征 $\bm{X}$：$\min<em>{\mathbf{X},\mathbf{D}}|\mathbf{Y}-\mathbf{D}\mathbf{X}|</em>{F}^{2}+\lambda[\mathbf{\bar{X}}]_{1}$<br><img src='../../figure/数据科学基础笔记/1-Feature-Engineering/sparse_coding.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>上式中矩阵的 F norm 类似于向量的 L2 norm。矩阵的 L1 norm 类似于向量的 L1 norm。</p><ul><li><script type="math/tex; mode=display">\left\| X \right\|_{F} = \sqrt{\sum_{i}\sum_{j}x_{ij}^{2}}</script></li><li>通常 L1 norm 的加入可以使得矩阵变得更加系数，因此 L1 norm 也被称为 sparse norm。</li></ul><p>为了优化目标，可以采取交替优化：先固定 $\bm{X}$，优化 $\bm{D}$；再固定 $\bm{D}$，优化 $\bm{X}$。</p>]]></content>
      
      
      <categories>
          
          <category> data science </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Clustering</title>
      <link href="/posts/e292886a.html"/>
      <url>/posts/e292886a.html</url>
      
        <content type="html"><![CDATA[<h2 id="How-to-represent-a-cluster"><a href="#How-to-represent-a-cluster" class="headerlink" title="How to represent a cluster"></a>How to represent a cluster</h2><p>比如把全班同学的身高作为一个cluster：</p><ul><li>可以把所有人的身高都记下来<ul><li>无法知道数据的特征</li></ul></li><li>可以使用平均值<ul><li>有信息的丢失，但是能够抓住一定特征</li><li>用平均值代表一堆点，误差最小</li></ul></li></ul><h3 id="How-to-define-error"><a href="#How-to-define-error" class="headerlink" title="How to define error?"></a>How to define error?</h3><p>平方误差是误差的常用度量方式<br><img src='../../figure/机器学习笔记/1-Clustering/square_distance.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>如果定义误差</p><script type="math/tex; mode=display">J(\bm{\mu})=\sum_{t=1}^{N}\left\| \bm{x_t}-\bm{\mu} \right\|_{}^{2}</script><p>可以证明当 $\bm{\mu}$ 是所有数据点的均值时，误差最小。</p><ul><li><p>证明 1 (配方):</p><script type="math/tex; mode=display">  \begin{aligned}  J(\bm{\mu})&=\sum_{t=1}^{N}\left\| \bm{x_t}-\bm{\mu} \right\|_{}^{2} \\  &= \sum_{t=1}^{N} (\bm{\mu}-\bm{x_t})\cdot (\bm{\mu}-\bm{x_t}) \\  &= \sum_{t=1}^{N} (\left\| \mu \right\|_{}^{2}+\left\| \bm{x_t} \right\|_{}^{2}-2\bm{\mu}\cdot \bm{x_t}) \\  &= n \left\| \bm{\mu} \right\|_{}^{2} - 2\bm{\mu}\cdot \sum_{t=1}^{N} \bm{x_t} + \sum_{t=1}^{N} \left\| \bm{x_t} \right\|_{}^{2} \\  &= n(\bm{\mu} - \frac{1}{n}\sum_{t=1}^{N}\bm{x_t})^{2} + C  \end{aligned}</script><p>  因此 $\bm{\mu}=\frac{1}{n}\sum_{t=1}^{N}\bm{x_t}$ 的时候误差最小。</p></li><li><p>证明 2 (求导):</p><script type="math/tex; mode=display">  \begin{aligned}  \left\| \bm{x_t}-\bm{\mu} \right\|_{}^{2} &= (\bm{x_t}-\bm{\mu})^{\mathrm{T}}(\bm{x_t}-\bm{\mu}) \\  &= \bm{x_t}^{\mathrm{T}}\bm{x_t} - \bm{x_t}^{\mathrm{T}}\bm{\mu} - \bm{\mu}^{\mathrm{T}}\bm{x_t} + \bm{\mu}^{\mathrm{T}}\bm{\mu} \\  &= \bm{x_t}^{\mathrm{T}}\bm{x_t} - 2\bm{\mu}^{\mathrm{T}}\bm{x_t} + \bm{\mu}^{\mathrm{T}}\bm{\mu}  \end{aligned}</script><p>  上式利用了 $\bm{x_t}^{\mathrm{T}}\bm{\mu}=(\bm{x_t}^{\mathrm{T}}\bm{\mu})^{\mathrm{T}}=\bm{\mu}^{\mathrm{T}}\bm{x_t}$</p><p>  同时对于向量的导数，如 $f(\bm{x})=\bm{a}^{\mathrm{T}}\bm{x}$，其中 $\bm{x}=\begin{pmatrix} x_1 \ x_2 \ \vdots \ x_n \end{pmatrix}$, $\bm{a} = \begin{pmatrix} a_1 \ a_2 \ \vdots \ a_n \end{pmatrix}$，那么定义导数为：</p><script type="math/tex; mode=display">  \frac{\partial f(\bm{x})}{\partial \bm{x}} = \begin{pmatrix}       \frac{\partial f}{\partial x_1} \\ \frac{\partial f}{\partial x_2} \\ \vdots \\ \frac{\partial f}{\partial x_n}   \end{pmatrix} = \bm{a}</script><p>  同理，对于 $f(\bm{x})=\bm{x}^{\mathrm{T}}\bm{A}\bm{x}=\sum<em>{i,j}x_i a</em>{ij} x_j$</p><script type="math/tex; mode=display">  \frac{\partial f(\bm{x})}{\partial \bm{x}} = \bm{A}\bm{x} + \bm{A}^{\mathrm{T}}\bm{x}</script><p>  此处可以理解为对 $f(\bm{x})$ 求微分</p><script type="math/tex; mode=display">  \begin{aligned}  \mathrm{d}f(\bm{x}) &= \mathrm{d}Tr(\bm{x}^{\mathrm{T}}\bm{A}\bm{x})  \\  &= Tr(\mathrm{d}(\bm{x}^{\mathrm{T}}\bm{A}\bm{x})) \\  &= Tr(\mathrm{d}\bm{x}^{\mathrm{T}}(\bm{A}\bm{x})+\bm{x}^{\mathrm{T}}\bm{A}\mathrm{d}\bm{x}) \\  &= Tr((\bm{A}\bm{x})^{\mathrm{T}}\mathrm{d}\bm{x}+\bm{x}^{\mathrm{T}}\bm{A}\mathrm{d}\bm{x}) \\  &= Tr \left[ (\bm{A}\bm{x}+\bm{A}^{\mathrm{T}}\bm{x})^{\mathrm{T}}\mathrm{d}\bm{x} \right] \\  &= (\bm{A}\bm{x}+\bm{A}^{\mathrm{T}}\bm{x})^{\mathrm{T}}\mathrm{d}\bm{x}  \end{aligned}</script><p>  此处利用了 $Tr(\bm{A}^{\mathrm{T}})=Tr(\bm{A})$ 的性质。</p><p>  最终考虑此处误差求导</p><script type="math/tex; mode=display">  \frac{\partial J}{\partial \bm{\mu}} = \sum_{t=1}^{N} (-2\bm{x_{t}}+2\bm{\mu}) = 0</script><script type="math/tex; mode=display">  \Rightarrow \bm{\mu}=\frac{1}{n}\sum_{t=1}^{N}\bm{x_t}</script></li></ul><h2 id="Clustering-the-data"><a href="#Clustering-the-data" class="headerlink" title="Clustering the data"></a>Clustering the data</h2><p>比如我们希望把数据分为两堆点，那么延续上面的思路，我们可以用两个点来代表这两个 cluster。<br><img src='../../figure/机器学习笔记/1-Clustering/clustering_the_data.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="Minimize-the-sum-of-square-distance-J"><a href="#Minimize-the-sum-of-square-distance-J" class="headerlink" title="Minimize the sum of square distance J"></a>Minimize the sum of square distance J</h3><p>定义这两个点为 $\bm{\mu_1},\bm{\mu_2}$，继续使用平方误差。</p><p>首先对于最普遍的 $K$ 个点的情形，有</p><script type="math/tex; mode=display">J=\sum_{n=1}^{N}\sum_{k=1}^{K}r_{nk}\left\| \bm{x_n}-\bm{\mu_k} \right\|_{}^{2}</script><p>其中当点 $\bm{x<em>n}$ 被归属到 cluster $k$ 时，$r</em>{nk}=1$，其他时候 $r_{nk}=0$。</p><p>那么对于此处的二聚类情形，即有 $K=2$。对于前面 $K=1$ 的情形，可以直接求导得出结果，但是当 $K=2$ 时，无法得到解析解，就需要利用机器学习的算法。</p><h4 id="If-we-know-r-n-1-r-n-2-for-all-n-1-…-N"><a href="#If-we-know-r-n-1-r-n-2-for-all-n-1-…-N" class="headerlink" title="If we know $r{n_1}$ , $r{n_2}$ for all $n=1,…,N$"></a>If we know $r<em>{n_1}$ , $r</em>{n_2}$ for all $n=1,…,N$</h4><p>很显然此时 $\bm{\mu_1},\bm{\mu_2}$ 应当分别取 cluster1 和 cluster2 的平均值。即：</p><script type="math/tex; mode=display">\bm{\mu_k}=\frac{\sum_{n}r_{nk}\bm{x_n}}{\sum_{n}r_{nk}}</script><p>我们称该过程为 <strong>M step</strong>。</p><h4 id="If-we-know-mu-1-mu-2"><a href="#If-we-know-mu-1-mu-2" class="headerlink" title="If we know $\mu_1$, $\mu_2$"></a>If we know $\mu_1$, $\mu_2$</h4><p>为了使得 $J$ 更小，显然当 $\left| \bm{x<em>n}-\bm{\mu_1} \right|</em>{}^{2}&lt;\left| \bm{x<em>n}-\bm{\mu_2} \right|</em>{}^{2}$ 时，应当有 $r<em>{n_1}=1, r</em>{n_2}=0$。即：</p><script type="math/tex; mode=display">r_{nk}=\begin{cases}1&\text{if }k=\arg\min_j\|\mathbf{x}_n-\boldsymbol{\mu}_j\|^2\\0&\text{otherwise.}\end{cases}</script><p>我们称该过程为 <strong>E step</strong>。</p><h2 id="K-mean-Algorithms"><a href="#K-mean-Algorithms" class="headerlink" title="K-mean Algorithms"></a>K-mean Algorithms</h2><ol><li>首先随机初始化 $\bm{\mu_1},\bm{\mu_2}$</li><li>进行一次 E step，即划分 cluster</li><li>根据此时的两个 cluster，利用 M step 更新 $\mu_1,\mu_2$。</li><li>若收敛，则停止；反之继续步骤 2.</li></ol><p>伪代码如下：</p><script type="math/tex; mode=display">\begin{aligned}&\text{Initialize~}\boldsymbol{m}_{i},i=1,\ldots,k,\mathrm{for~example},\text{to }k\text{ random }\boldsymbol{x}^{t} \\&\text{Repeat} \\&\quad \text{For~all~}\boldsymbol{x}^{t}\in\mathcal{X} \\&\quad \quad b_i^t\gets  \begin{cases}  &1 \quad \text{if }\|\boldsymbol{x}^t-\boldsymbol{m}_i\|=\min_j\|\boldsymbol{x}^t-\boldsymbol{m}_j\|\\  &0\quad\mathrm{otherwise}  \end{cases} \\&\quad \text{For all } \bm{m_i}, i=1, \ldots k  \\&\quad \quad \boldsymbol{m}_{i}\leftarrow\sum_{t}b_{i}^{t}\boldsymbol{x}^{t}/\sum_{t}b_{i}^{t} \\&\text{Until~} \bm{m_i} \text{~converage}\end{aligned}</script><p>直观过程图如下：<br><img src='../../figure/机器学习笔记/1-Clustering/K_mean_algo.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h3><ul><li>How many possible assignments for K-mean clustering?<ul><li>$k^{n}$</li></ul></li><li>Can K-mean algorithm always converge? Why?<ul><li>目标函数单调递减且有界，因此一定收敛。</li></ul></li><li>Possible limitations of K-mean clustering?<ul><li>可能收敛到的是<em>局部最优解</em>。比如有两堆点，但是初始化的时候 $\bm{\mu_1},\bm{\mu_2}$ 中的某个点初始值离两堆点都会非常远，那么会导致最终一个 cluster 占据了所有点；另一个 cluster 没有点。</li></ul></li></ul><h2 id="Hierarchical-Clustering"><a href="#Hierarchical-Clustering" class="headerlink" title="Hierarchical Clustering"></a>Hierarchical Clustering</h2><ol><li>首先把每一个点都视作一个单独的 group</li><li>查找两个最近的 group，把它们合成一个</li><li>当所有的点都被合成一个 cluster 时，算法终止。</li></ol><h3 id="Distance-Measure"><a href="#Distance-Measure" class="headerlink" title="Distance Measure"></a>Distance Measure</h3><p>此时需要考虑什么叫 “离得最近的两个 group”。我们记两个点 $a$ 和 $b$ 的距离为 $d(a,b)$</p><p>两个 group $A,B$ 的距离可以定义为：</p><ul><li>single-linkage<ul><li>$\displaystyle d(A,B) = \min_{a\in A,b\in B} d(a,b)$ </li></ul></li><li>complete-linkage<ul><li>$\displaystyle d(A,B) = \max_{a\in A,b\in B} d(a,b)$</li></ul></li><li>average-linkage<ul><li>$\displaystyle d(A,B) = \frac{\sum_{a\in A,b\in B}d(a,b)}{\left\vert A \right\vert \cdot \left\vert B \right\vert }$</li></ul></li></ul><h3 id="Dendrogram"><a href="#Dendrogram" class="headerlink" title="Dendrogram"></a>Dendrogram</h3><p>经过 hierarchical clustering 之后，可以得到树状图用于形象地展示 cluster 的过程<br><img src='../../figure/机器学习笔记/1-Clustering/dendrogram.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>从这里可以看出这种算法的层级结构。</p><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><ul><li>What are the advantage and limitations of hierarchical clustering?<ul><li>优点：<ul><li>便于理解层级结构。</li><li>不用随机初始化，不会像 K-mean 算法那样陷入局部最优。</li></ul></li><li>缺点：<ul><li>计算复杂度高，每一步的计算复杂度为 $O(n^{2})$；而 K-mean 每一步为 $O(kn)$。</li><li>依然不知道一堆点该取多少 cluster。</li></ul></li></ul></li></ul><h2 id="Adaptive-learing-online-learning"><a href="#Adaptive-learing-online-learning" class="headerlink" title="Adaptive learing(online learning)"></a>Adaptive learing(online learning)</h2><p>假如不能像之前一样一次性知道所有数据，数据是逐个来的，那么就需要新的算法。</p><h3 id="Competitive-learning"><a href="#Competitive-learning" class="headerlink" title="Competitive learning"></a>Competitive learning</h3><p>用 $m_1,m_2$ 两个点代表两个 cluster。当新来的点 $x$ 离 $m_1$ 更近，那么把 $x$ 归入 cluster 1；反之归入 cluster 2。<br><img src='../../figure/机器学习笔记/1-Clustering/competitive_learning.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>同时在新的点进入后，我们希望通过调整 $m_1,m_2$ 让这两个点能够被新的点影响。</p><script type="math/tex; mode=display">\begin{gathered}\varepsilon_{t}(\theta_{j})=\|x_{t}-m_{j}\|^{2} \\c=argmin_{j}\varepsilon_{t}(\theta_{j}). \\\left.p_{j,t}=\left\{\begin{array}{ll}{1,}&{\mathrm{if}\quad j=c,}\\{0,}&{\mathrm{otherwise};}\end{array}\right.\right. \\m_{j}^{new}=m_{j}^{old}+\eta p_{j,t}(x_{t}-m_{j}^{old}). \end{gathered}</script><p>可以看出此处对 $m_j$ 的更新类似于梯度下降法。</p><h4 id="bad-initialization"><a href="#bad-initialization" class="headerlink" title="bad initialization"></a>bad initialization</h4><p>类似 K-mean，假如 $m_1,m_2$ 中的一个点初始化不合适，同样会陷入局部最优解。即某个点成为了所有数据的中心。<br><img src='../../figure/机器学习笔记/1-Clustering/bad_initialization.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="Frequency-sensitive-competitive-learning-FSCL"><a href="#Frequency-sensitive-competitive-learning-FSCL" class="headerlink" title="Frequency sensitive competitive learning (FSCL)"></a>Frequency sensitive competitive learning (FSCL)</h3><p>即假如某个点已经包括了多个数据，那么后面的新数据被这个点包括的难度会增大(penalize the frequent winner)</p><script type="math/tex; mode=display">\varepsilon_t(\theta_j) = \alpha_j \left\| x_t - m_j \right\|_{}^{2}</script><p>但是这种算法在指定的中心多余实际的中心时会出问题。比如一堆数据聚成 $4$ 个类更为合适，但是给了 $5$ 个中心点。</p><h3 id="Rival-penalized-competitive-learning-RPCL"><a href="#Rival-penalized-competitive-learning-RPCL" class="headerlink" title="Rival penalized competitive learning (RPCL)"></a>Rival penalized competitive learning (RPCL)</h3><p>与 FSCL 相比，RPCL 引入了对于竞争次优点的惩罚，解决了指定中心与实际中心数量不匹配的问题。即每次竞争之后让竞争胜利者之外的最优点离新数据远一些。</p><script type="math/tex; mode=display">\left.p_{j,t}=\begin{cases}1,&\text{if~}j=c,\\-\gamma,&\text{if~}j=r,\\0,&\text{otherwise},\end{cases}\left\{\begin{array}{l}c=argmin_j\varepsilon_t(\theta_j),\\r=argmin_{j\neq c}\varepsilon_t(\theta_j),\end{array}\right.\right.</script><p>其中 $\gamma$ 大约是 $0.05$ 到 $0.1$ 之间的值。<br><img src='../../figure/机器学习笔记/1-Clustering/RPCL.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h3><ul><li>Are competitive learning (CL) and K-mean equivalent?<ul><li>对于 K-mean，求均值有 $\displaystyle \mu=\frac{1}{N}\sum<em>{t=1}^{N}x_t=\bar{x}</em>{N}$，即 $\displaystyle \bar{x}<em>{t+1} = \bar{x}</em>{t} + \frac{1}{t+1}(x_{t+1}-x_t)$</li><li>对于 CL，有 $m<em>{j}^{new}=m</em>{j}^{old}+\eta p<em>{j,t}(x</em>{t}-m_{j}^{old})$</li><li>因此只要使得 $\eta=\frac{1}{t+1}$ 时，两者的计算方式可以相同。</li></ul></li><li>Could you come up with new algorithms to tackle the “bad initializaion” problem of competitive learning? (or K-mean)?</li><li>Can you design a K-mean version of RPCL?</li></ul><h2 id="Gaussian-Mixture-Models-GMM"><a href="#Gaussian-Mixture-Models-GMM" class="headerlink" title="Gaussian Mixture Models (GMM)"></a>Gaussian Mixture Models (GMM)</h2><h3 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h3><h4 id="Binary-variables"><a href="#Binary-variables" class="headerlink" title="Binary variables"></a>Binary variables</h4><p>比如说抛硬币，每一个样本 $x\in {0,1}$。</p><script type="math/tex; mode=display">\begin{aligned}p(x=1|\mu) &= \mu \\p(x=0|\mu) &= 1-\mu\end{aligned}</script><p>也可以简写为</p><script type="math/tex; mode=display">Bern(x|\mu) = \mu^{x}(1-\mu)^{1-x}</script><p>易得 $\mathbb{E}[x]=\mu, var[x]=\mu(1-\mu)$</p><p>假如有 $N$ 个点，独立同分布，$\mathcal{D}={x_1,\ldots,x_N}$，我们可以写出似然函数：</p><script type="math/tex; mode=display">p(\mathcal{D}|\mu)=\prod_{n=1}^Np(x_n|\mu)=\prod_{n=1}^N\mu^{x_n}(1-\mu)^{1-x_n}</script><p>有时为方便计算，写成：</p><script type="math/tex; mode=display">\ln p(\mathcal{D}|\mu)=\sum_{n=1}^N\ln p(x_n|\mu)=\sum_{n=1}^N\left\{x_n\ln\mu+(1-x_n)\ln(1-\mu)\right\}</script><h4 id="Multinomial-variables"><a href="#Multinomial-variables" class="headerlink" title="Multinomial variables"></a>Multinomial variables</h4><p>伯努利分布仅有两种情况，但是假如像掷骰子，可能会有 $K=6$ 中情况。这里考虑有 $K$ 中情况时的概率分布问题。样本记为 $\mathbf{x}$，有 $x<em>i=1$，$\sum</em>{k=1}^{K}x_k=1$，表示选中第 $i$ 种情况。比如 $K=6$，样本可能为 $\mathbf{x}=(0,0,1,0,0,0)^\mathrm{T}$。</p><p>Multinomial distribution</p><script type="math/tex; mode=display">p(\mathbf{x}|\boldsymbol{\mu})=\prod_{k=1}^K\mu_k^{x_k}\quad\quad\boldsymbol{\mu}=(\mu_1,\ldots,\mu_K)^\mathrm{T}\quad\mu_k\geqslant0\\\sum_k\mu_k=1</script><p>期望为 $\mathbb{E}[\mathbf{x}|\boldsymbol{\mu}]=\sum_\mathbf{x}p(\mathbf{x}|\boldsymbol{\mu})\mathbf{x}=(\mu_1,\ldots,\mu_M)^\mathrm{T}=\boldsymbol{\mu}$。</p><p>同样写出似然函数</p><script type="math/tex; mode=display">p(\mathcal{D}|\boldsymbol{\mu})=\prod_{n=1}^N\prod_{k=1}^K\mu_k^{x_{nk}}=\prod_{k=1}^K\mu_k^{(\sum_nx_{nk})}=\prod_{k=1}^K\mu_k^{m_k} \quad m_k=\sum_{n}x_{nk}</script><h4 id="Gaussian-distribution"><a href="#Gaussian-distribution" class="headerlink" title="Gaussian distribution"></a>Gaussian distribution</h4><script type="math/tex; mode=display">\mathcal{N}(x|\mu,\sigma^2)=\frac1{\left(2\pi\sigma^2\right)^{1/2}}\exp\left\{-\frac1{2\sigma^2}(x-\mu)^2\right\}</script><h4 id="Multivariate-Gaussian"><a href="#Multivariate-Gaussian" class="headerlink" title="Multivariate Gaussian"></a>Multivariate Gaussian</h4><script type="math/tex; mode=display">\mathcal{N}(\mathbf{x}|\boldsymbol{\mu},\boldsymbol{\Sigma})=\frac1{(2\pi)^{D/2}}\frac1{|\boldsymbol{\Sigma}|^{1/2}}\exp\left\{-\frac12(\mathbf{x}-\boldsymbol{\mu})^\mathrm{T}\boldsymbol{\Sigma}^{-1}(\mathbf{x}-\boldsymbol{\mu})\right\}</script><p>其性质有：</p><script type="math/tex; mode=display">\begin{aligned}&\mathbb{E}[\mathbf{x}]=\boldsymbol{\mu}\\&\mathbb{E}[\mathbf{x}\mathbf{x}^\mathrm{T}]=\boldsymbol{\mu}\boldsymbol{\mu}^\mathrm{T}+\boldsymbol{\Sigma}. \\&\mathrm{cov[x]=\mathbb{E}\left[(x-\mathbb{E}[x])(x-\mathbb{E}[x])^T\right]=\boldsymbol{\Sigma}.}\end{aligned}</script><p><img src='../../figure/机器学习笔记/1-Clustering/multivariate_gaussian.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="Mahalanobis-distance"><a href="#Mahalanobis-distance" class="headerlink" title="Mahalanobis distance"></a>Mahalanobis distance</h4><p>对于欧氏距离，每个维度都是同等重要的。但是在某些应用场景下，每个维度并不是等同的，比如一座山，在某些方向坡度更陡，某些方向坡度更缓，那么在移动相同水平距离的情况下难度时不同的。因此可以引入新的距离度量的方式。</p><ul><li>在欧氏距离中，假如有两点 $\mathbf{x},\mathbf{y}$，距离可以写成 $d^{2}(\mathbf{x},\mathbf{y})=(\mathbf{y}-\mathbf{x})^{\mathrm{T}}(\mathbf{y}-\mathbf{x})$</li><li>而马氏距离则为 $d^{2}(\mathbf{x},\mathbf{y})=(\mathbf{y}-\mathbf{x})^{\mathrm{T}}\mathbf{A}(\mathbf{y}-\mathbf{x})$. ($d(\vec{x},\vec{y})=\sqrt{(\vec{x}-\vec{y})^T\Sigma^{-1}(\vec{x}-\vec{y})}$)</li></ul><p>以二维向量为例，考虑点 $\mathbf{x}$ 到原点</p><script type="math/tex; mode=display">\left\| \mathbf{x}-0 \right\|_{}^{2} = x_1^{2}+x_2^{2}=\begin{pmatrix}     x_1 \\ x_2 \end{pmatrix} ^{\mathrm{T}}\begin{pmatrix}     1 & 0 \\ 0 & 1 \end{pmatrix} \begin{pmatrix}     x_1 \\ x_2 \end{pmatrix}</script><p>但假如某个维度更加重要，中间矩阵可以写为 $\begin{pmatrix} 1 &amp; 0 \ 0 &amp; 2  \end{pmatrix}$，可以看出 lm此时数据的“等高线”为一个椭圆。如果还希望这个椭圆能够旋转，那么可以再在两侧加上旋转矩阵 $\mathbf{R}$。因此 $\mathbf{A}=\mathbf{R}\boldsymbol{\Lambda}\mathbf{R}^{\mathrm{T}}$</p><h4 id="From-distance-to-probability"><a href="#From-distance-to-probability" class="headerlink" title="From distance to probability"></a>From distance to probability</h4><p>从距离表示一个东西和从概率表示一个东西，在概念上可以是一致的。</p><script type="math/tex; mode=display">D_M(x)=\sqrt{(x-\mu)^T\Sigma^{-1}(x-\mu)} \rightarrow \frac{1}{\sqrt{(2\pi)^k|\boldsymbol{\Sigma}|}}\exp\left(-\frac{1}{2}(\mathbf{x}-\boldsymbol{\mu})^\mathrm{T}\boldsymbol{\Sigma}^{-1}(\mathbf{x}-\boldsymbol{\mu})\right)</script><p>概率相当于是对距离的 normalize。</p><p>一种距离对应一种分布，从上面可以看出，欧氏/马氏距离对应了高斯分布；绝对值距离则对应 Laplace 分布：</p><script type="math/tex; mode=display">\left\vert x-\mu \right\vert \rightarrow e^{-\gamma \left\vert x-\mu \right\vert }</script><h3 id="Issues-for-K-mean-algorithm"><a href="#Issues-for-K-mean-algorithm" class="headerlink" title="Issues for K-mean algorithm"></a>Issues for K-mean algorithm</h3><ul><li>If Euclidean distance is not good for some data, do we have other choices?</li><li>Can we assign each data point to the clusters probabilistically?</li><li>If K (the total number of clusters) is unknown, can we estimate it from the data?</li></ul><h3 id="Gaussian-Mixture-Model"><a href="#Gaussian-Mixture-Model" class="headerlink" title="Gaussian Mixture Model"></a>Gaussian Mixture Model</h3><p>在 K-mean 算法中，我们希望最小化 $\boldsymbol{\mu}$ 到所有样本的欧氏距离 $\min<em>{\boldsymbol{\mu}}\sum</em>{t=1}^{N}\left| \mathbf{x}<em>t-\boldsymbol{\mu} \right|</em>{}^{2}$，而为了解决 K-mean 没有考虑 cluster 形状(可能为椭圆形)，以及无法使用概率来划分样本点的问题，我们考虑使用 GMM。</p><p>在 GMM 中，每个 cluster 都有一个概率分布</p><script type="math/tex; mode=display">\mathcal{N}(\mathbf{x}|\boldsymbol{\mu},\boldsymbol{\Sigma})=\frac{1}{\sqrt{(2\pi)^{k}|\boldsymbol{\Sigma}|}}\exp\left(-\frac{1}{2}(\mathbf{x}-\boldsymbol{\mu})^{\mathrm{T}}\boldsymbol{\Sigma}^{-1}(\mathbf{x}-\boldsymbol{\mu})\right)</script><p><img src='../../figure/机器学习笔记/1-Clustering/k_mean_and_gmm.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>同时我们使用 $z_k=1$ 表示样本 $\mathbf{x}$ 属于第 $k$ 个 cluster。</p><script type="math/tex; mode=display">\mathbf{z}=(z_1,\ldots,z_K)\quad z_k\in\{0,1\}\quad\sum_kz_k=1</script><p>利用每个 cluster 的概率分布，可以写出</p><script type="math/tex; mode=display">p(\mathbf{x}|z_k=1)=\mathcal{N}(\mathbf{x}|\boldsymbol{\mu}_k,\boldsymbol{\Sigma}_k)</script><p>然后再考虑先验概率</p><script type="math/tex; mode=display">p(z_k=1)=\pi_k \quad 0\le \pi_{k} \le 1 \quad \sum_{k=1}^{K}\pi_{k}=1</script><p>最后可以得到样本点的概率分布函数：</p><script type="math/tex; mode=display">p(\mathbf{x})=\sum_\mathbf{z}p(\mathbf{z})p(\mathbf{x}|\mathbf{z})=\sum_{k=1}^K\pi_k\mathcal{N}(\mathbf{x}|\boldsymbol{\mu}_k,\boldsymbol{\Sigma}_k)</script><h4 id="Maximum-likelihood"><a href="#Maximum-likelihood" class="headerlink" title="Maximum likelihood"></a>Maximum likelihood</h4><p>此时问题可以转化为最大化似然函数</p><script type="math/tex; mode=display">p(\mathbf{X}|\boldsymbol{\mu}, \boldsymbol{\Sigma}, \boldsymbol{\pi})</script><p>其中</p><script type="math/tex; mode=display">\begin{gathered}\mathbf{X}=\{x_{1},...,x_{N}\} \\\boldsymbol{\pi}=\{\pi_{_1},...,\pi_{_K}\} \\\boldsymbol{\mu}=\{\mu_{_1},\ldots,\mu_{_K}\} \\\boldsymbol{\Sigma}=\{\Sigma_{_1},...,\Sigma_{_K}\}\end{gathered}</script><p>首先假设先验概率已知。为方便计算，将似然函数取对数：</p><script type="math/tex; mode=display">\ln p(\mathbf{X}|\boldsymbol{\mu},\boldsymbol{\Sigma})=-\frac{ND}{2}\ln(2\pi)-\frac{N}{2}\ln|\boldsymbol{\Sigma}|-\frac{1}{2}\sum_{n=1}^N(\mathbf{x}_n-\boldsymbol{\mu})^\mathrm{T}\boldsymbol{\Sigma}^{-1}(\mathbf{x}_n-\boldsymbol{\mu})</script><p>首先计算 $\boldsymbol{\mu}$:</p><script type="math/tex; mode=display">\frac\partial{\partial\boldsymbol{\mu}}\ln p(\mathbf{X}|\boldsymbol{\mu},\boldsymbol{\Sigma})=\sum_{n=1}^N\boldsymbol{\Sigma}^{-1}(\mathbf{x}_n-\boldsymbol{\mu})=0\quad\longrightarrow\quad\boldsymbol{\mu}_\mathrm{ML}=\frac1N\sum_{n=1}^N\mathbf{x}_n</script><p>然后计算 $\boldsymbol{\Sigma}$</p><script type="math/tex; mode=display">\begin{aligned}\mathrm{d}\ln p(\mathbf{X}|\boldsymbol{\mu},\boldsymbol{\Sigma}) &= 0- \frac{N}{2}\operatorname{Tr}(\boldsymbol{\Sigma}^{-1}\cdot \mathrm{d}\boldsymbol{\Sigma}) - \frac{1}{2} \operatorname{Tr}(\sum_{t=1}^{N} (\mathbf{x}_t-\boldsymbol{\mu})^{\mathrm{T}}(-\boldsymbol{\Sigma}^{-1}\cdot \mathrm{d}\boldsymbol{\Sigma}\cdot \boldsymbol{\Sigma}^{-1})(\mathbf{x}_{t}-\boldsymbol{\mu})) \\&= - \frac{N}{2}\operatorname{Tr}(\boldsymbol{\Sigma}^{-1}\cdot \mathrm{d}\boldsymbol{\Sigma}) - \frac{1}{2} \operatorname{Tr}(\sum_{t=1}^{N} (\mathbf{x}_{t}-\boldsymbol{\mu})(\mathbf{x}_t-\boldsymbol{\mu})^{\mathrm{T}}(-\boldsymbol{\Sigma}^{-1}\cdot \mathrm{d}\boldsymbol{\Sigma}\cdot \boldsymbol{\Sigma}^{-1})) \\&= - \frac{N}{2}\operatorname{Tr}(\boldsymbol{\Sigma}^{-1}\cdot \mathrm{d}\boldsymbol{\Sigma}) + \frac{1}{2} \operatorname{Tr}(\sum_{t=1}^{N} \boldsymbol{\Sigma}^{-1}(\mathbf{x}_{t}-\boldsymbol{\mu})(\mathbf{x}_t-\boldsymbol{\mu})^{\mathrm{T}}\boldsymbol{\Sigma}^{-1}\cdot \mathrm{d}\boldsymbol{\Sigma})\end{aligned}</script><p>(此处利用了 $\operatorname{Tr}(ABC)= \operatorname{Tr}(CAB)$ 的性质) </p><script type="math/tex; mode=display">\frac{\partial \ln p(\mathbf{X}|\boldsymbol{\mu},\boldsymbol{\Sigma})}{\partial \boldsymbol{\Sigma}} =0 \Rightarrow - \frac{N}{2} \boldsymbol{\Sigma}^{-1}+ \frac{1}{2} \boldsymbol{\Sigma}^{-1} (\mathbf{x}_{t}-\boldsymbol{\mu})(\mathbf{x}_t-\boldsymbol{\mu})^{\mathrm{T}} \boldsymbol{\Sigma}^{-1} =0</script><p>得到</p><script type="math/tex; mode=display">\boldsymbol{\Sigma_\mathrm{ML}}=\frac{1}{N}\sum_{n=1}^{N}(\mathbf{x}_{n}-\boldsymbol{\mu_\mathrm{ML}})(\mathbf{x}_{n}-\boldsymbol{\mu_\mathrm{ML}})^\mathrm{T}</script><p>即样本的样本协方差 (sample covariance matrix)。</p><h4 id="Matrix-cook-book"><a href="#Matrix-cook-book" class="headerlink" title="Matrix-cook-book"></a>Matrix-cook-book</h4><script type="math/tex; mode=display">\begin{aligned}\partial\mathbf{A}& \begin{array}{cc}=&0\end{array} & (\mathbf{A}\text{ is a constant})  \\\partial(\alpha\mathbf{X})& =\quad\alpha\partial\mathbf{X}  \\\partial(\mathbf{X}+\mathbf{Y})& =\quad\partial\mathbf{X}+\partial\mathbf{Y}  \\\partial(\mathrm{Tr}(\mathbf{X}))& =\quad \operatorname{Tr}(\partial\mathbf{X})  \\\partial(\mathbf{X}\mathbf{Y})& =\quad(\partial\mathbf{X})\mathbf{Y}+\mathbf{X}(\partial\mathbf{Y})  \\\partial(\mathbf{X}\circ\mathbf{Y})& =\quad(\partial\mathbf{X})\circ\mathbf{Y}+\mathbf{X}\circ(\partial\mathbf{Y})  \\\partial(\mathbf{X}\otimes\mathbf{Y})& =\quad(\partial\mathbf{X})\otimes\mathbf{Y}+\mathbf{X}\otimes(\partial\mathbf{Y})  \\\partial(\mathbf{X}^{-1})& =\quad-\mathbf{X}^{-1}(\partial\mathbf{X})\mathbf{X}^{-1}  \\\partial(\det(\mathbf{X}))& =\quad\det(\mathbf{X})\text{Tr}(\mathbf{X}^{-1}\partial\mathbf{X})  \\\partial(\ln(\det(\mathbf{X})))& =\quad\mathrm{Tr}(\mathbf{X}^{-1}\partial\mathbf{X})  \\\partial\mathbf{X}^{T}& =\quad(\partial\mathbf{X})^T  \\\partial\mathbf{X}^{H}& =\quad(\partial\mathbf{X})^H \end{aligned}</script><h3 id="Expectation-Maximization-EM-for-maximum-likelihood"><a href="#Expectation-Maximization-EM-for-maximum-likelihood" class="headerlink" title="Expectation-Maximization (EM) for maximum likelihood"></a>Expectation-Maximization (EM) for maximum likelihood</h3><h4 id="E-step"><a href="#E-step" class="headerlink" title="E step"></a>E step</h4><p>在 K-mean 算法中，对于第 $n$ 个样本点的分类，我们有：</p><script type="math/tex; mode=display">\gamma_{nk} = \begin{cases}  1; \quad k=\argmin_{j} \left\| \mathbf{x}_n-\boldsymbol{\mu}_j \right\|_{} \\  0 ; \quad \text{otherwise}\end{cases}</script><p>在引入了概率之后，我们则认为</p><script type="math/tex; mode=display">\gamma_{nk} = p(k|\mathbf{x}_n) = \frac{p(\mathbf{x}_n,k)}{p(\mathbf{x}_n)} = \frac{p(k)p(\mathbf{x}_n|k)}{p(\mathbf{x}_n)} = \frac{\pi_{k}G(\mathbf{x}_n|\boldsymbol{\mu}_k,\boldsymbol{\Sigma}_k)}{\sum_{j}\pi_j G(\mathbf{x}_n|\boldsymbol{\mu}_j,\boldsymbol{\Sigma}_j)}</script><p><img src='../../figure/机器学习笔记/1-Clustering/gmm_estep.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="M-step"><a href="#M-step" class="headerlink" title="M step"></a>M step</h4><script type="math/tex; mode=display">\pi_k=\frac{N_k}N\quad N_k=\sum_{n=1}^N\gamma(z_{nk})</script><script type="math/tex; mode=display">\begin{gathered}\boldsymbol{\mu}_k=\frac1{N_k}\sum_{n=1}^N\gamma(z_{nk})\mathbf{x}_n \\\boldsymbol{\Sigma}_{k}=\frac{1}{N_{k}}\sum_{n=1}^{N}\gamma(z_{nk})(\mathbf{x}_{n}-\boldsymbol{\mu}_{k})(\mathbf{x}_{n}-\boldsymbol{\mu}_{k})^{\mathrm{T}} \end{gathered}</script><p><img src='../../figure/机器学习笔记/1-Clustering/gmm_mstep.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="Summary-for-the-EM-algorithm-for-GMM"><a href="#Summary-for-the-EM-algorithm-for-GMM" class="headerlink" title="Summary for the EM algorithm for GMM"></a>Summary for the EM algorithm for GMM</h3><ul><li>Does it find the global optimum?<ul><li>No, like K-means, EM only finds the nearest local optimum and the optimum depends on the initialization</li></ul></li><li>GMM is more general then K-means by considering mixing weights, covariance matrices, and soft assignments.</li><li>Like K-means, it does not tell you the best K.</li></ul><h3 id="Questions-1"><a href="#Questions-1" class="headerlink" title="Questions"></a>Questions</h3><ul><li>How can EM for GMM degenerate back to k-mean algorithm<ul><li>指定 $\boldsymbol{\Sigma}$ 为 $k\mathbf{I}$</li><li>E-step 时让 $\gamma_{nk} \in {0,1}$</li></ul></li><li>Can you design a variant algorithm between k-mean and EM?</li></ul>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Support Vector Machine</title>
      <link href="/posts/5f9d1835.html"/>
      <url>/posts/5f9d1835.html</url>
      
        <content type="html"><![CDATA[<h2 id="Linear-classifiers-–-which-line-is-better"><a href="#Linear-classifiers-–-which-line-is-better" class="headerlink" title="Linear classifiers – which line is better?"></a>Linear classifiers – which line is better?</h2><p><img src='../../figure/人工智能笔记/7-Support-Vector-Machine/linear_classifiers.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>考虑这三条线性分类的线，虽然这三条线都正确的对数据做了分类，从直觉上来说黑色线的效果最好。这是因为这条线离两侧的数据点都比较远。这是因为数据可能有噪声，离数据点尽量远能够使得新的数据加入时，这个分类方式更不容易出错。</p><h3 id="Parameterizing-the-decision-boundary"><a href="#Parameterizing-the-decision-boundary" class="headerlink" title="Parameterizing the decision boundary"></a>Parameterizing the decision boundary</h3><p><img src='../../figure/人工智能笔记/7-Support-Vector-Machine/decision_boundary.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>首先将分界面用线性方程表示，此时正类满足 $\bm{w}\cdot \bm{x}+b&gt;0$，负类满足 $\bm{w}\cdot \bm{x}+b&lt;0$。</p><p>然后定义<strong>置信度</strong>为 $(\bm{w}\cdot \bm{x_j}+b)y_i$，其中 $y_i$ 的取值为 $\pm 1$。因此不论是正类还是负类，只要在正确的地方，它们的置信度都大于 $0$。</p><h3 id="Maximizing-the-margin"><a href="#Maximizing-the-margin" class="headerlink" title="Maximizing the margin"></a>Maximizing the margin</h3><p><img src='../../figure/人工智能笔记/7-Support-Vector-Machine/maximizing_the_margin.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>支持向量机的目标是最大化两侧的间隔，而间隔可以用点到直线的距离表示，因此定义间隔margin为</p><script type="math/tex; mode=display">2\gamma=\frac{\left\vert \bm{w}\cdot x^{+} + b \right\vert }{\left\| \bm{w} \right\|_{}} + \frac{\left\vert \bm{w}\cdot x^{-} + b \right\vert }{\left\| \bm{w} \right\|_{}} = \frac{2a}{\left\| \bm{w} \right\|_{}}</script><p>因此问题被建模为</p><script type="math/tex; mode=display">\begin{gathered}\max_{\boldsymbol{w},b}2\gamma=\frac{2a}{\|w\|} \\s.t.(w\cdot x_j+b)y_j\geq a~\forall j \end{gathered}</script><p>其中第二条式子表示在最大化间隔的同时还要两边的数据点都满足一定的置信度。</p><h3 id="Support-Vector-Machine"><a href="#Support-Vector-Machine" class="headerlink" title="Support Vector Machine"></a>Support Vector Machine</h3><p>同时我们发现 $a$ 可以是任意的，因此可以取 $a=1$，问题最终被简化为</p><script type="math/tex; mode=display">\min_{w,b}w\cdot w\\s.t.(w\cdot x_j+b)y_j\geq1\mathrm{~}\forall j</script><p>这个问题就是容易求解的。但是这个模型没有什么实用价值，因为现实中基本没有数据集可以被完美二分。</p><p><strong>支持向量</strong>：<br>落在 $\bm{w}\cdot \bm{x}+b=1$ 上的点。</p><p>支持向量机的分界面就是由这些支持向量决定的，改变其他点的位置不会影响分界面。</p><h2 id="What-if-data-is-not-linearly-separable"><a href="#What-if-data-is-not-linearly-separable" class="headerlink" title="What if data is not linearly separable?"></a>What if data is not linearly separable?</h2><p>在实际情况中，数据往往不可完美的线性分开(可能有噪声)，或者有时为了二分会导致margin非常窄。这时我们就要考虑新的方法。<br><img src='../../figure/人工智能笔记/7-Support-Vector-Machine/data_not_separable.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>此时建立新的模型，其中 $C$ 为错误的点的数量。</p><script type="math/tex; mode=display">\begin{aligned}&\min_{\boldsymbol{w},\boldsymbol{b}}\boldsymbol{w}\cdot\boldsymbol{w}+\boldsymbol{C}\#\mathrm{mistakes}\\&s.t.(\boldsymbol{w}\cdot\boldsymbol{x}_j+b)y_j\geq1 \quad \forall j\end{aligned}</script><p>但这是个NP难问题，同时这个方法无法区分错误的程度。比如有的点只差一点，有的点差很多，这应该要区别对待。</p><h3 id="Soft-margin-SVM"><a href="#Soft-margin-SVM" class="headerlink" title="Soft-margin SVM"></a>Soft-margin SVM</h3><p>我们引入松弛变脸 $\xi_{j}$，其中 $\xi$ 的取值与某个数据点的错误程度相关。那么模型写为：</p><script type="math/tex; mode=display">\begin{aligned}&&\min_{\boldsymbol{w},\boldsymbol{b},\boldsymbol{\xi}_j}\boldsymbol{w}\cdot\boldsymbol{w}+C\sum_j\xi_j \\&&\begin{aligned}\operatorname{s.t.}(\boldsymbol{w}\cdot\boldsymbol{x}_j+b)y_j\geq1-\xi_j\quad\forall j\end{aligned}\\&& \xi_{j}\geq0\quad\forall j \end{aligned}</script><p>式子中 $C$ 是调节因此。假如 $C \rightarrow \infty$，那么软间隔重新回到之前的硬间隔。</p><p>下图可以感受 $\xi$ 的几何意义：<br><img src='../../figure/人工智能笔记/7-Support-Vector-Machine/slack_variable.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="SVM-vs-Logistic-Regression"><a href="#SVM-vs-Logistic-Regression" class="headerlink" title="SVM vs. Logistic Regression"></a>SVM vs. Logistic Regression</h3><p>这里分析一下支持向量机和之前学过的线性模型的区别和联系。</p><p>松弛因子在下图中就是Hinge Loss，用公式可以写为</p><script type="math/tex; mode=display">\xi_{j}=(1-(\bm{w}\cdot \bm{x_j}+b)y_i)_{+} = \max_{}(0, 1-(\bm{w}\cdot \bm{x_j}+b)y_i)</script><p><img src='../../figure/人工智能笔记/7-Support-Vector-Machine/svm_loss.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>上图中同样也展示了Logistic Regression的Loss函数，为</p><script type="math/tex; mode=display">loss(f(x_j),y_j)=-logP(y_j|x_j,w,b)=log\left(1+e^{-(w\cdot x_j+b)\gamma_j}\right)</script><p>这里使用的是log似然，推导过程为：</p><script type="math/tex; mode=display">\begin{cases}    \displaystyle P(y=1|x)=\frac{1}{1+e^{-\theta^{\mathrm{T}}x}} \\    \displaystyle P(y=-1|x)=1-\frac{1}{1+e^{\theta^{\mathrm{T}}x}}=\frac{1}{1+e^{\theta^{\mathrm{T}}x}}\end{cases}\Rightarrow P(y|x)=\frac{1}{1+e^{- (\theta^{\mathrm{T}}x) \cdot y}}</script><p>观察Hinge loss和Log loss，可以发现两者比较相似，都是0-1 loss的凸替代，都有比较好的性质。但是和Log loss相比，在 $(\bm{w}\cdot x_j+b)y_j&gt;1$ 时，Hinge loss为 $0$，性质更好。</p><p>但是如果观察总的损失函数，我们发现支持向量机为 $\boldsymbol{w}\cdot\boldsymbol{w}+C\sum_j\xi_j$，这就相当于支持向量机先天就具有正则化项，因此有更好的抗过拟合的能力。</p><h2 id="Constrained-Optimization"><a href="#Constrained-Optimization" class="headerlink" title="Constrained Optimization"></a>Constrained Optimization</h2><h3 id="Lagrange-Multiplier-Method"><a href="#Lagrange-Multiplier-Method" class="headerlink" title="Lagrange Multiplier Method"></a>Lagrange Multiplier Method</h3><p>从上面的模型可以看出，支持向量机是一个约束优化问题。而优化约束问题的一般解决方法时使用拉格朗日函数。</p><p>一般约束问题可以写为：</p><script type="math/tex; mode=display">\begin{aligned}&\operatorname*{min}_{x}f(x)& \text{Convex optimization if}  \\&s.t.\ g(x)\leq0 & f,g\text{ are convex}  \\&h(x)=0& \text{h is affine} \end{aligned}</script><h4 id="Optimization-with-equality-constraints"><a href="#Optimization-with-equality-constraints" class="headerlink" title="Optimization with equality constraints"></a>Optimization with equality constraints</h4><p>首先只考虑等式约束的情形。设 $\mathbf{x}$ 为 $d$ 维向量，我们希望找到最优点 $\mathbf{x}^{*}$ 使得目标函数 $f(\mathbf{x})$ 最小并且满足约束 $g(\mathbf{x})=0$。从几何角度看，这个问题的目标是在方程 $g(\mathbf{x})=0$ 确定的 $d-1$ 维曲面上寻找能够使得目标函数最小化的点，即：<br><img src='../../figure/人工智能笔记/7-Support-Vector-Machine/lagrange_multiplier.png' width=660 style="display: block; margin-left: auto; margin-right: auto;"></p><p>那么对于最优点 $\mathbf{x}^{*}$:</p><ul><li>在约束曲面上的所有点 $\mathbf{x}$ 都满足 $\nabla g(\mathbf{x})$ 正交与约束曲面，因此 $\nabla g(\mathbf{x}^{*})$ 也正交于约束曲面</li><li>同时此时 $f(\mathbf{x})$ 取到极值，因此 $\nabla f(\mathbf{x}^{*})$ 也正交于约束曲面。(否则可以往梯度反方向移动，使得目标函数的值更小)</li></ul><p>由此可以得到</p><script type="math/tex; mode=display">\nabla f(\mathbf{x}^{*})+\lambda \nabla g(\mathbf{x}^{*})=0</script><p>基于上式，可以定义拉格朗日函数</p><script type="math/tex; mode=display">L(\mathbf{x},\lambda) = f(\mathbf{x}) + \lambda g(\mathbf{x})</script><p>当 $L(\mathbf{x},\lambda)$ 分别对 $\mathbf{x}$ 和 $\lambda$ 求导时，恰好可以得到 $\nabla f(\mathbf{x}^{<em>})+\lambda \nabla g(\mathbf{x}^{</em>})=0$ 和 $g(\mathbf{x})=0$，即我们对拉格朗日函数求极值时，恰好能够满足对 $f(\mathbf{x})$ 求极值以及满足约束 $g(\mathbf{x})=0$ 的条件。</p><h4 id="Optimization-with-inequality-constraints"><a href="#Optimization-with-inequality-constraints" class="headerlink" title="Optimization with inequality constraints"></a>Optimization with inequality constraints</h4><p>然后再考虑仅有不等式 $g(\mathbf{x})\le 0$ 约束的情形，几何解释同样如上图所示。对于不等式约束，最优点 $\mathbf{x}^{*}$ 有两种情形，一种在 $g(\mathbf{x})&lt;0$ 中，另一种在边界 $g(\mathbf{x})=0$ 上。</p><ul><li>对于 $g(\mathbf{x})&lt;0$ 的情形，约束 $g(x)\le 0$ 不起作用，则可以直接通过 $\nabla f(\mathbf{x})=0$ 获得最优点。此时相当于 $\lambda=0$。</li><li>对于 $g(\mathbf{x})=0$ 的情形，处理方式与等式约束基本相同，仅需注意此时 $\nabla f(\mathbf{x}^{<em>})$ 和 $\nabla g(\mathbf{x}^{</em>})$ 的方向相反，即 $\lambda&gt;0$。</li></ul><p>综合上述两种情况，在约束 $g(\mathbf{x})\le 0$ 的条件下最小化 $f(\mathbf{x})$ 的任务，可以转化为在如下约束下最小化 $L(\mathbf{x},\lambda)$ 的任务：</p><script type="math/tex; mode=display">\begin{aligned}s.t. \quad & g(\mathbf{x})\le 0 \\&\lambda\ge 0 \\&\lambda g(\mathbf{x}) =0\end{aligned}</script><p>上述约束就是 <strong>Karush-Kuhn-Tucker(KKT)</strong> 条件。</p><h4 id="Optimization-with-multiple-constraints"><a href="#Optimization-with-multiple-constraints" class="headerlink" title="Optimization with multiple constraints"></a>Optimization with multiple constraints</h4><p>将上述讨论结合起来，并且推广到多个约束的情形。考虑有 $m$ 个等式约束和 $n$ 不等式约束的优化问题：</p><script type="math/tex; mode=display">\begin{aligned}& \min_{\bm{x}} f(\bm{x}) \\s.t. \quad & h_i(\bm{x})=0 \quad (i=1, \ldots ,m) \\&g_i(\bm{x})\le 0 \quad(j=1, \ldots ,m)\end{aligned}</script><p>引入拉格朗日乘子 $\bm{\lambda}=(\lambda_1,\lambda_2, \ldots ,\lambda_m)^{\mathrm{T}}, \bm{\mu}=(\mu_1,\mu_2, \ldots ,\mu_n)^{\mathrm{T}}$，得到拉格朗日函数：</p><script type="math/tex; mode=display">L(\bm{x},\lambda,\mu)=f(\bm{x})+\sum_{i=1}^{m}\lambda_i h_i(\bm{x}) + \sum_{j=1}^{n}\mu_j g_j(\bm{x})</script><p>由不等式约束引入的 KKT 条件为：</p><script type="math/tex; mode=display">\begin{cases}    g_j(\bm{x})\le 0 \\    \mu_j\ge 0 \\    \mu_j g_j(\bm{x})=0\end{cases}</script><h3 id="Duality"><a href="#Duality" class="headerlink" title="Duality"></a>Duality</h3><p>一个优化问题可以从两个角度来考虑，即主问题(primal problem)和对偶问题(dual problem)。在约束最优化问题中，常常利用拉格朗日对偶性将原始问题(主问题)转换成对偶问题，通过解对偶问题来得到原始问题的解。</p><h4 id="Duality-problem-with-multiple-constraints"><a href="#Duality-problem-with-multiple-constraints" class="headerlink" title="Duality problem with multiple constraints"></a>Duality problem with multiple constraints</h4><p>对于上述的多约束问题，我们把需要解决的原问题称为<strong>主问题</strong></p><script type="math/tex; mode=display">\begin{aligned}& \min_{\bm{x}} f(\bm{x}) \\s.t. \quad & h_i(\bm{x})=0 \quad (i=1, \ldots ,m) \\&g_i(\bm{x})\le 0 \quad(j=1, \ldots ,m)\end{aligned}</script><p>根据其拉格朗日函数 $L(\bm{x},\lambda,\mu)=f(\bm{x})+\sum<em>{i=1}^{m}\lambda_i h_i(\bm{x}) + \sum</em>{j=1}^{n}\mu_j g_j(\bm{x})$，可以定义出该拉格朗日函数的<strong>对偶函数</strong></p><script type="math/tex; mode=display">\Gamma(\bm{\lambda},\bm{\mu}) =  \inf_{\bm{x}\in D}L(\bm{x},\bm{\lambda},\bm{\mu})=\inf_{\bm{x}\in D}\left(f(\bm{x})+\sum_{i=1}^m\lambda_i h_i(\bm{x})+\sum_{j=1}^n\mu_j g_j(\bm{x})\right)</script><p>记 $\bm{\tilde{x}}\in D$ 为主问题可行域中的一个点，主问题的最优值为 $p^{*}$，有</p><script type="math/tex; mode=display">\Gamma(\bm{\lambda},\bm{\mu})\leq L(\tilde{\bm{x}},\bm{\lambda},\bm{\mu})\leq f(\tilde{\bm{x}})\le p^{*}</script><p>可以看出对偶函数给出了主问题的下界。这个下界取决于 $\bm{\lambda}$ 和 $\bm{\mu}$，于是我们开始考虑：基于对偶函数能够获得的最好的下界是什么？这就引出了<strong>对偶问题</strong></p><script type="math/tex; mode=display">\max_{\bm{\lambda},\bm{\mu}} \Gamma(\bm{\lambda},\bm{\mu}) \\s.t. \quad \bm{\mu}\ge 0</script><p>记对偶问题的最优值为 $d^{<em>}$。考虑 $p^{</em>}$ 和 $d^{*}$ 的关系：</p><ul><li>$d^{<em>}\le p^{</em>}$，这称为“弱对偶性(weak duality)”成立；</li><li>$d^{<em>}=p^{</em>}$，则称为“强对偶性（strong duality）”成立，此时由对偶问题能获得主问题的最优下界</li></ul><p>对于一般的优化问题，强对偶性通常不成立，但是若主问题是凸优化问题，如主问题中 $f(\bm{x})$ 和 $g_j(\bm{x})$ 均为凸函数，$h_j(\bm{x})$ 为仿射函数(线性)，且其可行域中至少有一点使不等式约束严格成立，则此时强对偶性成立。</p><p>对于一般的问题，强对偶性和 KKT 条件的关系为：<br><img src='../../figure/人工智能笔记/7-Support-Vector-Machine/strong_duality_KKT.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>即在凸优化的条件下，两者等价。</p><h3 id="Solving-optimal-margin-classifier"><a href="#Solving-optimal-margin-classifier" class="headerlink" title="Solving optimal margin classifier"></a>Solving optimal margin classifier</h3><p>SVM 的优化函数是个凸优化问题，因此我们考虑使用对偶来求解。首先将原问题(这里先考虑能够满足二分的情况)：</p><script type="math/tex; mode=display">\begin{gathered}\max_{\boldsymbol{w},\boldsymbol{b}}\frac1{\|\boldsymbol{w}\|}\\s.t. \quad (w^T\cdot x_i+b)y_i\geq1,\forall i\end{gathered}</script><p>转化为约束满足问题的标准形式：</p><script type="math/tex; mode=display">\begin{gathered}\underset{\mathbf{w},b}{\operatorname*{min}}\frac12w^Tw\\s.t.\quad 1-(w^T\cdot x_i+b)y_i\leq0,\forall i\end{gathered}</script><p>然后写出拉格朗日函数：</p><script type="math/tex; mode=display">\mathcal{L}(w,b,\alpha)=\frac12w^Tw-\sum_{i=1}^m\alpha_i[y_i(w^Tx_i+b)-1]</script><p>对 $\omega$ 和 $b$ 求偏导，可以求解得到：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial \mathcal{L}}{\partial w}&=w-\sum_{i=1}^m\alpha_iy_ix_i=0\\\frac{\partial \mathcal{L}}{\partial b}&=\sum_{i=1}^m\alpha_iy_i=0\\w&=\sum_{i=1}^m\alpha_iy_ix_i\end{aligned}</script><p>可以发现此时 $w$ 可以表示成所有样本线性组合的形式。再将 $w$ 的值代回 $\mathcal{L}$ 的方程中，并且利用 $\sum_{i=1}^m\alpha_iy_i=0$，可以得到对偶问题</p><script type="math/tex; mode=display">\Gamma(\alpha)=\sum_{i=1}^{m}\alpha_{i}-\frac{1}{2}\sum_{i=1}^{m}\sum_{j=1}^{m}\alpha_{i}\alpha_{j}y_{i}y_{j}(x_{i}^{T}x_{j}) \\s.t. \quad \sum_{i=1}^m\alpha_iy_i=0, \alpha_i\ge 0</script><p>再考虑互补松弛条件，由于 SVM 问题中 $g(x)=1-(w^T\cdot x_i+b)y_i\leq0$，和置信度相关，因此如果 $\alpha_i&gt;0$，那么说明 $(w^{\mathrm{T}}\cdot x_i+b)y_i=1$，即置信度为 $1$。假如置信度不为 $1$，那么 $\alpha_i=0$。</p><p>而置信度为 $1$ 的点恰好都是支持向量，也就是说只有支持向量的点 $\alpha&gt;0$，其他点都有 $\alpha=0$。因此 $w=\sum_{i=1}^{m}\alpha_i y_i x_i$ 说明 $w$ 是支持向量的线性组合，和其他点无关。这里体现了支持向量存在稀疏解的优势。</p><p>同时观察 $\mathcal{L}(\alpha)$，发现式子中包含是 $x_i$ 与 $x_j$ 求内积的形式。</p>]]></content>
      
      
      <categories>
          
          <category> artificial intelligence </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>传输层</title>
      <link href="/posts/ec75daa1.html"/>
      <url>/posts/ec75daa1.html</url>
      
        <content type="html"><![CDATA[<p>为什么需要传输层？</p><ul><li>网络层虽然把数据从一台主机传输到另一台，但是还需要解决数据究竟传输到哪个应用程序的问题</li><li>对于发送数据端而言，有数据需要发送，那么就需要把这些数据收集下来交给网络层进行传输</li></ul><h2 id="概述和传输层服务"><a href="#概述和传输层服务" class="headerlink" title="概述和传输层服务"></a>概述和传输层服务</h2><h3 id="传输层的位置"><a href="#传输层的位置" class="headerlink" title="传输层的位置"></a>传输层的位置</h3><ul><li>传输层位于应用层和网络层之间。基于网络层提供的服务，向分布式应用程序提供通信服务</li><li>按照因特网的“端到端”设计原则，应用程序只运行在终端上，即不需要为网络设备编写程序</li><li>站在应用程序的角度，传输层应提供进程之间<strong>本地通信的抽象</strong>。(用户感受不到不同的应用运行在不同的终端上)</li></ul><h3 id="不同终端上的进程如何通信"><a href="#不同终端上的进程如何通信" class="headerlink" title="不同终端上的进程如何通信"></a>不同终端上的进程如何通信</h3><ul><li>设想在应用程序和网络之间存在一扇“门”：<ul><li>需要发送报文时：发送进程将报文推到门外</li><li>门外的运输设施（因特网）将报文送到接收进程的门口</li><li>需要接收报文时：接收进程打开门，即可收到报文</li></ul></li><li>在TCP/IP网络中，这扇“门”称为套接字（socket）</li></ul><p><img src='../../figure/计算机网络笔记/传输层/套接字.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="传输层提供什么服务？"><a href="#传输层提供什么服务？" class="headerlink" title="传输层提供什么服务？"></a>传输层提供什么服务？</h3><ul><li>无连接的服务(不可靠)，UDP</li><li>面向连接的服务(可靠)，TCP<ul><li>只能保证可靠，但是不能像虚电路一样保证传输质量。因为TCP建立在不可靠的IPv4之上。</li></ul></li></ul><h3 id="传输层实现什么功能？"><a href="#传输层实现什么功能？" class="headerlink" title="传输层实现什么功能？"></a>传输层实现什么功能？</h3><ul><li>UDP，最低限度服务<ul><li>进程到进程的传输</li><li>错误校验</li></ul></li><li>TCP，最低限度服务加上增强服务<ul><li>进程到进程的传输</li><li>错误校验</li><li>可靠传输(类似数据链路层，依靠ACK，或者还有pipline使用滑动窗口)</li><li>流量控制</li><li>拥塞控制</li></ul></li></ul><h2 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h2><h3 id="创建一个网络应用"><a href="#创建一个网络应用" class="headerlink" title="创建一个网络应用"></a>创建一个网络应用</h3><p>首先编写一个分布式程序，使其运行在不同的端系统上，并通过网络通信。</p><p>然后选择应用程序体系结构，主流的是客户-服务器体系结构（C/S）</p><ul><li>有一台总是在线的主机，运行一个<strong>服务器程序(server)</strong>，服务器主机具有永久的、众所周知的地址</li><li>用户终端上运行一个<strong>客户程序（client）</strong>，需要时主动与服务器程序通信，请求服务</li><li>客户只与服务器通信，客户之间不通信</li></ul><p>进程需要一个标识，以便其它进程能够找到它。进程标识包括：</p><ul><li>主机地址</li><li>主机上与该进程关联的<strong>端口号</strong><h3 id="应用编程接口：socket-API"><a href="#应用编程接口：socket-API" class="headerlink" title="应用编程接口：socket API"></a>应用编程接口：socket API</h3>应用需<strong>显式地</strong>创建、使用和释放套接字</li><li>采用客户-服务器模式：<ul><li>客户总是主动发起通信的一方，服务器始终在等待客户的服务请求到来</li></ul></li><li>应用可以通过socket API调用两种传输服务:<ul><li>不可靠的数据报服务：由UDP协议实现</li><li>可靠的字节流服务：由TCP协议实现</li></ul></li></ul><h4 id="基于UDP的套接字通信流程"><a href="#基于UDP的套接字通信流程" class="headerlink" title="基于UDP的套接字通信流程"></a>基于UDP的套接字通信流程</h4><p>服务器端可以服务许多客户端，同时对客户端先来先服务的原则。<br>服务器可以被网络攻击者攻击，即控制大量机器访问该服务器，让正常用户无法访问。</p><p><img src='../../figure/计算机网络笔记/传输层/UDP套接字通信流程.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="使用TCP套接字实现回音服务"><a href="#使用TCP套接字实现回音服务" class="headerlink" title="使用TCP套接字实现回音服务"></a>使用TCP套接字实现回音服务</h4><p>使用TCP套接字编程时，可将TCP连接想像成一对套接字之间的一条封闭管道：</p><ul><li>发送端TCP将要发送的字节序列从管道的一端（套接字）送入</li><li>接收端TCP从管道的另一端（套接字）取出字节序列</li><li>在管道中传输的字节不丢失，并<strong>保持顺序</strong></li></ul><p><img src='../../figure/计算机网络笔记/传输层/TCP套接字实现回音服务.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="服务器使用多个套接字服务客户"><a href="#服务器使用多个套接字服务客户" class="headerlink" title="服务器使用多个套接字服务客户"></a>服务器使用多个套接字服务客户</h4><ul><li>服务器进程在监听套接字上等待客户的连接请求</li><li>客户进程创建一个本地套接字，与服务器的监听套接字通信。<ul><li>在此过程中，客户TCP向服务器TCP发送连接请求</li></ul></li><li>收到连接请求后，服务器进程创建一个临时套接字（称<strong>连接套接字</strong>）和一个<strong>新的服务器进程</strong>，与客户进程通信</li><li>服务器进程回到监听套接字上继续等待。<ul><li>此举允许服务器同时服务多个客户</li></ul></li><li>客户服务结束后，服务器销毁进程，关闭连接套接字</li></ul><p><img src='../../figure/计算机网络笔记/传输层/基于TCP套接字的通信流程.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><h2 id="传输层复用和分用"><a href="#传输层复用和分用" class="headerlink" title="传输层复用和分用"></a>传输层复用和分用</h2><ul><li>（发送端）复用：传输层从多个套接字收集数据，交给网络层发送</li><li>（接收端）分用：传输层将从网络层收到的数据，交付给正确的套接字</li></ul><p>就像寄信，要把信送给同一个地方的每个人，地址就相当于IP地址，名字就相当于端口号。</p><h3 id="套接字标识与端口号"><a href="#套接字标识与端口号" class="headerlink" title="套接字标识与端口号"></a>套接字标识与端口号</h3><ul><li>端口号是套接字标识的一部分：<ul><li>每个套接字在本地关联一个端口号</li><li>端口号是一个16比特的数</li></ul></li><li>端口号的分类：<ul><li>熟知端口：0～1023，由公共域协议使用</li><li>注册端口：1024～49151，需要向IANA注册才能使用</li><li>动态和/或私有端口：49152～65535，一般程序使用</li></ul></li></ul><h2 id="无连接传输：UDP"><a href="#无连接传输：UDP" class="headerlink" title="无连接传输：UDP"></a>无连接传输：UDP</h2><h3 id="UDP提供的服务"><a href="#UDP提供的服务" class="headerlink" title="UDP提供的服务"></a>UDP提供的服务</h3><ul><li>UDP提供的服务：<ul><li>进程到进程之间的报文交付</li><li>报文完整性检查（可选）：检测并丢弃出错的报文</li></ul></li><li>UDP需要实现的功能：<ul><li>复用和分用</li><li>报文检错</li></ul></li></ul><h3 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h3><p><img src='../../figure/计算机网络笔记/传输层/UDP报文格式.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><ul><li>用于复用和分用的字段：源端口号，目的端口号</li><li>用于检测报文错误的字段：报文总长度，校验和（checksum）</li></ul><h3 id="UDP校验和计算"><a href="#UDP校验和计算" class="headerlink" title="UDP校验和计算"></a>UDP校验和计算</h3><p>计算UDP校验和时，要包括伪头、UDP头和数据三个部分<br><img src='../../figure/计算机网络笔记/传输层/UDP校验和计算.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="为什么需要UDP"><a href="#为什么需要UDP" class="headerlink" title="为什么需要UDP"></a>为什么需要UDP</h3><ul><li>应用可以尽可能快地发送报文：<ul><li>无建立连接的延迟</li><li>不限制发送速率（不进行拥塞控制和流量控制）</li></ul></li><li>报头开销小</li><li>协议处理简单</li></ul><p>UDP适合哪些应用？</p><ul><li>容忍丢，但对延迟敏感的应用，如流媒体</li><li>以单次请求/响应为主的应用，如DNS</li><li>若应用要求基于UDP进行可靠传输。由应用层实现可靠性</li></ul><p>UDP包通常不能穿过防火墙。</p><h2 id="面向连接的传输：TCP"><a href="#面向连接的传输：TCP" class="headerlink" title="面向连接的传输：TCP"></a>面向连接的传输：TCP</h2><h3 id="TCP-概述"><a href="#TCP-概述" class="headerlink" title="TCP 概述"></a>TCP 概述</h3><ul><li>TCP服务模型在一对通信的进程之间提供一条理想的字节流管道</li><li>点到点通信:仅涉及一对通信进程<ul><li>因为会创建临时的套接字和进程来处理</li></ul></li><li>全双工：可以同时双向传输数据</li><li>可靠、有序的字节流：不保留报文边界</li></ul><p>需要的机制</p><ul><li>建立连接:<ul><li>通信双方为本次通信建立数据传输所需的状态（套接字、缓存、变量等）</li></ul></li><li>可靠数据传输：<ul><li>流水线式发送，报文段检错，丢失重传</li></ul></li><li>流量控制:<ul><li>发送方不会令接收方缓存溢出</li></ul></li></ul><h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p><img src='../../figure/计算机网络笔记/传输层/TCP报文格式.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="重要的TCP选项"><a href="#重要的TCP选项" class="headerlink" title="重要的TCP选项"></a>重要的TCP选项</h4><ul><li>最大段长度（MSS）：<ul><li>TCP段中可以携带的最大数据字节数</li><li>建立连接时，每个主机可声明自己能够接受的MSS，缺省为536字节</li></ul></li><li>窗口比例因子（window scale）：<ul><li>建立连接时，双方可以协商一个窗口比例因子</li><li>实际接收窗口大小 = window size * 2^window scale</li></ul></li><li>选择确认（SACK）：<ul><li>最初的TCP协议只使用累积确认</li><li>改进的TCP协议引入选择确认，允许接收端指出缺失的数据字节</li></ul></li></ul><h3 id="TCP可靠数据传输"><a href="#TCP可靠数据传输" class="headerlink" title="TCP可靠数据传输"></a>TCP可靠数据传输</h3><p>TCP 在不可靠的IP服务上建立可靠的数据传输</p><ul><li>基本机制<ul><li>发送端：流水线式发送数据、等待确认、超时重传</li><li>接收端：进行差错检测，采用累积确认机制</li></ul></li><li>乱序段处理：协议没有明确规定<ul><li>接收端不缓存：可以正常工作，处理简单，但效率低</li><li>接收端缓存：效率高，但处理复杂</li></ul></li></ul><h4 id="一个高度简化的TCP协议"><a href="#一个高度简化的TCP协议" class="headerlink" title="一个高度简化的TCP协议"></a>一个高度简化的TCP协议</h4><ul><li>接收方：<ul><li>确认方式：采用<strong>累积确认</strong>，仅在正确、按序收到报文段后，更新确认序号；其余情况，重复前一次的确认序号（与GBN类似）</li><li>失序报文段处理：<strong>缓存</strong>失序的报文段（与SR类似）</li></ul></li><li>发送方：<ul><li>发送策略：流水线式发送报文段</li><li>定时器的使用：仅对最早未确认的报文段使用<strong>一个重传定时器</strong>（与GBN类似）</li><li>重发策略：仅在超时后<strong>重发最早未确认的报文段</strong>（与SR类似，因为接收端缓存了失序的报文段）</li></ul></li></ul><h4 id="TCP-发送方"><a href="#TCP-发送方" class="headerlink" title="TCP 发送方"></a>TCP 发送方</h4><p>在此协议下，TCP发送方要处理的事件有：</p><ul><li>收到应用数据：<ul><li>创建并发送TCP报文段</li><li>若当前没有定时器在运行（没有已发送、未确认的报文段），启动定时器</li></ul></li><li>超时:<ul><li>重传包含最小序号的、未确认的报文段</li><li>重启定时器</li></ul></li><li>收到ACK：<ul><li>如果确认序号大于基序号（已发送未确认的最小序号）：</li><li>推进发送窗口（更新基序号）</li><li>如果发送窗口中还有未确认的报文段，启动定时器，否则终止定时器</li></ul></li></ul><h5 id="如何设置超时值"><a href="#如何设置超时值" class="headerlink" title="如何设置超时值"></a>如何设置超时值</h5><ul><li>若超时值太小，容易产生不必要的重传</li><li>若超时值太大，则丢包恢复的时间太长</li></ul><p>超时值应大于RTT，但RTT是变化的，所以先估计RTT。</p><ul><li><strong>SampleRTT</strong>：RTT是变化的，需要实时测量从发出某个报文段到收到其确认报文段之间经过的时间，该时间即为 SampleRTT。</li><li><strong>EstimatedRTT</strong>：由于 SampleRTT 波动很大，更有意义的是计算其平均值，该平均值即为 EstimatedRTT。</li></ul><p>使用指数加权移动平均估算 EstimatedRTT：</p><script type="math/tex; mode=display">EstimatedRTT = (1- a)* EstimatedRTT + a* SampleRTT</script><p>通常 $a=0.125$<br><img src='../../figure/计算机网络笔记/传输层/采样RTT与估算RTT.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><p>估算出RTT之后，我们希望超时值 TimeoutInterval 能够比 EstimatedRTT 大一些，满足使得大多数正常传输不超时。TimeoutInterval 和 TimeoutInterval 之间的差值应当与 RTT 的波动幅度相关，这里考虑 DevRTT。其中</p><script type="math/tex; mode=display">DevRTT = (1-b)*DevRTT + b*|SampleRTT-EstimatedRTT|</script><p>通常 $b=0.25$</p><h5 id="TCP确认的二义性"><a href="#TCP确认的二义性" class="headerlink" title="TCP确认的二义性"></a>TCP确认的二义性</h5><ul><li>TCP确认的二义性问题：<ul><li>重传的TCP报文段使用与原报文段相同的序号</li><li>发送端收到确认后 ，无法得知是对哪个报文段进行的确认</li></ul></li><li>二义性确认带来的问题：<ul><li>对重传报文段测量的SampleRTT，可能不准确</li></ul></li><li>解决方法：<ul><li>忽略有二义性的确认，只对一次发送成功的报文段测量SampleRTT ，并更新EstimtedRTT</li><li>当TCP重传一个段时，停止测量SampleRTT</li></ul></li></ul><div style="text-align: center;">  <img src='../../figure/计算机网络笔记/传输层/TCP确认的二义性1.png' height=200 style="display: inline-block; margin-right: 10px;">  <img src='../../figure/计算机网络笔记/传输层/TCP确认的二义性2.png' height=200 style="display: inline-block; margin-right: 10px;"></div><h5 id="定时器补偿"><a href="#定时器补偿" class="headerlink" title="定时器补偿"></a>定时器补偿</h5><p>如果为了解决TCP确认的二义性，而停止测量SampleRTT，可能会面临下面的问题：</p><ul><li>简单忽略重传报文段的问题：<ul><li>重传意味着超时值可能偏小了，需要增大</li><li>若简单忽略重传报文段（不更新EstimtedRTT），则超时值也不会更新，超时设置过小的问题没有解决</li></ul></li><li>解决方法：<ul><li>采用定时器补偿策略，发送方每重传一个报文段，就直接将超时值增大一倍（不依赖于RTT的更新）</li><li>若连续发生超时事件，超时值呈指数增长（至一个设定的上限值）</li></ul></li></ul><p>Karn算法结合使用RTT估计值和定时器补偿策略确定超时值：</p><ul><li>使用EstimatedRTT估计初始的超时值</li><li>若发生超时，每次重传时对定时器进行补偿，<em>直到成功传输一个报文段为止</em></li><li>若收到上层应用数据、或某个报文段没有重传就被确认了，用最近的EstimatedRTT估计超时值</li></ul><h4 id="TCP的接收端"><a href="#TCP的接收端" class="headerlink" title="TCP的接收端"></a>TCP的接收端</h4><p>理论上，接收端只需区分两种情况：</p><ul><li>收到期待的报文段：发送更新的确认序号</li><li>其它情况：重复当前的确认序号</li></ul><h5 id="推迟确认"><a href="#推迟确认" class="headerlink" title="推迟确认"></a>推迟确认</h5><ul><li>为减小通信量，TCP允许接收端推迟确认：<ul><li>接收端可以在收到若干个报文段后，发送一个累积确认的报文段</li></ul></li><li>推迟确认带来的问题：<ul><li>若延迟太大，会导致不必要的重传</li><li>推迟确认造成RTT估计不准确</li></ul></li><li>TCP协议规定：<ul><li>推迟确认的时间最多为500ms</li><li>接收方至少每隔一个报文段使用正常方式进行确认</li></ul></li></ul><h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><p>仅靠超时重发丢失的报文段，恢复太慢，因此发送方可利用重复ACK检测报文段丢失：</p><ul><li>发送方通常连续发送许多报文段</li><li>若仅有个别报文段丢失，发送方将收到多个重复序号的ACK</li><li>多数情况下IP按序交付分组，重复ACK极有可能因丢包产生</li></ul><p>TCP协议规定：当发送方收到对同一序号的3次重复确认时，立即重发包含该序号的报文段。<br>所谓快速重传，就是在定时器到期前重发丢失的报文段</p><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><h4 id="接收缓存"><a href="#接收缓存" class="headerlink" title="接收缓存"></a>接收缓存</h4><p>TCP接收端有一个接收缓存，接收端TCP将收到的数据放入接收缓存，应用进程从接收缓存中读数据。如果接收缓存中的数据未及时取走，后续到达的数据可能会因缓存溢出而丢失。<br><img src='../../figure/计算机网络笔记/传输层/接收缓存.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>因此流量控制希望发送端TCP通过调节发送速率，不使接收端缓存溢出。</p><h4 id="TCP如何进行流量控制"><a href="#TCP如何进行流量控制" class="headerlink" title="TCP如何进行流量控制"></a>TCP如何进行流量控制</h4><p>接收缓存中的可用空间称为接收窗口：</p><script type="math/tex; mode=display">RcvWindow = RcvBuffer-[LastByteRcvd -LastByteRead]</script><p>接收方将 RcvWindow 放在报头中，向发送方通告接收缓存的可用空间，从而发送方限制未确认的字节数不超过接收窗口的大小，即：</p><script type="math/tex; mode=display">LastByteSent-LastByteAcked ≦ RcvWindow</script><h4 id="非零窗口通告与零窗口探测"><a href="#非零窗口通告与零窗口探测" class="headerlink" title="非零窗口通告与零窗口探测"></a>非零窗口通告与零窗口探测</h4><p>在理论上，当接收窗口为0时，发送方必须停止发送；当接收窗口变为非0时，接收方应通告增大的接收窗口。而在TCP协议中，触发一次TCP传输需要满足以下三个条件之一：</p><ul><li>应用程序调用</li><li>超时</li><li>收到数据/确认</li></ul><p>对于单向传输中的接收方，只有第三个条件能触发传输，但是当发送方停止发送后，接收方不再收到数据，无法返回确认。因此就产生了一个死锁。要解决这个问题，发送端在接收到<strong>零窗口通告之后</strong>，可以采用<strong>零窗口探测</strong>。</p><p>即发送端收到零窗口通告时，启动一个<strong>坚持定时器</strong>，定时器超时后，发送端发送一个零窗口探测报文段（序号为上一个段中最后一个字节的序号）。接收端在响应的报文段中通告当前接收窗口的大小，若发送端仍收到零窗口通告，重新启动坚持定时器</p><h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>TCP拥塞控制需要回答三个问题：</p><ul><li>发送方如何感知网络拥塞？</li><li>发送方采用什么机制来限制发送速率？</li><li>发送方感知到网络拥塞后，采取什么策略调节发送速率？</li></ul><h3 id="拥塞检测和速率限制"><a href="#拥塞检测和速率限制" class="headerlink" title="拥塞检测和速率限制"></a>拥塞检测和速率限制</h3><p><strong>发送方如何感知网络拥塞</strong>：<br>由于拥塞发生在网络层，因此发送方只能利用丢包事件感知拥塞。拥塞会造成丢包和分组延迟增大，那么对于传输层来说，无论是丢包还是分组延迟过大，对于发送端来说都是丢包了。</p><p><strong>发送方采用什么机制限制发送速率</strong>：<br>和流量控制中的接收窗口类似，发送方使用拥塞窗口 cwnd 限制已发送未确认的数据量。</p><script type="math/tex; mode=display">LastByteSent-LastByteAcked \le  cwnd</script><script type="math/tex; mode=display">rate =\frac{cwnd}{RTT}Bytes/sec</script><h3 id="拥塞窗口的调节策略：AIMD"><a href="#拥塞窗口的调节策略：AIMD" class="headerlink" title="拥塞窗口的调节策略：AIMD"></a>拥塞窗口的调节策略：AIMD</h3><ul><li>乘性减（<strong>M</strong>ultiplicative <strong>D</strong>ecrease）:发送方检测到丢包后，将cwnd的大小减半（但不能小于一个MSS）。目的：迅速减小发送速率，缓解拥塞</li><li>加性增（<strong>A</strong>dditive <strong>I</strong>ncrease）：若无丢包，每经过一个RTT，将cwnd增大一个MSS，直到检测到丢包。目的：缓慢增大发送速率，避免振荡</li></ul><p><img src='../../figure/计算机网络笔记/传输层/AIMD拥塞调节.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="TCP慢启动-Slow-Start"><a href="#TCP慢启动-Slow-Start" class="headerlink" title="TCP慢启动 (Slow Start)"></a>TCP慢启动 (Slow Start)</h3><p>优秀的拥塞窗口的调节策略希望发送速率能够尽可能地贴近可用的带宽，而AIMD策略使用加性增的变化速度太慢。因此这里引入慢启动。</p><p>慢启动的基本思想：</p><ul><li>在新建连接上<strong>指数增大</strong>cwnd，直至检测到丢包（此时终止慢启动）</li><li>希望迅速增大cwnd至可用的发送速度</li></ul><h3 id="区分不同的丢包事件"><a href="#区分不同的丢包事件" class="headerlink" title="区分不同的丢包事件"></a>区分不同的丢包事件</h3><p>超时和收到3个重复的ACK，它们反映出来的网络拥塞程度是步一样的。</p><ul><li>超时：说明网络交付能力很差</li><li>收到3个重复的ACK：说明网络仍有一定的交付能力</li></ul><p>因此目前的TCP实现区分上述两种不同的丢包事件</p><ul><li>收到3个重复的ACK：<ul><li>将cwnd降至一半</li><li>使用AIMD调节cwnd</li></ul></li><li>超时：<ul><li>设置门限 =cwnd/2</li><li>cwnd=1MSS</li><li>使用慢启动增大cwnd至门限</li><li>使用AIMD调节cwnd</li></ul></li></ul><h3 id="TCP拥塞控制的实现"><a href="#TCP拥塞控制的实现" class="headerlink" title="TCP拥塞控制的实现"></a>TCP拥塞控制的实现</h3><p>发送方维护变量ssthresh，发生丢包时，ssthresh=cwnd/2，<br>ssthresh是从慢启动转为拥塞避免(Congestion Avoidance) 的分水岭：</p><ul><li>cwnd低于门限时，执行慢启动</li><li>cwnd高于门限：执行拥塞避免<br>拥塞避免阶段，拥塞窗口线性增长：每当收到ACK， cwnd=cwnd + MSS*(MSS/cwnd)</li></ul><p>检测到3个重复的ACK后：</p><ul><li>TCP Reno实现： cwnd= ssthresh+3MSS，线性增长</li><li>TCP Tahoe实现：cwnd=1 MSS，慢启动</li></ul><p><img src='../../figure/计算机网络笔记/传输层/TCP拥塞实现.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p>]]></content>
      
      
      <categories>
          
          <category> computer network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8253/4 Timer</title>
      <link href="/posts/967533ad.html"/>
      <url>/posts/967533ad.html</url>
      
        <content type="html"><![CDATA[<h2 id="8253-芯片结构"><a href="#8253-芯片结构" class="headerlink" title="8253 芯片结构"></a>8253 芯片结构</h2><p><img src='../../figure/计算机组成笔记/8253-4-Timer/8253芯片结构.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></p><p>使用 8253 作为计数器是因为使用 CPU 进行计数的话，可能会因为中断等问题而不可控。比如<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    MOV CX, N</span><br><span class="line">AGAIN:LOOP AGAIN</span><br></pre></td></tr></table></figure></p><p>可以进行计时，但是软件方法并不稳定。因此引入了 8253 这一硬件。<br><img src='../../figure/计算机组成笔记/8253-4-Timer/8253接脚.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><ul><li>左侧的 $A_1A_0$ 选择 Counter 或者控制寄存器。当 $A_1A_0=00,01,10,11$ 时，分别选择 Counter0, Counter1, Counter2, Control Register。</li><li>右侧是三个 Counter。工作流程为：门控信号有效时，给 Counter 一个计数初值 N，然后在外部时钟的驱动下 Counter 开始倒数，倒数到 0 的时候 OUT 进行输出。同时输出的形式不仅仅可以是方波，也可以有不同的 duty cycle。<ul><li>CLK 是驱动用的时钟</li><li>GATE 是门控，有效时 Counter 才工作</li><li>OUT 是输出信号。</li></ul></li><li>这里的 Counter 最大可以将频率降低 $65536$(Binary) 或者 $10000$(BCD) 倍。</li></ul><h3 id="Counter-内部结构"><a href="#Counter-内部结构" class="headerlink" title="Counter 内部结构"></a>Counter 内部结构</h3><p><img src='../../figure/计算机组成笔记/8253-4-Timer/counter内部结构.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><ul><li>$CR$ 寄存器中储存的是计数初值。计数初值最大是 $0$，之后会减到 $65535$ 或者 $9999$。</li><li>$CE$ 中储存的是计数值。最开始初始化为计数初值，然后会在时钟的驱动下自减</li><li>$OL$ 可以锁存当前的计数值</li></ul><h3 id="控制字格式"><a href="#控制字格式" class="headerlink" title="控制字格式"></a>控制字格式</h3><p><img src='../../figure/计算机组成笔记/8253-4-Timer/控制寄存器格式.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>$SC$ 用于选择当前 Counter<br><img src='../../figure/计算机组成笔记/8253-4-Timer/counter选择.png' width=250 style="display: block; margin-left: auto; margin-right: auto;"></p><p>$RW$ 与读写有关<br><img src='../../figure/计算机组成笔记/8253-4-Timer/读写控制.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>其中 00 指的是把计数值写到上述 $OL$ 中。<br>其他几种情况在考虑写高字节还是低字节。这是因为寄存器有 $16$ 位，而数据线只有 $8$ 位。</p><p>$M$ 用于选择模式<br><img src='../../figure/计算机组成笔记/8253-4-Timer/模式选择.png' width=150 style="display: block; margin-left: auto; margin-right: auto;"></p><p>$BCD$ 表示是否采用 BCD 编码<br><img src='../../figure/计算机组成笔记/8253-4-Timer/编码模式.png' width=250 style="display: block; margin-left: auto; margin-right: auto;"></p>]]></content>
      
      
      <categories>
          
          <category> computer organization </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8255 PPI芯片</title>
      <link href="/posts/6365978a.html"/>
      <url>/posts/6365978a.html</url>
      
        <content type="html"><![CDATA[<h2 id="芯片结构"><a href="#芯片结构" class="headerlink" title="芯片结构"></a>芯片结构</h2><h3 id="I-O-模块的基本结构"><a href="#I-O-模块的基本结构" class="headerlink" title="I/O 模块的基本结构"></a>I/O 模块的基本结构</h3><p><img src='../../figure/计算机组成笔记/8255-PPI芯片/IO模块基本结构.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>如上图所示，I/O 模块的左侧是和系统的接口，系统可以和 I/O 模块交互数据，地址和控制信息。同时 Status/Control Register 通常会存储一些 I/O 模块的状态信息和控制字，可以与 CPU 进行读写操作。</p><p>I/O 模块右侧是与外设的交互接口，和外设交换数据和状态。</p><h3 id="8255-芯片结构"><a href="#8255-芯片结构" class="headerlink" title="8255 芯片结构"></a>8255 芯片结构</h3><p><img src='../../figure/计算机组成笔记/8255-PPI芯片/8255芯片结构.png' width=700 style="display: block; margin-left: auto; margin-right: auto;"></p><p>可以看出8255芯片基本满足 I/O 模块的基本结构。</p><ul><li>对于右侧，有 Port A，Port B，Port C 对外进行输入输出，同时还能组合成 Group A，Group B。</li><li>对于左侧，就是和 CPU 进行交互的数据线以及控制线。<ul><li>$\overline{RD},\overline{WR}$ 表示读写信号</li><li>$A_0,A_1$ 用于选择 Port A，Port B，Port C 以及 Control Register(CR)。<ul><li>$A_0A_1=00,01,10,11$ 时，分别选择 Port A，Port B，Port C，CR。此时 CPU 可以和这些 buffer 或者 register 进行读写操作。</li></ul></li><li>$\overline{CS}$ 是片选信号</li></ul></li></ul><h3 id="操作模式-Operation-Modes"><a href="#操作模式-Operation-Modes" class="headerlink" title="操作模式(Operation Modes)"></a>操作模式(Operation Modes)</h3><ul><li>输入输出模式(Input/output modes)<ul><li>Mode 0, 简单输入输出模式(simple I/0 mode)<ul><li>PA，PB，PC与外设可以直接读或者写</li><li>传输速度一样，不需要握手信号</li></ul></li><li>Mode 1<ul><li>PA，PB与外设进行读或者写，需要握手信号</li><li>PCU(PC3-PC7)，PCL(PC0-PC2) 用作PA，PB的握手信号(只需要3个位)</li></ul></li><li>Mode 2<ul><li>PA能够进行读以及写操作。</li><li>PCU(PC3-PC7)做握手信号</li></ul></li></ul></li><li>位的设置与清除模式(BSR, bit set/reset mode)<ul><li>只有PC能做输出端口</li><li>PC的每个位都可以单独设置</li></ul></li></ul><h3 id="控制寄存器与操作模式"><a href="#控制寄存器与操作模式" class="headerlink" title="控制寄存器与操作模式"></a>控制寄存器与操作模式</h3><p><img src='../../figure/计算机组成笔记/8255-PPI芯片/8255模式选择.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="输入输出模式"><a href="#输入输出模式" class="headerlink" title="输入输出模式"></a>输入输出模式</h4><ul><li>Group A<ul><li>$D_6D_5$ 用于选择模式<ul><li>00-Mode 0, 01-Mode 1, 1*-Mode 2</li></ul></li><li>$D_4$ 选择 Port A 的输入输出模式<ul><li>1-Input, 0-Output</li></ul></li><li>$D_3$ 选择 PCU 的输入输出模式<ul><li>1-Input, 0-Output</li></ul></li></ul></li><li>Group B<ul><li>$D_2$ 用于选择模式<ul><li>0-Mode 0, 1-Mode 1</li></ul></li><li>$D_1$ 选择 Port B 的输入输出模式<ul><li>1-Input, 0-Output</li></ul></li><li>$D_0$ 选择 PCL 的输入输出模式<ul><li>1-Input, 0-Output</li></ul></li></ul></li></ul><h4 id="BSR-模式"><a href="#BSR-模式" class="headerlink" title="BSR 模式"></a>BSR 模式</h4><p><img src='../../figure/计算机组成笔记/8255-PPI芯片/BSR模式.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>$D_3D_2D_1$ 选择位，$D_0$ 控制输出。</p><!-- TODO Mode1，Mode2的详细操作待补充 -->]]></content>
      
      
      <categories>
          
          <category> computer organization </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>80X86微处理器</title>
      <link href="/posts/146105a1.html"/>
      <url>/posts/146105a1.html</url>
      
        <content type="html"><![CDATA[<h2 id="8086接脚介绍"><a href="#8086接脚介绍" class="headerlink" title="8086接脚介绍"></a>8086接脚介绍</h2><p>首先比较一下8086和8088芯片的接脚。8086是16位的芯片，而8088为了符合当时市场主流，虽然内部是16位的设计，但是对外的接口是8位的。<br><img src='../../figure/计算机组成笔记/80X86微处理器/8086与8088.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><p>从图中可以看出，8086的数据线有16根，从 $AD<em>0$ 到 $AD</em>{15}$，而8088只有8根。</p><p>下面具体介绍一些接脚的功能；<br><img src='../../figure/计算机组成笔记/80X86微处理器/8086接脚.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><ul><li>$AD$ 表示这些接脚既可以做地址线，也可以做数据线，接脚复用。</li><li>最左侧的 $CLK$ 表示CPU接入的时钟信号。</li><li>$\overline{WR}$ 和 $\overline{RD}$ 分别表示写和读</li><li>$M/\overline{IO}$ 表示访问memory还是I/O，这个信号说明8086采用的是isolated I/O的结构。</li><li>$INTR$ 表示中断请求，外设通过这个接脚将请求发送给CPU</li><li>$\overline{INTA}$ 是CPU对外设中断请求的回应</li><li>$NMI$ 表示不可屏蔽中断</li><li>$HOLD$ 由DMA controller送给CPU，请求总线</li><li>$HLDA$ 是CPU对DMA总线请求的回复</li><li>$READY$ 通常和CPU访问memory或者I/O相关。CPU比较快，所以当memory或者I/O处理好数据之后，会把 $READY$ 信号放到总线上，通知CPU。</li><li>$RESET$ 和计算机重启相关。在重启之后，$IP,DS,SS,ES$ 寄存器和指令队列(instruction queue)中的数据都被清零。而 $CS=FFFFH$。可以看出计算机重启之后CPU会从位于 $FFFF0H$ 的位置开始执行。</li></ul><p>图中的Latch叫做锁存器(型号74LS373)，用来暂时存储地址</p><ul><li>$ALE$ 用于控制锁存器的开关。信号有效时，锁存器能从输入端读取数据，并且发送到输出端；若信号无效，则输出端数据不变。</li><li>$\overline{BHE}$ 用于决定8086芯片的高地址对应的数据(even bank)是否有效。</li></ul><p>Data transceiver叫做数据收发器(型号74LS245)，用来控制数据的传输</p><ul><li>$DT/\overline{R}$ 用来决定CPU是写数据还是读数据。</li><li>$\overline{DEN}$ 用来决定数据收发器是否工作。如果为高点平，则不工作，两边数据断开。</li></ul><h2 id="8086地址计算"><a href="#8086地址计算" class="headerlink" title="8086地址计算"></a>8086地址计算</h2><h3 id="Physical-Address-Wrap-around"><a href="#Physical-Address-Wrap-around" class="headerlink" title="Physical Address Wrap-around"></a>Physical Address Wrap-around</h3><p>8086中地址的表示采用段加偏移的形式，同时使用该方式表示地址时会有warp-around，即如果段加偏移算出来的物理地址超过了 $FFFFFH$，那么抛掉进位，从 $00000H$ 重新开始算。比如当 $CS=FF59H$，那么代码段的范围可以到 $0F58FH$。</p><h3 id="段重叠-Segment-overlapping"><a href="#段重叠-Segment-overlapping" class="headerlink" title="段重叠(Segment overlapping)"></a>段重叠(Segment overlapping)</h3><p>一个8086程序通常有code segment，data segment，stack segment三个段，这三个段可能会有重叠。有时候会故意通过设置段值的方式让某些段重叠，从而方便数据的共享。<br><img src='../../figure/计算机组成笔记/80X86微处理器/内存中段的区域.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></p><p>同时从图中可以看出，$CS$ 和 $DS$ 通常在内存中处于比较低的位置，而 $SS$ 则存在于比较高的位置。</p><h3 id="段地址表示"><a href="#段地址表示" class="headerlink" title="段地址表示"></a>段地址表示</h3><ul><li>代码段：$CS:IP$。假如指令地址超出了当前代码段的范围，那么计算机会自行修改 $CS$ 的值。</li><li>数据段：$DS:offset$，其中偏移量可以是<ul><li>立即数，如 $23FFH$</li><li>寄存器，可以是 $BX,SI,DI$</li></ul></li><li>堆栈段：$SS:SP$。(特殊情况下会用 $BP$)<ul><li>需要注意，在push入数据之后，栈地址会逐渐变低，即 $SP$ 逐渐减小。这是为了防止和其他应用的数据冲突。</li></ul></li><li>额外段(Extra segment)：和数据段相同。</li></ul><h3 id="大端序和小端序"><a href="#大端序和小端序" class="headerlink" title="大端序和小端序"></a>大端序和小端序</h3><p>Little endian：一个字的低字节放在内存低地址(大多数处理器都采取此方式，如8086)<br>Big endian：一个字的低字节放在内存高地址</p><h2 id="CPU状态字-Flag-register"><a href="#CPU状态字-Flag-register" class="headerlink" title="CPU状态字(Flag register)"></a>CPU状态字(Flag register)</h2><p>是一个16位的寄存器，8086只是用了其中9位。<br><img src='../../figure/计算机组成笔记/80X86微处理器/CPU状态字.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><ul><li>CF(Carry Flag)：记录进位</li><li>PF(Parity Flag)：检查低8位中1的个数，假如是偶数，PF=1。(用于奇校验)</li><li>AF(Auxiliay Carry Flag)：记录BCD的进位</li><li>ZF(Zero Flag)：计算结果为0，ZF=1</li><li>SF(Sign Flag)：和计算结果的最高位相同，用于表示正负(当成二进制补码)</li><li>OF(Overflow Flag)：有符号数计算溢出</li><li>OF(Overflow Flag)：无符号数计算溢出</li><li>IF(Interrupt Flag)：IF=1时，CPU处理INTR；反之则忽略</li><li>DF(Direction Flag)：字符串处理方向相关</li><li>TF(Trap Flag)：TF=1，CPU进入调试(debug)模式</li></ul><h2 id="8086系列寻址模式"><a href="#8086系列寻址模式" class="headerlink" title="8086系列寻址模式"></a>8086系列寻址模式</h2><p>CPU如何访问操作数？以MOV指令为例</p><h3 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h3><p>数据就在寄存器中，无需访存<br>如：MOV BX,DX</p><p>除了CS和IP之外，其他寄存器的值都可以这样操作。</p><h3 id="Immediate"><a href="#Immediate" class="headerlink" title="Immediate"></a>Immediate</h3><p>直接把立即数送给寄存器，无需访存<br>如：MOV AX，2550H</p><p>但是立即数不能直接送给段寄存器。</p><h3 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h3><p>数据在Memory中，而数据的地址偏移量在指令中<br>如：MOV DL,[2400] $\quad$ MOV [3518],AL</p><p>如果不指明段寄存器，则默认是数据段寄存器DS</p><h3 id="Register-indirect"><a href="#Register-indirect" class="headerlink" title="Register indirect"></a>Register indirect</h3><p>数据在Memory中，而数据的地址偏移量在寄存器中。默认段值为DS，存储偏移地址的寄存器只能是SI，DI和BX。<br>如：MOV AL,[BX]</p><h3 id="Based-relative"><a href="#Based-relative" class="headerlink" title="Based relative"></a>Based relative</h3><p>如 MOV CX,[BX]+10</p><h3 id="Indexed-relative"><a href="#Indexed-relative" class="headerlink" title="Indexed relative"></a>Indexed relative</h3><p>和上面类似，只是这里用index寄存器<br>如 MOV DX,[SI]+5</p><h3 id="Based-indexed-relative"><a href="#Based-indexed-relative" class="headerlink" title="Based indexed relative"></a>Based indexed relative</h3><p>如 MOV CL,[BX][DI]+8</p>]]></content>
      
      
      <categories>
          
          <category> computer organization </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用ssh下载GitHub上的repo</title>
      <link href="/posts/4d4a0720.html"/>
      <url>/posts/4d4a0720.html</url>
      
        <content type="html"><![CDATA[<ol><li><p>首先在电脑上生成SSH key，可以运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>表示指定 rsa 算法生成密钥。然后会生成 id_rsa （私钥）和 id_rsa.pub （公钥）。在Linux系统中，生成的两个文件默认会放在 <code>~/.ssh</code> 文件夹下。</p></li><li><p>在GitHub上添加 SSH key</p><ol><li>打开 GitHub，点击右上角的你的头像，点击设置 settings</li><li>点击左侧的 SSH and GPG keys，点击右上角的 New SSH key</li><li>把刚刚生成的公钥 （id_rsa.pub 文件中的内容）复制到 Key 所在框， Title 不用填，复制好点击下方的 Add SSH key 按钮即可。</li><li>添加完返回 SSH 页面就会出现你的本地信息</li></ol></li><li><p>验证绑定<br>在命令行输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>假如成功，会返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi zhuxz0299! You&#x27;ve successfully authenticated, but GitHub does not provide shell access</span><br></pre></td></tr></table></figure></li></ol><p>假如出现了这种问题：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">Permissions 0664 for &#x27;/home/zhuxiaozhi/.ssh/id_rsa&#x27; are too open.</span><br><span class="line">It is required that your private key files are NOT accessible by others.</span><br><span class="line">This private key will be ignored.</span><br><span class="line">Load key &quot;/home/zhuxiaozhi/.ssh/id_rsa&quot;: bad permissions</span><br><span class="line">git@github.com: Permission denied (publickey).</span><br></pre></td></tr></table></figure><br>则说明是权限设置出了问题，使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><br>修改私钥权限即可。</p><ol><li>此时就可以通过git下载代码了。例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:aim-uofa/AdelaiDepth.git</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> git </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的一些基本操作</title>
      <link href="/posts/7ddfa635.html"/>
      <url>/posts/7ddfa635.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h2><p>可以在root权限下使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -m -s /bin/bash &lt;username&gt;</span><br></pre></td></tr></table></figure></p><ul><li><code>-m</code> 选项表示创建用户时同时创建用户的主目录。</li><li><code>-s /bin/bash</code> 选项指定用户的默认shell为bash。你也可以使用其他shell，如/bin/sh或/bin/zsh。</li><li><code>&lt;username&gt;</code> 是你希望创建的新用户的用户名。你可以选择任何合适的用户名。</li></ul><p>然后使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd &lt;username&gt;</span><br></pre></td></tr></table></figure><br>设置密码</p><p>最后如果想要将该用户假如sudo用户组，可以输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo visudo</span><br></pre></td></tr></table></figure><br>在文件中在 <code>root    ALL=(ALL:ALL) ALL</code> 的下方加上 <code>&lt;username&gt;    ALL=(ALL:ALL) ALL</code>，其中 <code>&lt;username&gt;</code> 为你希望给予sudo权限的用户名。</p><p>以上命令会使用默认编辑器。如果希望指定编辑器编辑sudoer文件，比如使用vscode，则可以：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo code /etc/sudoers</span><br></pre></td></tr></table></figure></p><h2 id="vscode免密码登录远程服务器"><a href="#vscode免密码登录远程服务器" class="headerlink" title="vscode免密码登录远程服务器"></a>vscode免密码登录远程服务器</h2><ol><li><p>首先在在本地运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>生成公钥-私钥对。文件会存储在 <code>C:\Users\ZhuXiaozhi\.ssh\</code> 文件夹下。</p></li><li><p>然后将公钥传给远端服务器，可以使用 <code>scp</code> 指令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp C:\Users\ZhuXiaozhi\.ssh\id_rsa.pub root@1.94.43.249:/root/.ssh</span><br></pre></td></tr></table></figure><p>这里将文件传给了 <code>root</code> 用户，并且存在了 <code>/root/.ssh</code> 文件夹下。</p></li><li><p>进入服务器的 <code>~/.ssh</code> 文件夹，将公钥加入 <code>authorized_keyss</code> 文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure></li><li><p>在 vscode 的远程连接配置文件中加入本地私钥路径。比如：</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络层</title>
      <link href="/posts/769365ef.html"/>
      <url>/posts/769365ef.html</url>
      
        <content type="html"><![CDATA[<h2 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h2><h3 id="网络层服务概述"><a href="#网络层服务概述" class="headerlink" title="网络层服务概述"></a>网络层服务概述</h3><p>下图中的接口层包含数据链路层和物理层。<br><img src='../../figure/计算机网络笔记/网络层/网络层服务概述.png' width=450 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="网络服务的实现"><a href="#网络服务的实现" class="headerlink" title="网络服务的实现"></a>网络服务的实现</h4><p>网络层实现的是端系统之间多跳传输。网络有很多发送端和接收端，这些都是我们的设备。而网络的核心则是众多路由器，执行转发数据包的功能。</p><h4 id="网络层关键功能"><a href="#网络层关键功能" class="headerlink" title="网络层关键功能"></a>网络层关键功能</h4><p>路由器需要实现的是从发送端到接收端找到一条路径，然后不断转发数据。</p><ul><li>路由(宏观层面)<ul><li>通过一系列路由算法和协议找到从发送端到接收端的路径</li></ul></li><li>转发(微观层面)<ul><li>将数据报从路由器的数据接口传送到正确的数据接口</li></ul></li></ul><h4 id="提供给传输层的服务"><a href="#提供给传输层的服务" class="headerlink" title="提供给传输层的服务"></a>提供给传输层的服务</h4><p>需要考虑网络通信的可靠服务是靠网络还是端系统来负责。</p><p>网络层可以向传输层提供两种服务：</p><ul><li>面向连接：虚电路</li><li>无连接：数据报</li></ul><h3 id="无连接服务的实现"><a href="#无连接服务的实现" class="headerlink" title="无连接服务的实现"></a>无连接服务的实现</h3><p>就像寄信，把信寄出去之后就不管了。<br>因此网络层向上只提供简单灵活无连接的、尽最大努力交付的数据报服务，不提供服务质量的承诺。</p><ul><li>可能会出现丢包、乱序、错误</li><li>优点：网络的造价大大降低，运行方式灵活，能够适应多种应用</li></ul><p><img src='../../figure/计算机网络笔记/网络层/无连接服务示例.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="数据报的转发策略"><a href="#数据报的转发策略" class="headerlink" title="数据报的转发策略"></a>数据报的转发策略</h4><p>数据报的转发取决于分组的目的地址。</p><p>对于每一个数据报，都会独立路由，与虚电路一定走同一条路不同。不过在实际实现中，假如路由表没有发生变化，那么数据报实际上走的还是同一条路。</p><h3 id="面向连接服务的实现"><a href="#面向连接服务的实现" class="headerlink" title="面向连接服务的实现"></a>面向连接服务的实现</h3><p>就像打电话，通信之前需要先建立连接(虚拟的或是真实的)。<br><img src='../../figure/计算机网络笔记/网络层/面向连接服务示例.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>同时需要注意，面向连接的服务也无法保证数据一定可靠，链路中如果有路由器出现问题，那么可能会导致数据丢失等严重问题。</p><h4 id="虚电路的转发策略"><a href="#虚电路的转发策略" class="headerlink" title="虚电路的转发策略"></a>虚电路的转发策略</h4><p>在虚电路传输之前需要先建立好链路，然后就一直在这个链路上传输。建立好链路之后，发送的数据中就无需包含源地址和目的地址，而是只需要包含一个标签，所有路由器看到这个标签之后就知道把这个数据向哪里传输。</p><!-- 比如下图中，当R4接收到数据，发现标签为L1，就知道应该从3号端口数据，标签改为L2 --><p><img src='../../figure/计算机网络笔记/网络层/虚电路的转发策略.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="虚电路与数据报网络的比较"><a href="#虚电路与数据报网络的比较" class="headerlink" title="虚电路与数据报网络的比较"></a>虚电路与数据报网络的比较</h3><p><img src='../../figure/计算机网络笔记/网络层/虚电路与数据报网络比较.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><h2 id="Internet网际协议"><a href="#Internet网际协议" class="headerlink" title="Internet网际协议"></a>Internet网际协议</h2><h3 id="IPv4协议"><a href="#IPv4协议" class="headerlink" title="IPv4协议"></a>IPv4协议</h3><p>IPv4协议，网际协议版本4，一种无连接的协议，是互联网的核心，也是使用最广泛的网际协议版本，其后继版本为IPv6</p><p>Internet协议执行两个基本功能</p><ul><li>寻址(addressing)</li><li>分片(fragmentation)</li></ul><h4 id="IPv4数据报格式"><a href="#IPv4数据报格式" class="headerlink" title="IPv4数据报格式"></a>IPv4数据报格式</h4><p><img src='../../figure/计算机网络笔记/网络层/ipv4数据报格式.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"><br><br></p><ul><li>版本： 4bit ，表示采用的IP协议版本。</li><li>首部长度： 4bit，表示整个IP数据报首部的长度。(因为IP数据报首部长度可变，主要是选项部分，所以设置了这一位。同时此处“长度”的单位为32bit)</li><li>区分服务： 8bit ，该字段一般情况下不使用。(为了让当前应用的特性改变服务，虽然这个构想很好，但是事实上每个用户都希望自己获得最好的服务，所以该服务并不被使用)</li><li>总长度： 16bit ，表示整个IP报文的长度,能表示的最大字节为2^16-1=65535字节</li><li>标识： 16bit ， IP软件通过计数器自动产生，每产生1个数据报计数器加1；在ip分片以后，用来标识同一片分片</li><li>标志： 3bit，目前只有两位有意义； MF，置1表示后面还有分片，置0表示这是数据报片的最后1个；DF，不能分片标志，置0时表示允许分片</li><li>片偏移： 13bit，表示IP分片后，相应的IP片在总的IP片的相对位置</li><li>生存时间TTL(Time To Live) ：8bit,表示数据报在网络中的生命周期，用通过路由器的数量来计量，即跳数(每经过一个路由器会减1)。TTL的引入是为了防止某些数据报无法到达目的地，在网络中不断转发，浪费带宽。</li><li>协议：8bit，标识上层协议（TCP/UDP/ICMP…）</li><li>首部校验和：16bit ，对数据报首部进行校验，不包括数据部分</li><li>源地址：32bit，标识IP片的发送源IP地址</li><li>目的地址：32bit，标识IP片的目的地IP地址</li><li>选项：可扩充部分，具有可变长度，定义了安全性、严格源路由、松散源路由、记录路由、时间戳等选项</li><li>填充：用全0的填充字段补齐为4字节的整数倍</li></ul><h4 id="数据报分片"><a href="#数据报分片" class="headerlink" title="数据报分片"></a>数据报分片</h4><p>MTU（Maximum Transmission Unit），最大传输单元，可以理解为两个站点之间最大带宽。</p><ul><li>MTU分类<ul><li>MTU分为链路MTU和路径MTU，分别代表两个站点之间的最大传输带宽和两个端点之间的带宽。</li></ul></li><li>数据报分片策略<ul><li>允许途中分片：根据下一跳链路的MTU实施分片</li><li>不允许途中分片：发出的数据报长度小于路径MTU（路径MTU发现机制）</li></ul></li></ul><p>假如一条链路中MTU不同，并且允许途中分片，那么就需要进行分片操作。</p><p>以下图传输情况为例：<br><img src='../../figure/计算机网络笔记/网络层/MTU与分片.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>从R1到R2的MTU小于从Tx到R1的MTU，因此在路由器R1上执行分片。数据报格式中与分片相关的有：标识、标志和片偏移。</p><ul><li>数据报在分段前后标识不变，以便于到达目的地之后重组。</li><li>数据报标志有DF和MF。<ul><li>DF=0表示能分片，DF=1表示不能分片。分片前后DF不变</li><li>在分片前，MF=0。在分片后，假如该数据报片后面还有其他数据报片，则MF=1；若没有，MF=0</li></ul></li><li>片偏移的值则由数据部分第一个字节的地址除 $8$ 得到。</li></ul><p>第一次分片情况如下图所示：<br><img src='../../figure/计算机网络笔记/网络层/数据报分片.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>然后再考虑从R2传输到R3。由于MTU进一步减小，所以之前得到的数据报片还需要进一步分片。<br>比如对数据报片1继续分片，那么我们得到长度为 $1000$ 和 $400$ 的两个更小的的分片。</p><ul><li>对于长度为 $1000$ 的分片，DF=0，MF=1，偏移=$0/8$</li><li>对于长度为 $400$ 的分片，DF=0，MF=1，偏移=$1000/8$</li></ul><p>最后从R3传到目的地Rx。R3继续转发这些分片，而不会进行整合。直到Rx分片才会重新整合。这是因为数据报独立路由，所以有些数据报走的可能不是同一条路。</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul><li>IP地址，网络上的每一台主机（或路由器）的每一个接口都会分配一个全球唯一的32位的标识符</li><li>将IP地址划分为固定的类，每一类都由两个字段组成</li><li>网络号相同的这块连续IP地址空间称为地址的前缀，或网络前缀<br><img src='../../figure/计算机网络笔记/网络层/网络前缀.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></li></ul><h4 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h4><ul><li>IP地址共分为A、B、C、D、E五类，A类、B类、C类为单播地址。其中D类和E类做特殊用途，这里不介绍。</li><li>IP地址依靠前几个bit进行分类。</li><li>IP地址的书写采用点分十进制记法，其中每一段取值范围为0到255</li></ul><p><img src='../../figure/计算机网络笔记/网络层/IP地址分类.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>从图中可以看出，A类网络中可以有非常多的主机，所以这类地址通常分给国家。我们最常用的是C类地址，网络中的主机号的数量只有 $2^{8}-2$(有两个是特殊IP地址)。</p><h4 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h4><p><img src='../../figure/计算机网络笔记/网络层/特殊IP地址.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>我们注意到如果只是按A、B、C类地址进行划分，弹性会很小。比如一个小公司只有几台电脑，但是分到了C类网络，这就会导致很多主机号的浪费。这是两级IP地址带来的缺陷，因此引入了子网划分。</p><ul><li><strong>子网划分</strong>(subnetting)，在网络内部将一个网络块进行划分以供多个内部网络使用，对外仍是一个网络</li><li><strong>子网</strong>(subnet )，一个网络进行子网划分后得到的一系列结果网络称为子网</li><li><strong>子网掩码</strong>(subnet mask )，与 IP 地址一一对应，是32 bit 的二进制数，置1表示网络位，置0表示主机位。子网掩码用于判断子网号的长度。</li><li>子网网络地址也有更加简单的表示方式，比如下图中的的子网掩码，可以记为 IP/24，其中 $24$ 表示子网掩码的 $1$ 共有 $24$ 位。</li></ul><p><img src='../../figure/计算机网络笔记/网络层/子网划分.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="无类域间路由-CIDR"><a href="#无类域间路由-CIDR" class="headerlink" title="无类域间路由(CIDR)"></a>无类域间路由(CIDR)</h4><ul><li>将32位的IP地址划分为前后两个部分，并采用斜线记法，即在IP地址后加上“/”，然后再写上网络前缀所占位数(就是上面讲的记法)，这个成为一个CIDR(Classless Inter-Domain Routing)。</li><li>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合（route aggregation），也称为构成超网 (supernet)</li></ul><h4 id="最长前缀匹配（Longest-prefix-match）"><a href="#最长前缀匹配（Longest-prefix-match）" class="headerlink" title="最长前缀匹配（Longest prefix match）"></a>最长前缀匹配（Longest prefix match）</h4><p>(注意这里的IP地址为子网的IP地址，每个端口对应一个网络网)</p><ul><li>IP地址与IP前缀匹配时，总是选取子网掩码最长的匹配项</li><li>主要用于路由器转发表项的匹配，也应用于ACL规则匹配等</li></ul><p>比如下面这张路由转发表：<br><img src='../../figure/计算机网络笔记/网络层/最长前缀匹配的路由转发表.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><p>从这张表中我们可以得出，</p><ul><li>IP地址为：200.23.22.161 （ 11001000 00010111 00010110 10100001 ）时，接口为0</li><li>IP地址为：200.23.24.170 （ 11001000 00010111 00011000 10101010 ）时，接口为 1</li></ul><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><h4 id="Ipv4地址如何获取"><a href="#Ipv4地址如何获取" class="headerlink" title="Ipv4地址如何获取"></a>Ipv4地址如何获取</h4><ul><li>公有IP地址要求全球唯一<ul><li>ICANN（Internet Corporation for Assigned Names and Numbers）即互联网名字与编号分配机构向ISP分配，ISP再向所属机构或组织逐级分配</li></ul></li><li>静态设定(传统的申请方式，比较麻烦)<ul><li>申请固定IP地址，手工设定，如路由器、服务器</li></ul></li><li>动态获取<ul><li>使用DHCP协议或其他动态配置协议，当主机加入IP网络，允许主机从DHCP服务器动态获取IP地址。这样可以有效利用IP地址，方便移动主机的地址获取。</li></ul></li></ul><h4 id="DHCP动态主机配置协议"><a href="#DHCP动态主机配置协议" class="headerlink" title="DHCP动态主机配置协议"></a>DHCP动态主机配置协议</h4><ul><li>工作模式：客户/服务器模式（ C/S ）<ul><li>基于 UDP 工作，服务器运行在 67 号端口， 客户端运行在 68 号端口</li></ul></li></ul><p><img src='../../figure/计算机网络笔记/网络层/DHCP协议.png ' width=550 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="DHCP工作流程"><a href="#DHCP工作流程" class="headerlink" title="DHCP工作流程"></a>DHCP工作流程</h4><ol><li>首先用户端并不知道DHCP服务器在哪，只知道DHCP工作在 67 号端口，因此会先广播。此时源IP地址为全零(还未分配到IP地址)，端口号为 68；目标IP地址为全一(广播)，端口号为 67；想要的IP地址为全零(还不知道哪些IP可用)；然后会有一个ID用于标识。</li><li>DHCP收到之后会发送一个offer，告诉用户端能提供的IP地址。同时因为不知道用户端的IP，所以同样需要广播。除此之外DHCP服务器还会指定租借IP的期限，即图中的lifetime，但同时一个客户机可以在租借期间续借IP地址。</li><li>由于网络中可能存在很多DHCP服务器，因此用户机可能会收到很多offer，此时它会从中选择一个，再发送request。request中会指明自己选择的那个IP地址，同时同样采用广播机制，这是为了告诉所有的服务器自己选择的是哪个offer。</li><li>最后DHCP服务器发送确认信号，用户端成功获得IP地址。</li></ol><p><img src='../../figure/计算机网络笔记/网络层/DHCP工作流程.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="IP与MAC地址"><a href="#IP与MAC地址" class="headerlink" title="IP与MAC地址"></a>IP与MAC地址</h3><p>路由器的每个端口和主机一样，都有一个IP地址和MAC地址。<br><img src='../../figure/计算机网络笔记/网络层/IP与MAC地址.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>在这里，假如IP$<em>{1}$想和IP$</em>{3}$通信，首先可以通过网络号和子网号相同这一点得到这两台主机在同一个局域网中，所以就可以利用局域网通信。</p><p>假如IP$<em>{1}$想和IP$</em>{2}$通信，IP数据报需要经过路由器的转发。同时需要注意，在网络层，IP数据报无论怎么转发，IP源地址和目的地址都是一样的；但是在数据链路层，在不同的局域网中，MAC帧中的源地址和目的地址是会不断改变的。(数据链路层是点对点的通信)</p><p><img src='../../figure/计算机网络笔记/网络层/网络层通信数据流向.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="为什么同时需要MAC地址和IP地址"><a href="#为什么同时需要MAC地址和IP地址" class="headerlink" title="为什么同时需要MAC地址和IP地址"></a>为什么同时需要MAC地址和IP地址</h4><ul><li>假如只有MAC，没有IP<ul><li>难以进行路由寻址</li></ul></li><li>只有IP，没有MAC<ul><li>理论可行，但是这样的话每次都需要解析网络层才能进行转发。</li></ul></li></ul><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><h4 id="ARP地址解析协议"><a href="#ARP地址解析协议" class="headerlink" title="ARP地址解析协议"></a>ARP地址解析协议</h4><p>我们注意到，数据在进行发送时，会先确定网络层的IP的源地址和目的地址。但是在局域网中信息是以MAC帧进行发送，于是带来了一个问题：我们如何得到MAC源地址和目的地址？</p><p>比如对于如下情形：<br>IP数据包转发：从主机A到主机B<br>• 检查目的IP地址的网络号部分<br>• 确定主机B与主机A属相同IP网络<br>• 将IP数据包封装到链路层帧中，直接发送给主机B<br>那么怎么获得B的MAC地址？<br><img src='../../figure/计算机网络笔记/网络层/ARP地址解析协议.png' width=250 style="display: block; margin-left: auto; margin-right: auto;"></p><p>ARP地址解析采用的是查表的方式，每个主机中都存有IP到MAC的转换表。</p><h4 id="ARP协议工作过程"><a href="#ARP协议工作过程" class="headerlink" title="ARP协议工作过程"></a>ARP协议工作过程</h4><p>以下图为例，A已知B的IP地址，需要获得B的MAC地址（物理地址）</p><ul><li>如果A的ARP表中缓存有B的IP地址与MAC地址的映射关系，则直接从ARP表获取</li><li>如果A的ARP表中未缓存有B的IP地址与MAC地址的映射关系，则A广播包含B的IP地址的ARP query分组，在局域网上的所有节点都可以接收到ARP query<ul><li>B接收到ARP query分组后，将自己的MAC地址发送给A(单播)</li><li>A在ARP表中缓存B的IP地址和MAC地址的映射关系</li><li>超时时删除</li></ul></li></ul><p><img src='../../figure/计算机网络笔记/网络层/ARP协议工作过程.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"><br><br><br><img src='../../figure/计算机网络笔记/网络层/ARP协议工作过程-响应.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="路由到另一个局域网"><a href="#路由到另一个局域网" class="headerlink" title="路由到另一个局域网"></a>路由到另一个局域网</h4><p>刚刚讲的是发送方和接收方在同一个局域网中的情况，这里考虑不同局域网。</p><p>比如说下图中需要实现A到E的通信。<br><img src='../../figure/计算机网络笔记/网络层/路由到另一个局域网.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><ol><li>A创建IP数据包(源地址为A，目的地址为E)</li><li>此时主机A应当首先得到的是R的MAC地址。同时每台主机都有路由表，这个路由表只有一个端口，指明了数据包往哪发(其实是DHCP时获得的路由器的IP地址)。因此A就可以使用ARP协议获得R的MAC地址。</li><li>A创建数据帧(源地址为A，目的地址为R)，其中数据帧中封装了A到E的IP数据包。</li><li>A发送数据帧，R接收。</li></ol><h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3><p>NAT的引入是为了解决IPv4地址不够用的问题，是一种将私有地址转为共有IP地址的技术。</p><p>私有IP地址：</p><ul><li>A类地址：10.0.0.0—10.255.255.255</li><li>B类地址：172.16.0.0—172.31.255.555</li><li>C类地址：192.168.0.0—192.168.255.255<h4 id="NAT工作机制"><a href="#NAT工作机制" class="headerlink" title="NAT工作机制"></a>NAT工作机制</h4>左侧为公有IP地址，右侧为私有IP地址。<br><img src='../../figure/计算机网络笔记/网络层/NAT工作机制.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></li></ul><p>需要注意，如果直接这样使用，那么只有内网的数据能够发送到外网，而外网数据无法发送给内网(因为外网的计算机不知道内网计算机的IP地址)。<br>为了解决这个问题，边界路由器需要解决内网和外网IP变换的工作，此时需要借助端口号来实现。</p><p>比如电脑10.0.0.1的3345端口想要从服务器128.119.40.186的80端口请求数据</p><ol><li>内网的10.0.0.1,3345首先会通过NAT路由器的NAT转换表转成138.76.29.7,5001</li><li>成功将请求发送到服务器并且得到回复，服务器发送的数据包的目的地址为138.76.29.7,5001</li><li>NAT路由器收到信息之后，解析目的地址，通过NAT转换表将目的地址转为10.0.0.1,3345</li><li>计算机成功接收到数据</li></ol><p><img src='../../figure/计算机网络笔记/网络层/NAT地址转换表.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h4><p>传输层TCP/UDP拥有16-bit 端口号字段，所以一个WAN侧地址可支持60,000个并行连接</p><ul><li>NAT的优势：<ul><li>节省IP地址</li><li>保护局域网的私密性(防火墙就是使用NAT实现的)</li></ul></li><li>问题或缺点<ul><li>违反了IP的结构模型，路由器处理传输层协议。违反了协议分层规则</li><li>违反了端到端的原则(中间需要使用NAT路由器修改IP地址和端口号)</li><li>新型网络应用的设计者必须要考虑 NAT场景，如 P2P应用程序(如果两个设备都在内网中，会不太好处理)</li></ul></li></ul><h3 id="ICMP-互联网控制报文协议"><a href="#ICMP-互联网控制报文协议" class="headerlink" title="ICMP:互联网控制报文协议"></a>ICMP:互联网控制报文协议</h3><p>ICMP是网络层协议，但是是建立在IPv4或者IPv6之上的。假如在数据传输中出现问题，路由器会通过ICMP进行回报。<br><img src='../../figure/计算机网络笔记/网络层/ICMP报文格式.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><h3 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h3><ul><li><strong>汇集树</strong>(Sink Tree)：所有的源节点到一个指定目标节点的最优路径的集合构成一棵以目标节点为根的树。<ul><li>这是因为在最优路径A上的任意两点，这两点之间的最优路径B一定在A上<br><img src='../../figure/计算机网络笔记/网络层/汇集树.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></li></ul></li></ul><p>上图中右边的树就是左边的图的汇集树。</p><h3 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h3><p>可以用Dijstra算法实现。不过这种算法只能处理静态的情形。</p><p>Dijkstra算法的基本步骤：</p><ul><li>初始化：将源节点的距离设置为0，将其他节点的距离设置为无穷大（或一个很大的数），将源节点标记为当前节点。</li><li>迭代过程：重复以下步骤，直到所有节点都被标记为已访问。<ul><li>从当前节点开始，计算当前节点到其邻居节点的距离和，更新邻居节点的距离（如果计算得到的距离比当前保存的距离更短）。</li><li>选择未访问节点中距离最小的节点作为下一个当前节点。</li><li>将该节点标记为已访问。</li></ul></li><li>最短路径生成：通过回溯，根据计算得到的最短路径信息，生成从源节点到其他节点的最短路径。<h3 id="距离向量路由-Distance-Vector-DS"><a href="#距离向量路由-Distance-Vector-DS" class="headerlink" title="距离向量路由(Distance Vector, DS)"></a>距离向量路由(Distance Vector, DS)</h3><h4 id="距离向量路由算法"><a href="#距离向量路由算法" class="headerlink" title="距离向量路由算法"></a>距离向量路由算法</h4></li><li>Bellman-Ford 方程<ul><li>假设 $D_{x}(y)$ 是 从 $x$ 到 $y$ 最小代价路径的代价值</li><li>则：$D<em>{x}(y) = \min {c(x,m) + D</em>{m}(y) }$。其中 $m$ 为 $x$ 的邻居, $c(x,m)$ 为 $m$ 到 $x$ 的距离。</li></ul></li></ul><p>在经过多次迭代之后，就能得到所有点两两之间的最短距离。</p><ul><li><strong>距离向量</strong>（Distance Vector）算法和BF算法基本相同:<ul><li>每个节点周期性地向邻居发送它自己到某些节点的距离向量；</li><li>当节点x接收到来自邻居的新DV估计，它使用B-F方程更新其自己的DV :<script type="math/tex; mode=display">D_{x}(y) \leftarrow \min_{v}\left\{ c(x,y)+D_v(y) \right\} \quad for\ each\ node\ y\in N</script></li><li>上述过程迭代执行，$D<em>{x}(y)$ 收敛为实际最小费用 $d</em>{x}(y)$</li></ul></li></ul><h4 id="路由器实现"><a href="#路由器实现" class="headerlink" title="路由器实现"></a>路由器实现</h4><ol><li><p>路由器启动时初始化自己的路由表。初始路由表包含所有直接相连的网络路径，距离均为0<br><img src='../../figure/计算机网络笔记/网络层/距离向量路由-路由表初始化.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p></li><li><p>路由器<em>周期性</em>地向其相邻路由器广播自己知道的路由信息，相邻路由器可以根据收到的路由信息修改和刷新自己的路由表(因为会周期性的更新信息，所以该算法是动态的)<br><img src='../../figure/计算机网络笔记/网络层/距离向量路由-广播信息.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p></li><li><p>经过若干次更新后，算法收敛，路由器最终都会知道到达所有网络的最短距离<br><img src='../../figure/计算机网络笔记/网络层/距离向量路由-收敛状态.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p></li></ol><h4 id="计数到无穷问题"><a href="#计数到无穷问题" class="headerlink" title="计数到无穷问题"></a>计数到无穷问题</h4><p>考虑如下情况：<br><img src='../../figure/计算机网络笔记/网络层/计数到无穷问题.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><p>在出了故障之后，假如是 $R_2$ 先把自己的路由表给 $R_1$，那么会导致 $R_1$ 更新自己的路由表，让自己到网络 net1 的距离变成 $2$。然后路由表在 $R_1$ 和 $R_2$ 之间不断传播，到 net1 的距离有不断更新，最终依然会收敛到 $16$，但是这会耗费非常多的时间。</p><h3 id="链路状态路由-Link-State-LS"><a href="#链路状态路由-Link-State-LS" class="headerlink" title="链路状态路由(Link State, LS)"></a>链路状态路由(Link State, LS)</h3><p>链路状态(Link State)路由解决Dij无法处理动态情况的方式是：当网络拓扑发生改变之后，就把这个改变的拓扑信息更新给网络中所有的路由器，那么Dij就是可用的。</p><ol><li><p>发现邻居，了解他们的网络地址；<br><img src='../../figure/计算机网络笔记/网络层/链路状态路由-发现邻居.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p></li><li><p>设置到每个邻居的成本度量(比如说带宽、延迟之类的信息)</p></li><li>构造一个分组(链路状态分组，link state packet, LSP)，分组中包含刚收到的所有信息：发送方标识、序列号、年龄、邻居列表。<br><img src='../../figure/计算机网络笔记/网络层/链路状态路由-链路状态分组.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></li><li>将此分组发送给其他的路由器；</li><li>计算到其他路由器的最短路径(采用的是Dij算法)</li></ol><h4 id="距离向量和链路状态算法比较："><a href="#距离向量和链路状态算法比较：" class="headerlink" title="距离向量和链路状态算法比较："></a>距离向量和链路状态算法比较：</h4><ul><li>网络状态信息交换的范围<ul><li>DV:邻居间交换</li><li>LS:全网扩散</li></ul></li><li>网络状态信息的可靠性<ul><li>DV:部分道听途说</li><li>LS:自己测量</li></ul></li><li>健壮性:<ul><li>DV:计算结果传递，健壮性差</li><li>LS: 各自计算，健壮性好</li></ul></li><li>收敛速度：<ul><li>DV: 慢,可能有计数到无穷问题</li><li>LS: 快</li></ul></li></ul><h3 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h3><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p>世界上的电脑和路由器非常多，</p><ul><li>如果仅仅是按照上述比如Link State的方式，由于更新了拓扑结果之后要进行全网扩散，工作量非常大</li><li>如果按照Distance Vector的方式，那么路由表会非常大<br><img src='../../figure/计算机网络笔记/网络层/层次路由-产生原因.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></li></ul><p>比如上图所示的网络，当接入的主机数量越来越多，那么 $R_1$ 的路由表也会越来越大。因此我们思考通过聚合的方式来减小路由表的规模。比如图中可以将 $PC_1-PC_2$ 聚合到一起，对应 $R_2$；将 $PC_5-PC_6$ 聚合到一起，对应 $R_4$；剩下的地址对应 $R_3$。</p><p>但现实情况是：</p><ul><li>地址分配往往是随机的，难以进行高效的地址聚合</li><li>每个网络的网络管理员有自己的管理方法和思路，并不希望每个路由器都干涉本网络内部的地址分配等问题</li></ul><p>因此需要使用层次路由</p><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>层次路由就是将网络分为多个阶层，最高层成为<strong>自治系统</strong>(AS, Autonomous System)。每个AS有一个全球唯一的ID号：AS ID。</p><p>譬如如图所示的网路，我们可以根据其所属的单位对其进行分隔。每个单位形成一个自治系统，在自治系统下的路由器由每一个单位自己做管理。<br><img src='../../figure/计算机网络笔记/网络层/层次路由-基本思路.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><ul><li>自治系统内部使用内部网关路由协议，Interior Gateway Protocols (IGP)<ul><li>典型IGP协议：OSPF，RIP，IS-IS，IGRP，EIGRP…(主要基于DV和LS)</li></ul></li><li>自治系统之间之间使用外部网关路由协议，Exterior Gateway Protocols(EGP)<ul><li>典型EGP协议：BGP</li></ul></li></ul><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src='../../figure/计算机网络笔记/网络层/层次路由-效果.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="广播路由"><a href="#广播路由" class="headerlink" title="广播路由"></a>广播路由</h3><p>之前考虑的路由方式主要是一对一的路由方式，这里考虑广播，即数据发送方想将数据发送给某一网络中的所有电脑。</p><ul><li>方法1：给每个主机单独发送一个数据包<ul><li>效率低、浪费带宽</li><li>Server需要知道每个目的地址</li></ul></li><li>方法2：多目标路由（multi-destination routing）<ul><li>在需要转发的路由器线路复制一次该数据报</li><li>优点：网络利用率高</li><li>缺点：Server依然需要知道所有的目的地址，难以实现<div style="text-align: center;"><img src='../../figure/计算机网络笔记/网络层/广播路由-单独发送.png' height=200 style="display: inline-block; margin-right: 10px;"><img src='../../figure/计算机网络笔记/网络层/广播路由-多目标路由.png' height=200 style="display: inline-block; margin-right: 10px;"></div></li></ul></li></ul><ul><li>方法3：泛洪（flooding）<ul><li>将每个进入数据包发送到除了进入线路外的每条出去线路</li><li>优点：<ul><li>保证性：一种有效广播手段，可确保数据包被传送到网络中每个节点</li><li>鲁棒性：即使大量路由器被损坏，也能找到一条路径（如果存在）</li><li>简单性：仅需知道自己的邻居</li></ul></li><li>缺点：网络中存在环路的话可能会对导致广播风暴。</li></ul></li></ul><p>解决方法：生成树。和交换机泛洪的处理方式一样。</p><h3 id="组播路由"><a href="#组播路由" class="headerlink" title="组播路由"></a>组播路由</h3><p><strong>组播</strong>（multicasting）：源主机给网络中的一部分目标用户发送数据包。又称为多播。多用于网络会议，或者服务器希望将体育直播视频发送给某些网络中的个别用户。</p><h4 id="源点树"><a href="#源点树" class="headerlink" title="源点树"></a>源点树</h4><p>组播路由的方式和广播路由非常像，同样是建立<strong>源点树</strong>(生成树)，只是叶节点仅仅是特定的一些用户。<br>基于源点树（source-based trees）存在的问题：大型网络中，组播源很多时，路由器需生成多颗棵树，工作量巨大，路由器需要大量空间来存储多颗树(对于每个生成树，每个路由器都需要储存父节点和子节点)</p><h4 id="核心树"><a href="#核心树" class="headerlink" title="核心树"></a>核心树</h4><p>另一种方法是使用<strong>核心树</strong>。即所有的组播源先将信息传到一个核心节点上，再由这个节点进行组播，这样多个组播源就能共享同一棵生成树。但是这种方法会导致核心节点的压力非常大，同时也可能导致更长的路径。<br><img src='../../figure/计算机网络笔记/网络层/组播路由-核心树.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>比如在上图中，从Server2到 $R_3$ 本应该可以直接到达，但是使用了核心树之后就需要先将数据送到 $R_1$ 核心。</p><h4 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h4><p>由于早期的路由器很多并不支持组播，那么可能会导致一个问题：假设主机和服务器都是支持组播的，但是在传输过程中有部分路由器不支持。为了让组播协议在网络中正常运行，可以使用<strong>隧道</strong>。</p><p>隧道实现的是对组播数据包的封装，变成一个普通的数据报。<br><img src='../../figure/计算机网络笔记/网络层/组播路由-隧道.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="选播路由-Anycast"><a href="#选播路由-Anycast" class="headerlink" title="选播路由(Anycast)"></a>选播路由(Anycast)</h3><p>有点类似于报警，会选择最近的一个警察局。</p><p>选播的应用场景为DNS，即将域名转为ip地址。在寻找DNS服务器的过程中，就会寻找最近的DNS服务器。比如平时使用8.8.8.8这个ip地址寻找DNS服务器，而有这个ip地址的服务器非常多，那么就需要让路由器找到最近的一个。</p><h2 id="Internet路由协议"><a href="#Internet路由协议" class="headerlink" title="Internet路由协议"></a>Internet路由协议</h2><p>常见的路由协议包括：</p><ol><li>OPSF-内部网关路由协议。(和Link State基本相同)</li><li>RIP-内部网关路由协议。(和Distance Vector基本相同)</li><li>BGP-外部网关路由协议</li><li>标签交换和MPLS。(就是希望在数据报网络中能够实现虚电路网络)<h3 id="BGP-外部网关路由协议"><a href="#BGP-外部网关路由协议" class="headerlink" title="BGP-外部网关路由协议"></a>BGP-外部网关路由协议</h3>BGP是目前互联网中唯一实际运行的自治域间的路由协议。</li></ol><ul><li>自治系统内部的路由：效率</li><li>自治系统之间的路由：安全<ul><li>自治系统之间通信可能会通过其他自治系统，那么处于安全或者费用的考虑，选择方式会有所不同。</li><li>因此BGP会把所有可行的数据告诉用户，用户决定使用哪个</li></ul></li></ul><h4 id="eBGP-amp-iBGP连接"><a href="#eBGP-amp-iBGP连接" class="headerlink" title="eBGP&amp;iBGP连接"></a>eBGP&amp;iBGP连接</h4><ul><li>BGP功能<ul><li>eBGP：从相邻的AS获得网络可达信息</li><li>iBGP： 将网络可达信息传播给AS内的路由器</li></ul></li></ul><p>下图中红色线表示eBGP，黑色线表示iBGP。我们更关注eBGP。<br><img src='../../figure/计算机网络笔记/网络层/BGP路径通告.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="BGP路径通告"><a href="#BGP路径通告" class="headerlink" title="BGP路径通告"></a>BGP路径通告</h4><p>考虑一种情况，比如AS1要实现和AS3中X的通信。</p><ol><li>那么当AS3的路由器3a向AS2的路由器2c通告路径AS3, X时AS3向AS2承诺它会向X转发数据包。</li><li>AS2的路由器2c从AS3的路由器3a接收到路径AS3, X</li><li>根据AS2的策略，AS2的路由器2c接受路径AS3, X，通过iBGP传播给AS2的所有路由器</li><li>根据AS2策略，AS2的路由器2a通过eBGP向AS1的路由器1c通告从AS3的路由器3a接收到路径AS2, AS3, X</li></ol><p>从这里可以看出BGP协议和前面的协议很不相同。IGP的算法中我们只关心下一个路由器是谁，而BGP则需要知道整条路径。同时路由器可能会学到多条到目的网络的路径:</p><ol><li>AS1的路由器1c从2a学到路径AS2, AS3, X</li><li>AS1的路由器1c从3a学到路径AS3, X</li><li>由策略，AS1路由器1c可能选择路径AS3, X, 并在AS1中通过iBGP通告路径</li></ol><h2 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h2><p>流量控制和拥塞控制区别：</p><ul><li>流量控制：解决接收方的接收能力不如发送方的发送能力的问题。(数据链路层和传输层)</li><li>拥塞控制：解决网络来不及处理发送方发送的数据的问题。(网络层)</li></ul><p>理论上拥塞控制应该在网络层实现，因为拥塞就是在网络层发生的。但是由于早期计算机网络发展时，希望路由器能够实现的比较简单，因此拥塞控制的实现实际上交给了传输层。但是这样做会导致分层模型受到破坏。理论上传输层对于拥塞的感知有限，对于传输层而言，只知道<strong>时延</strong>、<strong>丢包</strong>两个问题。</p><h3 id="拥塞控制概述"><a href="#拥塞控制概述" class="headerlink" title="拥塞控制概述"></a>拥塞控制概述</h3><ul><li><strong>拥塞</strong>：网络中存在太多的数据包导致数据包传输延迟或丢失，从而导致网络吞吐量下降</li><li><strong>拥塞控制</strong>（congestion control）：需要确保通信子网能够承载用户提交的通信量，是一个全局性问题，涉及主机、路由器等多种因素</li></ul><p><img src='../../figure/计算机网络笔记/网络层/拥塞问题.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>网络发生拥塞导致吞吐量急剧下降，是因为拥塞会导致数据包的丢弃，被丢弃有导致重传，继续增加了网络负担，导致更严重的拥塞。在这种正反馈的影响下，网络会崩溃。</p><h4 id="拥塞控制的途径"><a href="#拥塞控制的途径" class="headerlink" title="拥塞控制的途径"></a>拥塞控制的途径</h4><p>• 提高网络供给。(但是要考虑到Braess Paradox，就像道路数量增加，民众对车的需求量也会增加，甚至大于修路的速度，最终导致路更堵。考虑到网络系统中也有很多用户，那么也可能导致这种现象。)<br>• 流量感知路由。(通过路由方式解决拥塞。类似于导航告诉用户哪条路不赌)<br>• 准入控制<br>• 流量调节<br>• 负载丢弃</p><h3 id="流量调节"><a href="#流量调节" class="headerlink" title="流量调节"></a>流量调节</h3><p>考虑A发送数据给B，流程为 $A \rightarrow R_1 \rightarrow R_2\rightarrow R_3 \rightarrow R_4 \rightarrow B$，在R3处发生拥塞。</p><ul><li><strong>显式拥塞通告</strong>（ECN，Explicit Congestion Notification），在IP包头中记录数据包是否经历了拥塞。R3会在IP包上标记，B接收到数据后会告诉A发生拥塞<ul><li>路由器工作量最小</li><li>在网络层真正有实现的方法</li></ul></li><li><strong>抑制包</strong>(Choke Packets)：R3直接发送信息给A，告诉这里发生拥塞</li><li><strong>逐跳的抑制包</strong>(Hop-by-Hop Choke Packets)：R3先告诉R2发生拥塞，请减慢发送速度。然后R2再向R1发送信息，最终逐跳传回A。</li></ul><p>以上三种方式都是显式的控制。  </p><h3 id="负载丢弃——随机早期检测RED-Random-Early-Detection"><a href="#负载丢弃——随机早期检测RED-Random-Early-Detection" class="headerlink" title="负载丢弃——随机早期检测RED (Random Early Detection)"></a>负载丢弃——随机早期检测RED (Random Early Detection)</h3><p>负载丢弃属于隐式的反馈，当发生拥塞是会发生丢包，当发送方发现没有受到确认信号，就会认为发生了拥塞，从而降低发送速度。而随机早期检测就是决定如何进行丢弃的算法。</p><p>回忆路由器的转发流程，路由器在受到数据之后会决定将数据从某个端口转发出去，而在发送前数据会先存在那个端口的buffer中，随即早期检测算法就是对这个buffer进行操作。<br><img src='../../figure/计算机网络笔记/网络层/随机早期检测.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><ul><li>当数据非常少的时候，buffer基本是空的，一有数据进来就能转发出去</li><li>发生拥塞时，数据来不及被转发，会堆积在buffer中，随机早期检测算法就会对buffer中过多的数据进行丢弃。</li></ul><p>随机早期检测丢弃的概率如下图所示：<br><img src='../../figure/计算机网络笔记/网络层/随机早期检测分组丢弃概率.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><ul><li>中间一段设置丢弃概率的原因：假如网络真的发生拥塞，那么会导致直接的崩溃。因此早期的小概率丢弃就是希望让发送端知道此时网络已经出现了一定的压力，应当降低返送端的发送速度。</li><li>进行随机丢弃的原因是：在发生拥塞时，我们更希望让发送数据最多的一方减慢发送数据的速率，而发送数据多就意味着被随机丢弃的概率就更大，那么就有更大的概率知道可能会发生的拥塞，从而放慢数据发送。</li></ul><h2 id="服务质量"><a href="#服务质量" class="headerlink" title="服务质量"></a>服务质量</h2><p>因为互联网本身只能提供“尽力而为的服务”，所以需要考虑网络服务的质量。</p><h3 id="什么是网络服务质量？（QoS-Quality-of-Service）"><a href="#什么是网络服务质量？（QoS-Quality-of-Service）" class="headerlink" title="什么是网络服务质量？（QoS, Quality of Service）"></a>什么是网络服务质量？（QoS, Quality of Service）</h3><p>QoS是网络在传输数据流时要满足一系列服务请求，具体可以量化为带宽、时延、抖动、丢包率等性能指标。</p><p>QoS针对各种业务的不同需求，为其提供端到端的服务质量保证。在有限的带宽资源下，它允许不同的流量不平等地竞争网络资源，语音、视频和重要的数据应用在网络设备中可以优先得到服务</p><ul><li>针对各种业务的不同需求：传输大文件可能需要大的带宽，玩游戏需要低延迟与低抖动。</li><li>不同的流量不平等地竞争网络资源：这里指的在其他用户不需要的情况下使用空闲的资源。比如对于传输大文件的用户可以分配更大的带宽，对于玩游戏的用于则分配能让延时降低的资源</li></ul><h3 id="如何确保服务质量"><a href="#如何确保服务质量" class="headerlink" title="如何确保服务质量"></a>如何确保服务质量</h3><p>需要解决以下4个问题：</p><ul><li>应用程序需要网络提供什么样的质量？(了解不同的业务需求)</li><li>如何规范进入网络的流量？</li><li>为了保障性能如何在路由器预留资源？</li><li>网络能否安全的接受更多流量？</li></ul><h3 id="流量整形"><a href="#流量整形" class="headerlink" title="流量整形"></a>流量整形</h3><p>这个技术解决的是<strong>规范进入网络的流量</strong>的问题。其作用是限制流出某一网络的某一连接的流量与突发，使这类报文以比较均匀的速度向外发送</p><h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><p>可以把应用想象成水龙头，用户使用流量相当于去开关水龙头。用户的行为是难以预期的，开关的时间以及打开之后的流量都不确定。为了对网络的使用做规范，即让流出去的水水流更加稳定，可以在水龙头下面放一个漏桶，控制流速。同时注意到桶是有深度的，所以这个控制出入的buffer也是有容量大小的。</p><ul><li>漏桶算法由此就能实现<strong>网络流量的限制</strong>。</li><li>同时还需要<strong>对网络的使用进行表达</strong>。这个可以通过控制漏桶洞的大小控制流速，桶的大小控制储存量。</li></ul><p><img src='../../figure/计算机网络笔记/网络层/漏桶算法.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>但是漏桶算法也有一些缺点：</p><ul><li>增加了延迟</li><li>无法应对突发性的应用(如网页浏览)</li></ul><h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>为了解决以上两个问题，出现了令牌桶算法。<br><img src='../../figure/计算机网络笔记/网络层/令牌桶算法.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>如上图所示，一个数据包如果想要传输，那么就必须从桶中拿到一个令牌，否则要被丢弃。</p><ul><li>令牌产生的速率是固定的，可以通过这一点控制传输速率</li><li>同时这里解决了延迟的问题，只要桶里有令牌，就可以立即开始传输</li><li>令牌桶还能解决突发的问题，突发的上限取决于桶的大小。</li></ul><h3 id="数据包调度"><a href="#数据包调度" class="headerlink" title="数据包调度"></a>数据包调度</h3><p>解决的是<strong>为了保障性能如何在路由器预留资源</strong>的问题。即给定应用的需求(流量、突发)之后，由路由器预留资源，保障性能。</p><p>就是在buffer上实现调度算法。<br>• 先来先服务FCFS（First-Come First-Serve）<br>• 公平队列算法（Fair Queueing）<br>• 加权公平队列算法（Weighted Fair Queueing）<br>• 优先级调度（Priority Scheduling）</p><h3 id="服务需求"><a href="#服务需求" class="headerlink" title="服务需求"></a>服务需求</h3><p>解决的是<strong>应用程序需要网络提供什么样的质量</strong>的问题。</p><p>描述应用的质量常用的方法有两种。</p><h4 id="综合服务"><a href="#综合服务" class="headerlink" title="综合服务"></a>综合服务</h4><p>典型的虚电路服务，</p><ul><li>应用必须非常清楚地描述需要的带宽是多少，时延是多少。</li><li>传输之前需要资源预留协议RSVP</li></ul><p>综合服务因为实现上非常困难，所以是失败的。</p><h4 id="区分服务"><a href="#区分服务" class="headerlink" title="区分服务"></a>区分服务</h4><p>IPv4的header中有一个栏位就是关于区分服务的，可以告诉优先级。</p><p>严格的满足某种带宽或者时延是困难的，但是可以把条件放宽松一些。即说明自己是倾向于大带宽或是倾向于低时延，对于这种不同的分类，就能实现不同地路由方式。</p><h2 id="VPN-Virtual-Private-Network"><a href="#VPN-Virtual-Private-Network" class="headerlink" title="VPN(Virtual Private Network)"></a>VPN(Virtual Private Network)</h2><p>目的：希望数据在通过公网传输时是安全的。<br><img src='../../figure/计算机网络笔记/网络层/VPN.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>VPN实现的方法之一就是通过隧道技术。<br><img src='../../figure/计算机网络笔记/网络层/隧道技术.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><p>比如数据报想要从R1传输到R2，中间需要经过公共网络，不安全。此时可以在R1对数据报进行封装，封装之后形成新的数据报，起点是R1，终点是R2。这是原本数据报的源地址X和目的地址Y就被隐藏，内容也会被加密。R2对数据报拆封，并且对内容进行解密，就可以继续正常传输。</p><h2 id="IPv6技术"><a href="#IPv6技术" class="headerlink" title="IPv6技术"></a>IPv6技术</h2><p>IPv6（Internet Protocol version 6）是互联网工程任务组（IETF）设计的用于替代IPv4的下一代协议。</p><p>IPv6地址表示法，冒分十六进制，$x:x:x:x:x:x:x:x$<br>• 简化方法：每个x前面的0可省略，可把连续的值为0的x表示为“::”, 且“::”只能出现1次<br>• 简化前地址，2001:0DA8:0000:0000:200C:0000:0000:00A5<br>• 简化后地址，2001:DA8:0000:0000:200C::A5</p><h3 id="IPv6头部"><a href="#IPv6头部" class="headerlink" title="IPv6头部"></a>IPv6头部</h3><p><img src='../../figure/计算机网络笔记/网络层/IPv6头部.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><ul><li>版本：4bit，协议版本号，值为6</li><li>流量类型：8bit，区分数据包的<strong>服务类别</strong>或优先级<ul><li>对应区分服务</li></ul></li><li>流标签：20bit，标识同一个数据流<ul><li>进程和进程之间通信，通信的数据报就属于同一个流。在IPv4中，想要知道数据报属于哪一个流，需要使用5 tuple(源地址，目的地址，源端口号，目的端口号，传输层协议)。使用5 tuple需要同时知道网络层和传输层的信息，而使用流标签能让路由器更快地做出判断，增加了IP的传输效率。</li></ul></li><li>有效载荷长度：16bit ，IPv6报头之后载荷的字节数（含扩展头），最大值64K<ul><li>对应IPv4的总长度</li></ul></li><li>下一个首部：8bit ，IPv6报头后的协议类型，可能是TCP/UDP/ICMP等，也可能是扩展头</li><li>跳数限制：8bit ，类似IPv4的TTL，每次转发跳数减1，值为0时包将会被丢弃<ul><li>对应生存时间</li></ul></li><li>源地址：128bit ，标识该报文的源地址</li><li>目的地址：128bit ，标识该报文的目的地址</li></ul><p>IPv6头部相比IPv4减少的东西</p><ul><li>没有首部校验和<ul><li>TCP和UDP会做校验，校验时会加入pseudo header，即IP层的header。但是当数据从下层往上层传输的时候，应当把头部先去掉，但是由于IP的header非常重要，因此这里保留下来进行校验，避免IP地址被篡改等问题。</li><li>由于传输层做了校验，IPv6就把校验去掉了</li></ul></li><li>没有首部长度<ul><li>IPv4有选项，但是IPv6没有。</li><li>长度固定是为了IPv6的转发效率</li><li>IPv6中选项的功能与下一个首部有关</li></ul></li><li>没有标识、标志与片偏移<ul><li>IPv4中这三个与分片有关</li><li>IPv6为了效率，不允许在转发的过程中做分片。在发送之前就会找到合适的路径。</li></ul></li><li>没有协议<ul><li>IPv4中协议即上层使用的协议，如TCP，UDP，ICMP等</li><li>IPv6中该功能和下一个首部相关</li></ul></li></ul><h3 id="IPv6扩展头"><a href="#IPv6扩展头" class="headerlink" title="IPv6扩展头"></a>IPv6扩展头</h3><p><img src='../../figure/计算机网络笔记/网络层/IPv6扩展头.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>IPv6想要实现功能的扩充，可以在中间插入头部。</p>]]></content>
      
      
      <categories>
          
          <category> computer network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning from Examples</title>
      <link href="/posts/2a9c81bf.html"/>
      <url>/posts/2a9c81bf.html</url>
      
        <content type="html"><![CDATA[<h2 id="Types-of-Learning"><a href="#Types-of-Learning" class="headerlink" title="Types of Learning"></a>Types of Learning</h2><p>机器学习有以下分类：</p><ul><li>有监督学习：分类，回归</li><li>无监督学习：聚类，降维</li><li>半监督学习：介于上两者之间，同时用到了监督学习和无监督学习的技术</li><li>强化学习：没有明确的可以学习的目标，但是在与环境交互的过程中会有奖励(reward)，然后通过这些奖励来不断学习。</li><li>自监督学习：与无监督学习有些不同。无监督学习目的是发现数据隐含的pattern，而自监督学习则是自己创造label。比如大语言模型，后面的句子就是前面句子的label。</li></ul><h2 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h2><h3 id="Linear-Basis-Function-Models"><a href="#Linear-Basis-Function-Models" class="headerlink" title="Linear Basis Function Models"></a>Linear Basis Function Models</h3><p>线性回归除了最基础的 $h<em>{\theta}(\bm{x})=\theta_0+\theta_1 x_1+ \cdots +\theta</em>{n}x_n$(或者简写成 $\bm{\theta}^{\mathrm{T}}\bm{x}$，其中定义 $x_0=1$)，还可以对 $\bm{x}$ 进行各种形式的变化。所以一个更加通用的拟合方程为：</p><script type="math/tex; mode=display">y(\bm{x},\bm{w}) = \sum_{j=0}^{M-1}w_j \phi_j(\bm{x}) = \bm{w}^{\mathrm{T}}\phi(\bm{x})</script><p>其中 $\bm{w}=(w<em>0, \ldots w</em>{M-1}), \bm{\phi}=(\phi<em>0, \ldots \phi</em>{Mj-1})^{\mathrm{T}}$，并且 $\phi_0(\bm{x})=1$，$w_0$ 为偏移量(bias)。</p><p>一些常用的函数为：</p><ul><li>多项式函数 $\phi_j(x)=x_j$</li><li>高斯函数 $\phi_j(x)=\exp \left( \displaystyle -\frac{(x-\mu_j)^{2}}{2s^{2}} \right)$</li><li>Sigmoid 函数 $\phi_j(x)=\sigma \left( \displaystyle \frac{x-\mu_j}{s} \right)$，其中 $\sigma(a)=\displaystyle \frac{1}{1+e^{-a}}$。</li></ul><h3 id="The-Least-Mean-Square-LMS-method"><a href="#The-Least-Mean-Square-LMS-method" class="headerlink" title="The Least Mean Square (LMS) method"></a>The Least Mean Square (LMS) method</h3><p>定义 cost function：</p><script type="math/tex; mode=display">J(\bm{\theta})=\frac{1}{2}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})^{2}</script><p>更新 $\bm{\theta}$：</p><script type="math/tex; mode=display">\theta_j :=\theta_j - \alpha \frac{\partial }{\partial \theta_j}J(\bm{\theta})</script><p>对于一个训练集，更新变量时可以使用</p><script type="math/tex; mode=display">\theta_{j} := \theta_j + \alpha \sum_{i=1}^{m}(y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)}</script><p>但是假如数据集特别大，那么每次更新计算开销特别大，所以有了随机梯度下降：</p><script type="math/tex; mode=display">\begin{aligned}&for\ i=1\ to\ m \\&\theta_j := \theta_j + \alpha (y^{(i)}-h_{\theta}(x^{i}))x_{j}^{(i)}\end{aligned}</script><p>但如果一次只一个变量，那么这个变量可能会有比较大的噪声，所以也可以一次多取几个数据，形成一个 batch，这就是小批量随机梯度下降。</p><h3 id="The-normal-equations"><a href="#The-normal-equations" class="headerlink" title="The normal equations"></a>The normal equations</h3><p>写成矩阵形式并且进行运算：</p><script type="math/tex; mode=display">\mathbf{X=}\begin{bmatrix}--(\mathbf{x}^{(1)})^T--\\--(\mathbf{x}^{(2)})^T--\\\vdots\\--(\mathbf{x}^{(m)})^T--\end{bmatrix}=\begin{bmatrix}\mathbf{x}_1^{(1)}&\mathbf{x}_2^{(1)}&\cdots&\mathbf{x}_n^{(1)}\\\mathbf{x}_1^{(2)}&\mathbf{x}_2^{(2)}&\cdots&\mathbf{x}_n^{(2)}\\\vdots&\vdots&\ddots&\vdots\\\mathbf{x}_1^{(m)}&\mathbf{x}_2^{(m)}&\cdots&\mathbf{x}_n^{(m)}\end{bmatrix}\quad\mathbf{Y=}\begin{bmatrix}y^{(1)}\\y^{(2)}\\\vdots\\y^{(m)}\end{bmatrix}</script><p>对 $\theta$ 求梯度：</p><script type="math/tex; mode=display">\begin{aligned}\nabla_{\theta}J(\theta)& =\nabla_\theta\frac{1}{2}(X\theta-\vec{y})^T(X\theta-\vec{y})  \\&=\frac{1}{2}\nabla_{\theta}\left(\theta^TX^TX\theta-\theta^TX^T\vec{y}-\vec{y}^TX\theta+\vec{y}^T\vec{y}\right) \\&=\frac{1}{2}\nabla_{\theta}\operatorname{tr}\left(\theta^{T}X^{T}X\theta-\theta^{T}X^{T}\vec{y}-\vec{y}^{T}X\theta+\vec{y}^{T}\vec{y}\right) \\&=\frac{1}{2} \nabla_{\theta}\left(\operatorname{tr}\theta^TX^TX\theta-2\operatorname{tr}\vec{y}^TX\theta\right) \\&=\frac12\left(X^TX\theta+X^TX\theta-2X^T\vec{y}\right) \\&= X^{T}X\theta-X^{T}\vec{y}\end{aligned}</script><p>想要最小化 $J$，那么应该有 $X^{\mathrm{T}}X\theta=X^{\mathrm{T}}\vec{y}$，解得 $\theta = (X^{\mathrm{T}}X)^{-1}X^{\mathrm{T}}\vec{y}$。</p><p>以上条件需要在 $(X^{\mathrm{T}}X)^{-1}$ 存在时成立。考察矩阵 $X$，这是一个 $n\times m$ 的矩阵，其中 $n$ 为变量的数量，$m$ 为样本数量。当 $n\le m$ 时，通常矩阵 $(X^{\mathrm{T}}X)$ 满秩，可逆；但是假如 $n\ge m$，即样本数量过少，那么就不可逆，$\theta$ 无法使用该方法求解。此时需要引入正则化。</p><h3 id="Regularized-least-squares"><a href="#Regularized-least-squares" class="headerlink" title="Regularized least squares"></a>Regularized least squares</h3><p>将 error function 改为</p><script type="math/tex; mode=display">\frac{1}{2}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})^{2} + \frac{\lambda}{2}\theta^{\mathrm{T}}\theta \Rightarrow \theta = (\lambda \bm{I}+X^{\mathrm{T}}X)^{-1}X^{\mathrm{T}}\vec{y}</script><p>即加入了一个二范数项。</p><p>将正则化的操作可视化，左侧为 $l_1$ 正则化，右侧为 $l_2$ 正则化，即上述式子给出的操作方法。图中的等高线表示 $w^{1}, w^{2}$ 取不同值时 error function 取到相同值的情况。<br><img src='../../figure/人工智能笔记/6-Learning-from-Examples/Regularized_least_squares.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"> </p><p>对于左图的正则化，做的约束为：$\left\vert w_1 \right\vert +\left\vert w_2 \right\vert \le t$，此时的等高线与正则化限制区域的交点通常在坐标轴上，所以相当于消掉了一个维度；对于右图的正则化，做的约束为 $w_1^{2}+w_2^{2}\le t$。</p><h2 id="Polynomial-Curve-Fitting"><a href="#Polynomial-Curve-Fitting" class="headerlink" title="Polynomial Curve Fitting"></a>Polynomial Curve Fitting</h2><p><img src='../../figure/人工智能笔记/6-Learning-from-Examples/polynomial_curve.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"> </p><p>假如想拟合图上的这些点。如果多项式的次数太低，那么可能会导致欠拟合；如果多项式次数过高，可能会导致过拟合。欠拟合和过拟合的效果如图：</p><div style="text-align: center;">  <img src='../../figure/人工智能笔记/6-Learning-from-Examples/first_order.png' height=200 style="display: inline-block; margin-right: 10px;">  <img src='../../figure/人工智能笔记/6-Learning-from-Examples/ninth_order.png' height=200 style="display: inline-block; margin-right: 10px;"></div><p>如果发现欠拟合，那么可以增加次数；如果发现过拟合，可以减少次数(降低模型复杂度)，增加样本数量，或者使用正则项。</p><p>我们先观察在不同次数的情况下拟合得到的系数：<br><img src='../../figure/人工智能笔记/6-Learning-from-Examples/polynomial_coefficients.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"> </p><p>我们发现当出现过拟合时，多项式的某些系数会非常大。因此可以使用正则化项来约束系数的复杂度。此时 cost function 为：</p><script type="math/tex; mode=display">\tilde{E}(\bm{w})=\frac{1}{2}\sum_{n=1}^{N} \left\{ y(x_n,\bm{w})-t_n \right\}^{2}+\frac{\lambda}{2} \left\| \bm{w} \right\|_{}^{2}</script><p>不同的 $\lambda$ 值对模型有不同的约束力度。<br><img src='../../figure/人工智能笔记/6-Learning-from-Examples/lambda_regularization.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"> </p><h2 id="Probabilistic-Interpretation-of-LMS"><a href="#Probabilistic-Interpretation-of-LMS" class="headerlink" title="Probabilistic Interpretation of LMS"></a>Probabilistic Interpretation of LMS</h2><p>这里解释为什么拟合问题通常使用最小平方误差。</p><p>对于目标变量 $y$ 和已有信息 $x$，假如确实存在线性关系，那么考虑到测量误差等问题，测得的信息通常为</p><script type="math/tex; mode=display">y^{(i)}=\theta^{\mathrm{T}}x^{(i)}+\epsilon^{(i)}</script><p>假设其中 $\epsilon^{(i)}$ 满足高斯分布 $N(0,\sigma^{2})$，并且独立同分布，那么我们有</p><script type="math/tex; mode=display">p(y^{(i)}|x^{(i)};\theta)=\frac1{\sqrt{2\pi}\sigma}exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})</script><p>然后我们得到似然函数</p><script type="math/tex; mode=display">L(\theta)=L(\theta;X,\vec{y})=p(\vec{y}|X;\theta)</script><p>所以再根据独立同分布的假设</p><script type="math/tex; mode=display">\begin{aligned}L(\theta)&=\prod_{i=1}^mp(y^{(i)}|x^{(i)};\theta)\\&=\prod_{i=1}^m\frac1{\sqrt{2\pi}\sigma}exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})\end{aligned}</script><p>由于 $L(\theta)$ 不方便计算，因此我们取对数</p><script type="math/tex; mode=display">\begin{aligned}\iota(\theta)&=\log L(\theta)\\&=\log\prod_{i=1}^m\frac1{\sqrt{2\pi}\sigma}exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})\\&=\sum_{i=1}^m\log\frac1{\sqrt{2\pi}\sigma}exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})\\&=m\log\frac1{\sqrt{2\pi}\sigma}-\frac1{\sigma^2}\times\frac12\sum_{i=1}^m(y^{(i)}-\theta^Tx^{(i)})^2\end{aligned}</script><p>根据统计学上的规则，我们需要最大化似然，在上式中我们可以看出正是需要最小化平方误差。</p><h2 id="Classification-and-Logistic-Regression"><a href="#Classification-and-Logistic-Regression" class="headerlink" title="Classification and Logistic Regression"></a>Classification and Logistic Regression</h2><p>分类问题有二分类(binary classification)，多分类(multi classification)等。除此之外还有多标签(multi label)，这个指的是一个样本可能同属于多个类别。</p><h3 id="Logistic-Regression-Model-Description"><a href="#Logistic-Regression-Model-Description" class="headerlink" title="Logistic Regression Model Description"></a>Logistic Regression Model Description</h3><p>Logistic Regression 虽然名为 “Regression”，但实际上是个分类模型。</p><p>与线性回归直接对输出结果建模不同，Logistic Regression 对输出的后验概率做建模。这里以二分类为例，用 $y=0,y=1$ 代表两个类：</p><script type="math/tex; mode=display">\begin{aligned}P(y=1|x;\theta)&=h_\theta(x)=g(\theta^Tx)=\frac1{1+e^{-\theta^Tx}}\\P(y=0|x;\theta)&=1-h_\theta(x)\end{aligned}</script><p>或者写成一个式子：</p><script type="math/tex; mode=display">P(y|x;\theta)=(h_{\theta}(x))^{y}(1-h_{\theta}(x))^{1-y}</script><h3 id="Maximum-Likelihood-Estimation"><a href="#Maximum-Likelihood-Estimation" class="headerlink" title="Maximum Likelihood Estimation"></a>Maximum Likelihood Estimation</h3><p>与线性回归最小化均方误差不同，这里要最大化条件似然。此处条件似然函数(conditional likelihood)为</p><script type="math/tex; mode=display">\begin{aligned}L(\theta)& =p(\overrightarrow{y}|X;\theta)  \\&=\prod_{i=1}^mp(y^{(i)}|x^{(i)};\theta) \\&=\prod_{i=1}^m(h_\theta(x^{(i)}))^{y^{(i)}}(1-h_\theta(x^{(i)}))^{1-y^{(i)}}\end{aligned}</script><p>取对数：</p><script type="math/tex; mode=display">\begin{aligned}\iota(\theta)& =\log L(\theta)  \\&=\sum_{i=1}^my^{(i)}\log h_{\theta}(x^{(i)})+(1-y^{(i)})\log(1-h_{\theta}(x^{(i)}))\end{aligned}</script><p>最后的形式就是交叉熵。</p><h3 id="Gradient-Ascent"><a href="#Gradient-Ascent" class="headerlink" title="Gradient Ascent"></a>Gradient Ascent</h3><p>所以现在需要解决的问题是：</p><script type="math/tex; mode=display">argmax_\theta\sum_{i=1}^my^{(i)}\log h_\theta(x^{(i)})+(1-y^{(i)})\log(1-h_\theta(x^{(i)}))</script><p>考虑到 sigmoid 函数求导的特性：</p><script type="math/tex; mode=display">\begin{aligned}g^{\prime}(z)& =\frac d{dz}\frac1{1+e^{-z}}  \\&=\frac1{(1+e^{-z})^2}(e^{-z}) \\&=\frac1{(1+e^{-z})}(1-\frac1{(1+e^{-z})}) \\&=g(z)(1-g(z))\end{aligned}</script><p>最终求导结果为：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial\iota(\theta)}{\partial\theta_j}& =\sum_{i=1}^m(y^{(i)}\frac1{h_\theta(x^{(i)})}-(1-y^{(i)})\frac1{1-h_\theta(x^{(i)})})\frac\partial{\partial\theta_j}h_\theta(x^{(i)})  \\&=\sum_{i=1}^m(y^{(i)}\frac1{h_\theta(x^{(i)})}-(1-y^{(i)})\frac1{1-h_\theta(x(i))})h_\theta(x^{(i)})(1-h_\theta(x^{(i)}))\frac\partial{\partial\theta_j}\theta^Tx^{(i)} \\&=\sum_{i=1}^m(y^{(i)}(1-h_\theta(x^{(i)}))-(1-y^{(i)})h_\theta(x^{(i)}))x_j \\&=\sum_{i=1}^m(y-h_\theta(x^{(i)}))x_j\end{aligned}</script><p>和线性回归模型类似，最后在更新参数的时候也可以采用批量梯度上升的方式：</p><script type="math/tex; mode=display">\theta_j:=\theta_j + \alpha \sum_{i=1}^{m}(y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)}</script>]]></content>
      
      
      <categories>
          
          <category> artificial intelligence </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>介质访问子层</title>
      <link href="/posts/bafb2d30.html"/>
      <url>/posts/bafb2d30.html</url>
      
        <content type="html"><![CDATA[<h2 id="MAC-Media-Access-Control-子层在哪里？"><a href="#MAC-Media-Access-Control-子层在哪里？" class="headerlink" title="MAC(Media Access Control)子层在哪里？"></a>MAC(Media Access Control)子层在哪里？</h2><p>数据链路层分为两个子层：<br>• MAC子层：介质访问<br>• LLC子层：承上启下（弱层），主要起到的是让上层无需关心下层的实现方式，即根据物理层的情况调用不同的协议。<br><img src='../../figure/计算机网络笔记/介质访问子层/MAC子层位置.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><ul><li>以太网包含了物理层和数据链路层，是个2层协议。</li><li>IEEE802.3则包含了物理层和MAC子层，是1.5层协议。</li><li>而WiFi(IEEE802.11)也是1.5层协议。</li></ul><p>对于1.5层的协议，LLC子层可以使用IEEE802.2进行协议的选择，更加有弹性。而以太网虽然设计的没那么好，但是提出更早，因此如今被更加广泛的使用。</p><!-- 之前讲到数据链路层最流行的是PPP协议， --><h2 id="信道分配问题"><a href="#信道分配问题" class="headerlink" title="信道分配问题"></a>信道分配问题</h2><h3 id="常见的接入情形"><a href="#常见的接入情形" class="headerlink" title="常见的接入情形"></a>常见的接入情形</h3><p>之前讲到数据链路层属于点对点的连接协议。对于家庭用户，比较常见的是使用信道直接连接两个端点<br><img src='../../figure/计算机网络笔记/介质访问子层/点到点信道.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>但是假如是公司用户，常见的是多用户共享一根信道。所以MAC子层需要解决的就是这里的信道复用的问题。<br><img src='../../figure/计算机网络笔记/介质访问子层/多点访问信道.png' width=250 style="display: block; margin-left: auto; margin-right: auto;"></p><p>介质访问控制可以分为<strong>静态分配</strong>和<strong>动态分配</strong>。</p><h3 id="静态分配的性能分析"><a href="#静态分配的性能分析" class="headerlink" title="静态分配的性能分析"></a>静态分配的性能分析</h3><p>常见的静态分配方法有：时分(TDM)，频分(FDM)。</p><p>在这里我们使用排队时间的长短来衡量性能。</p><h4 id="M-M-1排队系统模型"><a href="#M-M-1排队系统模型" class="headerlink" title="M/M/1排队系统模型"></a>M/M/1排队系统模型</h4><ul><li>M（顾客到达时间间隔分布）<ul><li>帧到达时间间隔服从指数分布</li><li>平均到达率（输入率）：l 帧/秒</li></ul></li><li>M（服务时间分布）<ul><li>帧长度服从指数分布，平均长度1/µ 位/帧</li><li>信道容量为C 位/秒，则信道服务率为µC 帧/秒</li></ul></li><li>1（并列服务台个数）</li></ul><p><img src='../../figure/计算机网络笔记/介质访问子层/MM1模型.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>下面分析一个稳定的生灭过程：</p><script type="math/tex; mode=display">\begin{aligned}\lambda p_0 &= \mu C p_1 \\\lambda p_1+\mu C p_1 &= \lambda p_0 +\mu C p_2 \\\lambda p_2+\mu C p_2 &= \lambda p_1 +\mu C p_3 \\&\cdots \end{aligned}</script><p>可以解得 $p_{i}=p_0 \rho^{i}$，其中 $\rho=\frac{\lambda}{\mu C}$，$p_0=1-\rho$。最终可得队伍中平均顾客数量为：</p><script type="math/tex; mode=display">N = \sum_{i=0}^{\infty}i p_{i} = \frac{\rho}{1-\rho}</script><p><img src='../../figure/计算机网络笔记/介质访问子层/排队论稳定生灭过程.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="Little定理"><a href="#Little定理" class="headerlink" title="Little定理"></a>Little定理</h4><p>在稳定状态下，存储在网络中的<strong>报文平均数</strong>，等于报文的<strong>平均到达率</strong>乘以这些报文在网络中经历的<strong>平均时间</strong></p><p>结合排队模型的分析，有</p><script type="math/tex; mode=display">N=\frac{\rho}{1-\rho}=\lambda T \Rightarrow T = \frac{1}{\mu C-\lambda}</script><p>$T$ 即为每个客户等待的平均时间。</p><h4 id="子信道的平均延迟"><a href="#子信道的平均延迟" class="headerlink" title="子信道的平均延迟"></a>子信道的平均延迟</h4><p>假如将信道 $N$ 等分，得到 $N$ 个子信道，那么平均输入率为 $\lambda /N$，平均服务率为 $C /N$，平均延迟为：</p><script type="math/tex; mode=display">T_{FDM}= \frac{1}{\mu(C /N)- \lambda /N} = \frac{N}{\mu C-\lambda}=NT</script><h3 id="静态分配特点"><a href="#静态分配特点" class="headerlink" title="静态分配特点"></a>静态分配特点</h3><ul><li>问题<ul><li>资源分配不合理，不满足用户对资源占用的不同需求</li><li>有资源浪费，效率低</li><li>延迟时间增大N倍</li></ul></li><li>适用情况<ul><li>适于用户数量少且用户数目固定的情况</li><li>适于通信量大且流量稳定的情况</li><li>不适用于突发性业务的情况</li></ul></li></ul><h2 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h2><h3 id="三大多路访问协议"><a href="#三大多路访问协议" class="headerlink" title="三大多路访问协议"></a>三大多路访问协议</h3><p>随机访问协议通常都会引起冲突。而受控访问协议相当于有一个中心来决定谁来发送数据，不会产生冲突。随机访问协议和受控访问协议分别在低负载和高负载的情况下性能较优，有限竞争协议则是对这两者的权衡。</p><p><img src='../../figure/计算机网络笔记/介质访问子层/三大多路访问协议.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h3><h4 id="纯ALOHA协议工作原理"><a href="#纯ALOHA协议工作原理" class="headerlink" title="纯ALOHA协议工作原理"></a>纯ALOHA协议工作原理</h4><p>想发就发，因此随时可能导致冲突。冲突了的帧需要重传。<br><img src='../../figure/计算机网络笔记/介质访问子层/纯ALOHA.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>为了衡量ALOHA协议的性能，我们定义<strong>帧时</strong> $T$ 为发送一个标准长的帧所需要的时间</p><p>假设生成帧的数量服从泊松分布</p><ul><li>一个帧时内用户平均产生 $N$ 个新帧</li><li>一个帧时内信道平均产生 $G$ 个新帧(包括重传)</li></ul><p>分析一下可以发现，$0<N<1$，轻载时 $N\rightarrow 0$，重载时 $N \rightarrow 1$。同时 $G\ge N$，轻载时 $G=N$(无冲突)，重载 $G>N$(冲突导致重传)。</p><p>根据泊松分布，一个帧时内产生 $k$ 个帧的概率为</p><script type="math/tex; mode=display">\operatorname{Pr}(k)=G^{k}e^{-G}/k!</script><p>当 $k=0$，有 $\operatorname{Pr}(k=0)=e^{-G}$。</p><h4 id="纯ALOHA协议性能分析"><a href="#纯ALOHA协议性能分析" class="headerlink" title="纯ALOHA协议性能分析"></a>纯ALOHA协议性能分析</h4><p>再定义</p><ul><li><strong>吞吐量</strong> $S$ 为在一个帧时 $T$ 内发送成功的平均帧数(相当于信道利用率)，显然 $0&lt;S&lt;1$。</li><li><strong>网络负载</strong> $G$ 为一个帧时 $T$ 内所有通信站总共发送的帧平均值(包括重发)</li><li>$P_0$ 为一帧发送成功(未发生冲突)的概率</li></ul><p>以上有 $S=G\times P_0$。</p><p>然后分析纯ALOHA冲突概率。假如一帧想要成功发送不冲突，那么在 $2T$ 的一段时间中应当都没有其他帧发送，如下图所示<br><img src='../../figure/计算机网络笔记/介质访问子层/纯ALOHA冲突概率.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>这段时间内生成帧的平均值为 $2G$，因此不产生冲突的概率为 $P_0=e^{-2G}$。然后带入</p><script type="math/tex; mode=display">S=GP_0=Ge^{-2G}</script><p>分析可知当 $G=0.5$ 时，$S$ 取到最大值 $0.184$。可以看出纯ALOHA的信道利用率很低。</p><h4 id="分隙ALOHA-Slotted-ALOHA"><a href="#分隙ALOHA-Slotted-ALOHA" class="headerlink" title="分隙ALOHA(Slotted ALOHA)"></a>分隙ALOHA(Slotted ALOHA)</h4><p>相比之前改进的地方是把时间分成时隙，时隙长度对应一帧的传输时间，帧的发送只能在时隙的起点。那么此时可以看出冲突也只能发生在时隙的起点<br><img src='../../figure/计算机网络笔记/介质访问子层/分隙ALOHA.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>此时 $P<em>0=e^{-G}$，$S=G e^{-G}$，在 $G=1$ 时，取到 $S</em>{\max}=1/e\thickapprox 0.368$</p><h3 id="载波侦听多路访问协议-CSMA：Carrier-Sense-Multiple-Access"><a href="#载波侦听多路访问协议-CSMA：Carrier-Sense-Multiple-Access" class="headerlink" title="载波侦听多路访问协议(CSMA：Carrier Sense Multiple Access)"></a>载波侦听多路访问协议(CSMA：Carrier Sense Multiple Access)</h3><p>先听后发。假如没有其他用户发送，那么就发送；但是假如监听到信道被占用，则有多种不同处理方式</p><h4 id="非持续式CSMA"><a href="#非持续式CSMA" class="headerlink" title="非持续式CSMA"></a>非持续式CSMA</h4><ol><li>经侦听，如果介质空闲，开始发送</li><li>如果介质忙，则等待一个随机分布的时间，然后重复步骤 $1.$</li></ol><ul><li>优点：等待一个随机时间可以减少再次碰撞冲突的可能性</li><li>缺点：等待时间内介质上如果没有数据传送，这段时间是浪费的</li></ul><h4 id="1-持续式CSMA"><a href="#1-持续式CSMA" class="headerlink" title="1-持续式CSMA"></a>1-持续式CSMA</h4><ol><li>经侦听，如介质空闲，则发送</li><li>如介质忙，持续侦听，一旦空闲立即发送</li><li>如果发生冲突，等待一个随机分布的时间再重复步骤①</li></ol><ul><li>优点：持续式的延迟时间要少于非持续式</li><li>主要问题：如果两个以上的站等待发送，一旦介质空闲就一定会发生冲突</li></ul><h4 id="p-持续式CSMA"><a href="#p-持续式CSMA" class="headerlink" title="p-持续式CSMA"></a>p-持续式CSMA</h4><ol><li>经侦听，如介质空闲，那么以 $p$ 的概率 发送，以 $1-p$ 的概率延迟一个时间单元发送</li><li>如介质忙，持续侦听，一旦空闲重复 $1.$</li><li>如果发送已推迟一个时间单元，再重复步骤 $1.$</li></ol><h4 id="CSMA能否避免冲突"><a href="#CSMA能否避免冲突" class="headerlink" title="CSMA能否避免冲突"></a>CSMA能否避免冲突</h4><p>不能。一种情况是信道空闲后两个用户可能同时发送导致冲突，另一种情况和传播延迟有关。</p><p>比如在下图中，$t_0$ 时刻甲发送信号，$t_1$ 时刻乙侦听后以为信道没有占用，也发送信号。然后 $t_2$ 时刻发生冲突，$t_3$ 时刻乙检测到冲突，$t_4$ 时刻甲检测到冲突。<br><img src='../../figure/计算机网络笔记/介质访问子层/传播延时对CSMA的影响.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="侦听冲突的原理"><a href="#侦听冲突的原理" class="headerlink" title="侦听冲突的原理"></a>侦听冲突的原理</h4><p>Tx为发送端，Rx为接收端。检测冲突的原理为：在Tx发送数据时，会通过Loopback将信号传输给自己的Rx，而Rx同时也接收Receive的信号，两个信号线性叠加。假如此时信道没有其他信号占用，那么Rx收到的就是Tx的数据帧。Tx和Rx都会向Collision Detection传输数据，所以假如Rx和Tx的数据一样，那么认为没有冲突，反之认为有冲突。<br><img src='../../figure/计算机网络笔记/介质访问子层/侦听冲突原理.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>回到刚才传播延迟产生冲突的例子，假如甲在 $t_4$ 时刻之前就停止了发送数据，那么根据侦听冲突的原理，甲无法侦测到冲突。同理如果乙在 $t_3$ 前停止发送数据，则导致乙侦测不到冲突。</p><p>因此这里定义<strong>冲突窗口</strong>的概念。冲突窗口是一个时间区间，表示发送方发出帧之后能检测到冲突的最长时间。冲突窗口在数值上等于最远两方传播时间的两倍 $2D$，即一个来回传播时延RTT(Round Trip Time)。</p><p>想要避免无法侦听到冲突的问题，我们要求发送方发送帧的时间应当大于冲突窗口，所以需要规定帧的最小长度 $L=2D\cdot v$，其中 $v$ 为信号传播速度。</p><h4 id="CSMA-CD-（1-持续）"><a href="#CSMA-CD-（1-持续）" class="headerlink" title="CSMA/CD （1-持续）"></a>CSMA/CD （1-持续）</h4><p>考虑到直接使用CSMA无法避免冲突，所以还需要解决冲突，这里使用CSMA with Collision Detection。</p><p>原理：“先听后发、边发边听”</p><ol><li>经侦听，如介质空闲，则发送。</li><li>如介质忙，持续侦听，一旦空闲立即发送。</li><li>如果发生冲突，等待一个随机分布的时间再重复步骤 $1.$</li></ol><p>当一方侦测到冲突之后，就会立刻停止传输，同时发送强化(Jam)信号，告诉另一方有冲突发生。<br><img src='../../figure/计算机网络笔记/介质访问子层/CSMA_CD.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>CSMA/CD 的概念模型包含：</p><ul><li>传输周期：一个站点使用信道，其他站点禁止使用</li><li>竞争周期：所有站点都有权尝试使用信道，争用时间槽</li><li>空闲周期：所有站点都不使用信道</li></ul><p><img src='../../figure/计算机网络笔记/介质访问子层/CSMA_CD概念模型.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="各种CSMA的性能比较"><a href="#各种CSMA的性能比较" class="headerlink" title="各种CSMA的性能比较"></a>各种CSMA的性能比较</h4><p>这里考虑信道利用率。<br><img src='../../figure/计算机网络笔记/介质访问子层/各种CSMA性能比较.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>如今的以太网采用的是CSMA/CD(1-持续式)。虽然 $p$ 更小时信道利用率更高，但是由于延迟过高，所以并不实用。</p><h3 id="位图协议"><a href="#位图协议" class="headerlink" title="位图协议"></a>位图协议</h3><ul><li>在竞争期，每个使用者都有一定的时隙，在时隙中可以“举手”示意自己有数据要发送。</li><li>在传输期，刚刚举手的使用者按序发送，避免冲突</li></ul><p><img src='../../figure/计算机网络笔记/介质访问子层/位图协议图示.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="位图协议信道利用率分析"><a href="#位图协议信道利用率分析" class="headerlink" title="位图协议信道利用率分析"></a>位图协议信道利用率分析</h4><p>假设有 $N$ 个用户，同时每个帧有 $d$ 个 bits。</p><p>信道利用率</p><ul><li>在低负载下：$d /(d+N) \xrightarrow{N\rightarrow\infty} 0$</li><li>在高负载下：$Nd /(Nd + N) = d /(d + 1) \xrightarrow{d \rightarrow \infty} 1$</li></ul><p>位图协议还有个缺点，就是无法考虑优先级。</p><h3 id="二进制倒计数协议"><a href="#二进制倒计数协议" class="headerlink" title="二进制倒计数协议"></a>二进制倒计数协议</h3><p>想要解决优先级的问题，可以使用二进制倒计数协议。该协议对每个站点进行<strong>编号</strong>，序号的长度相同。</p><ul><li>在竞争期，需要发送数据的站点从高序号到低序号进行比较，需要更大的优先。<br>比较方式为：先比第一位，假如某个站点第一位为 $0$，但是发现存在站点第一位为 $1$，则该站点放弃竞争。</li></ul><p><img src='../../figure/计算机网络笔记/介质访问子层/二进制倒计数协议.png' width=250 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="二进制倒计数协议的信道利用率分析"><a href="#二进制倒计数协议的信道利用率分析" class="headerlink" title="二进制倒计数协议的信道利用率分析"></a>二进制倒计数协议的信道利用率分析</h4><p>$N$ 个站点二进制编码需要 $\log_2 N$ 位，因此信道利用率为 $d / (d+\log_2 N)$。</p><h3 id="自适应搜索树协议"><a href="#自适应搜索树协议" class="headerlink" title="自适应搜索树协议"></a>自适应搜索树协议</h3><p>类似于核酸检测，先混检，发现问题之后再单检。</p><p>自适应搜索树协议在一次成功传输后的第一个竞争时隙，所有站点同时竞争。</p><ul><li>如果只有一个站点申请，则获得信道。</li><li>否则在下一竞争时隙，有一半站点参与竞争（递归），下一时隙由另一半站点参与竞争</li></ul><p><img src='../../figure/计算机网络笔记/介质访问子层/自适应搜索树协议.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><h3 id="以太网的前世今生"><a href="#以太网的前世今生" class="headerlink" title="以太网的前世今生"></a>以太网的前世今生</h3><p>1973年提出经典以太网，后来又出现了快速以太网(fast ethernet)，千兆以太网(gigabit ethernet)，万兆以太网(10-G ethernet)，每次版本迭代速度大约差十倍。</p><h3 id="经典以太网"><a href="#经典以太网" class="headerlink" title="经典以太网"></a>经典以太网</h3><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>最高速率 $10Mbps$，使用曼彻斯特编码，使用<strong>同轴电缆</strong>和<strong>中继线</strong>连接。<br><img src='../../figure/计算机网络笔记/介质访问子层/以太网的物理层.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>任意两个收发器之间距离不得超过2.5km，且任意两个收发器之间经过的中继器不能超过4个，以保证MAC协议正常工作</p><h4 id="MAC子层"><a href="#MAC子层" class="headerlink" title="MAC子层"></a>MAC子层</h4><p>主机运行CSMA/CD协议</p><p>常用的MAC帧格式有两种标准</p><ul><li>DIX Ethernet V2 标准(最常用的)</li><li>IEEE 的 802.3 标准</li></ul><p>一个帧的完整格式如下，而对于其中的 header，两种标准略有不同<br><img src='../../figure/计算机网络笔记/介质访问子层/MAC帧格式.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><p>在DIX Ethernet V2 标准中，类型有以下几种：</p><ul><li>IPv4: 0x0800</li><li>ARP: 0x0806</li><li>PPPoE: 0x8864 (PPPoE协议是结合了以太网能够解决信道复用以及PPP协议有连接的特点形成的协议)</li></ul><p>因此再考虑数据的长度不超过1500，比对应类型的数字都小。网卡可以通过这一项的值大小来判断接收到的MAC帧格式使用的是哪个标准。</p><p>数据帧数据的长度最小是46个字节，这与冲突窗口有关。数据帧长度不能太短，否则会导致无法检测到冲突。分析经典的以太网，速率为 $10Mbps$，最大长度为 $2500\times 4=10000m$，在最差情况下往返一次的时间为 $50ms$，在这段时间内能够发送 $500bit$，加上安全余量至 $512bit$，因此总长度设置为 $64Bytes$。<br><img src='../../figure/计算机网络笔记/介质访问子层/MAC帧最短数据.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>经过以上分析，我们注意到这个长度的设定是和以太网的传输速率有关的。</p><ul><li>假如传输速率增大，当使用 fast ethernet 时，为了不增加帧长，那就必须将最大长度缩小十倍。</li><li>再到gigabit ethernet，为了保证CSMA/CD继续正常工作，可以采用载波扩充(增加帧长度)或者帧突发(将多个小的帧合到一起)。但事实上，此时的以太网在使用了交换机之后已经避免了冲突问题，如果不需要向前兼容，可以不使用CSMA/CD。</li></ul><p>之前考虑 CSMA/CD 协议时，以太网检测到冲突后，会立即中止传输，并发出一个短冲突加强信号，在等待一段随机时间后重发。这里来讨论一下随机时间如何决定。<br>最常用的随机时间决定方法称为<strong>二进制指数后退</strong>。</p><ol><li>首先确定基本退避时间槽，其长度为以太介质上往返传播时间($2𝜏$) ，以太网中设为 $512$ 比特时间</li><li>定义 $k=\min_{}(\text{重传次数},10)$</li><li>从整数集合 $\left{ 0,1 , \ldots ,2^{k}-1 \right}$ 中随机抽出一个数，记为 $r$</li><li>重传所需的时延就是 $r$ 倍的时间槽 $2𝜏$；</li><li>当重传达 $16$ 次仍不能成功时即丢弃该帧，并向高层报告</li></ol><h2 id="数据链路层交换"><a href="#数据链路层交换" class="headerlink" title="数据链路层交换"></a>数据链路层交换</h2><h3 id="数据链路层交换原理"><a href="#数据链路层交换原理" class="headerlink" title="数据链路层交换原理"></a>数据链路层交换原理</h3><h4 id="交换机-网桥-的引入"><a href="#交换机-网桥-的引入" class="headerlink" title="交换机(网桥)的引入"></a>交换机(网桥)的引入</h4><ul><li><strong>冲突域</strong>指的是一个网段，其中可能会有冲突产生。产生冲突的前提就是当有多个使用者共享一个信道，并且同时冲突。</li><li><strong>Hub</strong>是物理层的一个网络连接设备，直接把网线接起来<br><img src='../../figure/计算机网络笔记/介质访问子层/几个冲突域.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></li></ul><p>如果希望上图中的所有电脑都可以相互通信，可以再使用一个Hub将它们全部连接起来，形成一个含有 $12$ 台电脑的冲突域。但是这会让更多的电脑共享信道，会导致：信道利用率下降，出现更大的安全隐患。<br><img src='../../figure/计算机网络笔记/介质访问子层/一个更大的冲突域.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>为了解决这个问题，我们使用数据链路层的交换设备。这个设备称为网桥或者交换机。交换机能够分隔冲突域，同时保证两个冲突域的电脑之间任然能够相互通信。<br><img src='../../figure/计算机网络笔记/介质访问子层/交换机.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>交换机实现功能，核心在于转发表。转发表用于记录某个设备的MAC地址对应于哪个端口。<br><img src='../../figure/计算机网络笔记/介质访问子层/交换机转发表.png' width=250 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="交换机转发表的生成"><a href="#交换机转发表的生成" class="headerlink" title="交换机转发表的生成"></a>交换机转发表的生成</h4><p>理想的网桥是透明的，即插即用，无需用户配置，这就要求交换机需要能够自己生成转发表。</p><p>转发表(MAC地址表)的构建是通过<strong>逆向学习源地址</strong>实现的。比如初始情况下网桥MAC地址表为空，计算机 A 向 B 发送数据，此时交换机就知道计算机 A 的MAC地址对应的端口号。<br><img src='../../figure/计算机网络笔记/介质访问子层/MAC地址表的生成.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></p><p>同时交换机还需要记录帧的到达时间，并且设定老化时间(默认为 $300s$)，当老化时间到期时，该表项就要被清除。这是因为设备可能需要经常插拔，所以转发表也需要经常更新。但如果在清除表项之前，A 电脑又发送了一次数据，则老化时间重置。</p><p>根据上述MAC地址表的生成原理，不难发现可能会溢出。比如某些攻击者使用许多设备向交换机发送信息，交换机就会认为有很多设备接入，从而不断增加MAC地址项，最终导致溢出。</p><h4 id="交换机转发数据帧"><a href="#交换机转发数据帧" class="headerlink" title="交换机转发数据帧"></a>交换机转发数据帧</h4><p>交换机对于入境帧共有转发(forwarding)，过滤(filter)和泛洪(flooding)几种操作。</p><p>假如计算机 B 向 D 发送数据帧，并且此时MAC地址表完整，那么交换机通过查询MAC地址表，发现 B 和 D 对应不同的端口，则即使将接收到的数据帧从 D 对应的端口上<strong>转发</strong>出去。<br><img src='../../figure/计算机网络笔记/介质访问子层/交换机转发.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>假如计算机 B 向 A 发送数据帧，并且此时MAC地址表完整，那么交换机通过查询MAC地址表，发现 B 和 A 对应相同的端口，则交换机将该数据帧丢弃。这种操作称为<strong>过滤</strong>。<br><img src='../../figure/计算机网络笔记/介质访问子层/交换机过滤.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>假如计算机 A 向 B 发送数据帧，但是此时MAC地址表不完整，那么交换机通过查询MAC地址表，发现查找不到 B 的MAC地址对应哪个端口，则交换机会将该数据帧从所有端口(除了入境口)发送出去，保证 B 能够接收到数据。这种操作称为<strong>泛洪</strong>。<br><img src='../../figure/计算机网络笔记/介质访问子层/交换机泛洪.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>同时除了上述查找不到端口的目标MAC地址需要泛洪，<strong>广播帧</strong>也需要泛洪。(广播帧指的是目的地址为FF-FF-FF-FF-FF-FF的数据帧。)</p><h3 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h3><ul><li>传统LAN分段<ul><li>交换机端口通常与集线器连接；</li><li>使用交换机把LAN分段为更小的冲突域。</li></ul></li><li>现代LAN分段<ul><li>直连PC，微分段，创建无冲突域</li></ul></li></ul><p><img src='../../figure/计算机网络笔记/介质访问子层/现代LAN分段.png' width=450 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="市面上的交换机"><a href="#市面上的交换机" class="headerlink" title="市面上的交换机"></a>市面上的交换机</h4><ul><li>执行数据链路层交换算法(通常买到的)<ul><li>多端口透明网桥，网桥的现代名称</li><li>一种即插即用设备</li></ul></li><li>POE（Power Over Ethernet）交换机<ul><li>常接：网络摄像机、AP、IP电话等</li><li>主要优点：无需电源（受电端）、无需专门布线</li></ul></li></ul><h4 id="交换机分类"><a href="#交换机分类" class="headerlink" title="交换机分类"></a>交换机分类</h4><ul><li><p>交换方式：从带宽的角度</p><ul><li>对称交换：出和入的带宽相同。例如：交换机上全为1000Mb/s速率端口</li><li>非对称交换：出和入的带宽不同。例如：交换机上有100Mb/s、1000Mb/s等多种速率端口<br><img src='../../figure/计算机网络笔记/介质访问子层/对称与非对称交换.png' width=450 style="display: block; margin-left: auto; margin-right: auto;"></li></ul></li><li><p>交换模式：从转发时机的角度</p><ul><li>存储转发模式(Store and Forward)：转发前必须接收整个帧、执行CRC校验<ul><li>缺点：延迟大</li><li>优点：不转发出错帧、支持非对称交换</li></ul></li><li>直通模式(Cut-through)：一旦接收到帧的目的地址，就开始转发<ul><li>缺点：可能转发错误帧、不支持非对称交换</li><li>优点：延迟非常小，可以边入边出</li></ul></li><li>无碎片模式(Fragment-free)：接收到帧的前64字节(冲突窗口大小)，即开始转发。(假如收到的帧小于64个字节，那么说明帧不完整，只是一个碎片)<ul><li>缺点：仍可能转发错误帧，不支持非对称交换</li><li>优点：过滤了冲突碎片，延迟和转发错帧介于存储转发和直通交换之间<h3 id="生成树协议"><a href="#生成树协议" class="headerlink" title="生成树协议"></a>生成树协议</h3><h4 id="拓扑冗余导致的问题"><a href="#拓扑冗余导致的问题" class="headerlink" title="拓扑冗余导致的问题"></a>拓扑冗余导致的问题</h4>可靠传输通常需要<strong>冗余拓扑</strong>，但是冗余拓扑可能会导致<strong>物理环路</strong><br><img src='../../figure/计算机网络笔记/介质访问子层/冗余拓扑.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></li></ul></li></ul></li></ul><p>物理环路可能会导致广播风暴、重复帧以及MAC地址表不稳定等问题。</p><p><strong>广播风暴</strong>指交换机在物理环路上不断广播流量，无限循环。<br><img src='../../figure/计算机网络笔记/介质访问子层/广播风暴.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p><strong>重复帧</strong>发生在X发数据给Y，但是此时转发表中还没有Y的MAC地址，此时使用flooding，就会导致Y连续两次接收到同一个帧。<br><img src='../../figure/计算机网络笔记/介质访问子层/重复帧.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>同时当一个帧的多个副本到达不同端口时，交换机会不断修改同一个MAC地址的对应端口，导致<strong>MAC地址表不稳定</strong>。<br><img src='../../figure/计算机网络笔记/介质访问子层/MAC地址表不稳定.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>为了不形成物理环路，我们想到可以生成一棵树。因此引入了生成树算法。</p><h4 id="生成树算法步骤"><a href="#生成树算法步骤" class="headerlink" title="生成树算法步骤"></a>生成树算法步骤</h4><ol><li>选举根桥(Root Bridge)，相当于树的根</li><li>为每个非根桥选出一个根端口(Root Port)</li><li>为每个网段确定一个指定端口(Designated Port)</li></ol><p>选择根桥时，依照交换机的优先级，将优先级小的作为根桥。如果优先级相同，则选其中MAC地址小的。<br><img src='../../figure/计算机网络笔记/介质访问子层/根桥选举.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>有了根桥之后，对于其他交换机，我们考虑这些交换机的哪个端口离交换机更近，近的作为根端口。假如一样近，那么同样选取ID更小的。<br><img src='../../figure/计算机网络笔记/介质访问子层/根端口选举.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>最后要给每一个网段指定端口。指定端口从所有连接到这个网段的交换机端口中选择，我们选择具有最小根路径开销的端口作为指定端口。假如开销相同，则选择ID更小的。<br><img src='../../figure/计算机网络笔记/介质访问子层/指定端口选举.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>最后对于剩下的端口，则进行阻塞。</p><h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><h4 id="广播域"><a href="#广播域" class="headerlink" title="广播域"></a>广播域</h4><p><strong>广播域</strong>指的是广播帧能够到达的范围。在一般情况下，所有交换机都会对广播帧进行flooding，因此交换机能够隔绝冲突域，但是不能隔绝广播域。<br><img src='../../figure/计算机网络笔记/介质访问子层/广播域.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="支持VLAN的交换机"><a href="#支持VLAN的交换机" class="headerlink" title="支持VLAN的交换机"></a>支持VLAN的交换机</h4><p>VLAN即虚拟局域网，一个VLAN就是一个广播域。使用支持VLAN的交换机可以通过划分VLAN来分隔广播域。<br><img src='../../figure/计算机网络笔记/介质访问子层/虚拟局域网.png' width=450 style="display: block; margin-left: auto; margin-right: auto;"></p><p>两个虚拟局域网(VLAN)之间的计算机无法通过数据链路层进行通信，想要通信需要使用路由器或者三层交换机。</p><h4 id="如何实现VLAN"><a href="#如何实现VLAN" class="headerlink" title="如何实现VLAN"></a>如何实现VLAN</h4><ul><li>基于端口的VLAN(最常用)<br><img src='../../figure/计算机网络笔记/介质访问子层/基于端口的VLAN.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></li><li>基于MAC地址的VLAN</li><li>基于协议的VLAN，通常需要服务器的参与</li><li>基于子网的VLAN，一个子网就是一个VLAN</li></ul><p>但是可以看出后面两种方式已经违反了计算机网络的分层架构，这里可以看出计算机网络在理论和实践方面有些不同。</p><h4 id="如何区分不同VLAN的数据帧"><a href="#如何区分不同VLAN的数据帧" class="headerlink" title="如何区分不同VLAN的数据帧"></a>如何区分不同VLAN的数据帧</h4><p>假如在下面这幅图中，灰色的计算机为一个VLAN，白色的计算机属于另一个VLAN。B1和B2分别为两个交换机。<br><img src='../../figure/计算机网络笔记/介质访问子层/区分不同VLAN的数据帧.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>假如左侧一台灰色区域的电脑发送数据帧，该数据帧经由B1传递到了B2，根据传统的情况，B2无法通过端口来判断发送的数据帧具体属于哪个VLAN。因此需要引入新的帧标记标准：IEEE802.1Q。</p><p>为了同时支持带VLAN标记的帧(<strong>标记帧</strong>)和不带VLAN标记的帧(<strong>无标记帧</strong>)，IEEE802.1Q对帧格式做了如下调整：<br><img src='../../figure/计算机网络笔记/介质访问子层/IEEE802.1Q数据帧格式.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>这里相当于增加了一种新的帧格式，对于支持VLAN的交换机，可以识别出该标记；对于不支持的交换机，则相当于接收到了一个不知道类型的数据帧，同样不影响传输。</p><p>支持VLAN的交换机有两种端口：</p><ul><li>Access端口：直接与计算机相连<ul><li>一旦Access端口加入了特定的VLAN，连接在该端口的设备被视为属于该VLAN<br><img src='../../figure/计算机网络笔记/介质访问子层/Access端口.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></li></ul></li><li>Trunk端口：用于交换机之间连接<ul><li>VLAN交换机在Trunk端口输出时，负责对Access端口输入的帧打上VLAN标签。因为VLAN对于计算机用户而言是透明的，计算机属于哪个VLAN由交换机决定，所以计算机发送出的帧没有VLAN标签，交换机最后将数据帧送给计算机时也会将VLAN标签去掉。<br><img src='../../figure/计算机网络笔记/介质访问子层/Trunk端口.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></li></ul></li></ul><h2 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h2><ul><li>对于以太网，数据链路层采用的是乌托邦式的协议，只发送，不确认。</li><li><p>对于无线局域网，数据链路层采用停等式，接收端收到数据之后返回确认帧，发送端如果没有收到确认帧，则重发。同时并不采用pipeline的形式。</p><h3 id="无线局域网组网模式"><a href="#无线局域网组网模式" class="headerlink" title="无线局域网组网模式"></a>无线局域网组网模式</h3><h4 id="基础架构模式"><a href="#基础架构模式" class="headerlink" title="基础架构模式"></a>基础架构模式</h4><div style="text-align: center;"><img src='../../figure/计算机网络笔记/介质访问子层/无线局域组网基础架构模式.png' height=200 style="display: inline-block; margin-right: 10px;"><img src='../../figure/计算机网络笔记/介质访问子层/基础架构模式_AP.png' height=200 style="display: inline-block;"></div></li><li><p>DS：分布式系统</p></li><li>AP：访问点</li><li>STA：站点</li></ul><h4 id="自组织模式-Ad-hoc"><a href="#自组织模式-Ad-hoc" class="headerlink" title="自组织模式(Ad hoc)"></a>自组织模式(Ad hoc)</h4><p><img src='../../figure/计算机网络笔记/介质访问子层/自组织模式.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></p><p>很少使用。</p><h3 id="IEEE802-11介质访问控制"><a href="#IEEE802-11介质访问控制" class="headerlink" title="IEEE802.11介质访问控制"></a>IEEE802.11介质访问控制</h3><h4 id="直接将CSMA-CD用于介质访问控制"><a href="#直接将CSMA-CD用于介质访问控制" class="headerlink" title="直接将CSMA/CD用于介质访问控制"></a>直接将CSMA/CD用于介质访问控制</h4><p>CSMA/CD是以太网的介质访问控制算法，如果直接用于Wifi的话，会产生以下问题：</p><ul><li>隐藏终端问题(Hidden Terminal)</li><li>暴露终端问题(Exposure Terminal)</li></ul><p>隐藏终端问题是因为距离太远，导致站点无法检测到某些竞争者的存在。比如下图中A正在向B传输数据，但是C也要向B传输数据，就会产生冲突，同时又无法检测到。<br><img src='../../figure/计算机网络笔记/介质访问子层/隐藏终端问题.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>暴露终端问题是某些站点侦听到其他站点的发送而误以为信道忙导致不能发送。比如下图中B正在向A传输数据，C要向D发送数据<br><img src='../../figure/计算机网络笔记/介质访问子层/暴露终端问题.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="CSMA-CA-Carrier-Sense-Multiple-Access-with-Collision-Avoid"><a href="#CSMA-CA-Carrier-Sense-Multiple-Access-with-Collision-Avoid" class="headerlink" title="CSMA/CA(Carrier Sense Multiple Access with Collision Avoid)"></a>CSMA/CA(Carrier Sense Multiple Access with Collision Avoid)</h4><ul><li>当信道空闲时间大于IFS（帧间隙），立即传输</li><li>当信道忙时，延迟直到当前传输结束+IFS时间</li><li>开始随机退后过程<ul><li>从（0，CWindow）中选择一个随机数作为退后计数器（backoff counter）</li><li>通过侦听确定每个时间槽是否活动</li><li>如果没有活动，则减少退后时间</li></ul></li><li>退后过程中如果信道忙，则挂起退后过程（解决站点之间的公平问题）</li><li>在当前帧传输结束后恢复退后过程</li></ul><p>下图为一个CSMA/CA的示例。箭头表示有数据要开始传输。蓝色矩形表示站点正在进行倒计数，淡蓝色网格的矩形则表示倒计数剩下的时间。<br><img src='../../figure/计算机网络笔记/介质访问子层/CSMA_CA实例.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>同时需要注意，上图中检查到冲突的方式和以太网不同。CSMA/CA难以直接监测冲突，但是Wifi是有确认的，如果发送端没有收到确认，那么则认为冲突，需要重传数据。</p><h4 id="帧间隙与优先级"><a href="#帧间隙与优先级" class="headerlink" title="帧间隙与优先级"></a>帧间隙与优先级</h4><p>我们注意到，帧间隙的长短可以控制发送端的优先级。</p><ul><li>SIFS（Short IFS）：最高优先级，用于Ack, CTS, 轮询响应等</li><li>PIFS（PCF IFS）：中等优先级（SIFS+1槽口时间），轮询服务</li><li>DIFS（DCF IFS）：最低优先级（ SIFS+2槽口时间），异步数据服务<br><img src='../../figure/计算机网络笔记/介质访问子层/帧间隙控制优先级.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></li></ul><p>因此像ACK这种信令数据就可以有更高的优先级，这样就不会让发送端误判超时。<br><img src='../../figure/计算机网络笔记/介质访问子层/差错检测与确认重传.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="RTS-CTS机制-可选机制"><a href="#RTS-CTS机制-可选机制" class="headerlink" title="RTS-CTS机制(可选机制)"></a>RTS-CTS机制(可选机制)</h4><ul><li>发送端在发送前先发送RTS(request to send)，告诉附近的站点自己需要发送数据。</li><li>接收端在接收到信息之后，会发送CTS(clear to send)，告诉附近的站点自己正在接收数据。</li><li>RTS和CTS中会包含传输的持续时间(Duration)以及发送者、接收者。<br><img src='../../figure/计算机网络笔记/介质访问子层/RTS-CST.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></li></ul><p>附近相关站点能够收到RTS或CTS，来维护NAV(Network Allocation Vector)，实现<strong>虚拟载波监听</strong><br><img src='../../figure/计算机网络笔记/介质访问子层/RTS-CTS机制实例.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>但实际上这种机制默认不使用，因为日常使用很少发生hidden terminal等问题，使用了该机制反而更慢。</p>]]></content>
      
      
      <categories>
          
          <category> computer network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Uncertainty and Probabilistic Reasoning</title>
      <link href="/posts/795e1c16.html"/>
      <url>/posts/795e1c16.html</url>
      
        <content type="html"><![CDATA[<h2 id="Uncertainty"><a href="#Uncertainty" class="headerlink" title="Uncertainty"></a>Uncertainty</h2><p>假如我们定义一个行为(action) $A_t$，表示在航班开始 $t$ 分钟前前往机场，然后想知道执行 $A_t$ 之后是否能够到达机场。相比之前提到的逻辑智能体，显然这里的某个行为并不能得到确切的结果。</p><p>不能得到确切结果的问题在于：</p><ol><li>我们无法感知到所有的相关事件</li><li>观测到的信息可能并不完全准确</li><li>会有一些突发事件</li><li>任务过于复杂，无法建模</li></ol><p>因此存粹的使用逻辑的方法，可能会犯错；如果希望逻辑严密，又会得到很弱的结论(需要进行大量的前提条件)。</p><h3 id="Methods-for-handling-uncertainty"><a href="#Methods-for-handling-uncertainty" class="headerlink" title="Methods for handling uncertainty"></a>Methods for handling uncertainty</h3><ul><li>定义缺省情况下的逻辑，即默认各种罕见情况不会发生</li><li>试图在逻辑中加入模糊因子(fudge factor)。比如：<ul><li>$A<em>{25}\rightarrow </em>{0.3}\text{get there on time}$</li><li>$\text{Sprinkler} \rightarrow _{0.99} \text{WetGrass}$</li><li>$\text{WetGrass} \rightarrow _{0.7} \text{Rain}$</li><li>但是使用这种方法在做逻辑推导的时候可能会导致一些问题。比如按照上述例子，洒水车会导致下雨，这是荒谬的。</li></ul></li></ul><h2 id="Probability"><a href="#Probability" class="headerlink" title="Probability"></a>Probability</h2><p>所以人们最终引入了概率。不过需要注意，这里的“概率”是智能体的一种信念，而不是真实的概率。但是我们任然可以继续使用概率论中的法则对这里的假想概率进行运算。</p><p>用概率的好处在于</p><ul><li>(laziness)我们不需要列出所有意外的情况，减少工作量</li><li>(ingnorance)因为我们有很多不能准确预知的结果，所以使用智能体的信念来表达结果更加合理。<h3 id="Making-decisions-under-uncertainty"><a href="#Making-decisions-under-uncertainty" class="headerlink" title="Making decisions under uncertainty"></a>Making decisions under uncertainty</h3>但是假如只依靠概率的话，又会出现问题。还是以提前出发去机场为例，假如智能体预测结果为：<br>$P(A<em>{25} \text{ gets me there on time} | …) = 0.04$<br>$P(A</em>{90} \text{ gets me there on time} | …) = 0.70$<br>$P(A<em>{120} \text{ gets me there on time} | …) = 0.95$<br>$P(A</em>{1440} \text{ gets me there on time} | …) = 0.9999$</li></ul><p>可以看出提早时间越长，赶上飞机的概率越大。但是一味的提高概率而不考虑代价也是不合理的，所以我们需要引入效用值(utility)。</p><h2 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h2><h3 id="Inference-by-enumeration"><a href="#Inference-by-enumeration" class="headerlink" title="Inference by enumeration"></a>Inference by enumeration</h3><p>通过枚举法进行推理，就是把真值表列出来，然后把符合条件的项相加。<br><img src='../../figure/人工智能笔记/5-Uncertainty/probability_distribution_example.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>比如根据以上的联合概率分布，需要计算牙疼(toothache)的概率：</p><script type="math/tex; mode=display">\operatorname{Pr}(\text{toothache}) = 0.108 + 0.012 + 0.016 + 0.064 = 0.2</script><p>这种方法也可以计算条件概率：</p><script type="math/tex; mode=display">\begin{aligned}\operatorname{Pr}(\lnot \text{cavity}|\text{toothache}) &= \frac{\operatorname{Pr}(\lnot \text{cavity} \land \text{toothache})}{\operatorname{Pr}(\text{toothache})} \\&= \frac{0.016+0.064}{0.108 + 0.012 + 0.016 + 0.064} \\& = 0.4\end{aligned}</script><p><strong>形式化的描述</strong>，就是给定证据变量 $E=e$，想要查询某个变量 $Y$，然后需要把隐藏变量 $H$ 消掉，即：</p><script type="math/tex; mode=display">\operatorname{Pr}(Y|E=e) = \alpha \operatorname{Pr}(Y, E=e) = \alpha \sum_{h} \operatorname{Pr}(Y, E=e, H=h)</script><p>上式中的 $\alpha$ 为归一化变量。比如说：</p><script type="math/tex; mode=display">\begin{aligned}\operatorname{Pr}(\text{Cavity} | \text{toothache}) &= \alpha \operatorname{Pr}(\text{Cavity},\text{toothache}) \\&= \alpha [\operatorname{Pr}(\text{Cavity},\text{toothache},\text{catch}) + \operatorname{Pr}(\text{Cavity},\text{toothache},\lnot \text{catch})] \\&= α [<0.108,0.016> + <0.012,0.064>] \\&= α <0.12,0.08> = <0.6,0.4>\end{aligned}</script><p>(注意上面 Cavity 是随机变量，而 toothache 和 $\lnot$ catch 是确定的取值)。</p><h2 id="Independence-and-Bayes’-Rule"><a href="#Independence-and-Bayes’-Rule" class="headerlink" title="Independence and Bayes’ Rule"></a>Independence and Bayes’ Rule</h2><h3 id="Independence"><a href="#Independence" class="headerlink" title="Independence"></a>Independence</h3><p>随机变量 $A$ 和 $B$ 相互独立，即：$\operatorname{Pr}(A|B)=\operatorname{Pr}(A)$ 或 $\operatorname{Pr}(B|A)=\operatorname{Pr}(B)$ 或 $\operatorname{Pr}(A,B)=\operatorname{Pr}(A)\operatorname{Pr}(B)$。利用独立的条件，能够大大简化真值表的规模。</p><p>假如我们考察以下几个随机变量，其中 Cavity, Toothache, Catch, Weather 的取值分别有 2，2，2，4 个。<br><img src='../../figure/人工智能笔记/5-Uncertainty/independence_example.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>假如 Weather 和其他变量独立，那么真值表的大小就由原来的 $2\times 2\times 2\times 4=32$ 变为现在的 $2\times 2\times 2+4=12$。</p><h3 id="Conditional-independence"><a href="#Conditional-independence" class="headerlink" title="Conditional independence"></a>Conditional independence</h3><p>绝对独立性虽然很好用，但实际情况中绝对独立的随机变量是很少见的，因此这里考虑条件独立。</p><p>随机变量 $A$ 和 $B$ 在 $C$ 的条件下独立，即：$\operatorname{Pr}(AB|C) = \operatorname{Pr}(A|C)\times \operatorname{Pr}(B|C)$，或者 $\operatorname{Pr}(A|C)=\operatorname{Pr}(A|BC)$。上面两个式子等价：</p><script type="math/tex; mode=display">\operatorname{Pr}(A|C) = \operatorname{Pr}(A|BC) = \frac{\operatorname{Pr}(ACB)}{\operatorname{Pr}(BC)} = \frac{\operatorname{Pr}(AB|C)\cdot \operatorname{Pr}(C)}{\operatorname{Pr}(B|C)\cdot P(C)} \\ \Leftrightarrow \operatorname{Pr}(AB|C) = \operatorname{Pr}(A|C)\times \operatorname{Pr}(B|C)</script><p>继续考虑上面的例子。假如有 Toothache, Cavity, Catch 三个变量，在不考虑独立性的情况下，$\operatorname{Pr}(\text{Toothache}, \text{Cavity}, \text{Catch})$ 有 $2^{3}-1=7$ 个独立项。但假如考虑 Toothache 和 Catch 在 Cavity 的条件下独立，那么</p><script type="math/tex; mode=display">\begin{aligned}&\operatorname{Pr}(\text{Toothache}, \text{Catch}, \text{Cavity}) \\&= \operatorname{Pr}(\text{Toothache} | \text{Catch}, \text{Cavity}) \operatorname{Pr}(\text{Catch}, \text{Cavity}) \\&= \operatorname{Pr}(\text{Toothache} | \text{Catch}, \text{Cavity}) \operatorname{Pr}(\text{Catch} | \text{Cavity}) \operatorname{Pr}(\text{Cavity}) \\&= \operatorname{Pr}(\text{Toothache} | \text{Cavity}) \operatorname{Pr}(\text{Catch} | \text{Cavity}) \operatorname{Pr}(\text{Cavity}) \end{aligned}</script><p>总共有 $2+2+1=5$ 个独立项。</p><h3 id="Bayes’-Rule-and-conditional-independence"><a href="#Bayes’-Rule-and-conditional-independence" class="headerlink" title="Bayes’ Rule and conditional independence"></a>Bayes’ Rule and conditional independence</h3><p>朴素贝叶斯(naive Bayes)模型的基本思想就是，在给定了 label 的情况下，各个特征值是相互独立的。<br><img src='../../figure/人工智能笔记/5-Uncertainty/naive_bayes.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><script type="math/tex; mode=display">\operatorname{Pr}(\text{Cause}, \text{Effect}_{1}, \text{Effect}_{2}, \ldots ,\text{Effect}_{n})= \operatorname{Pr}(\text{Cause}) \prod_{i} \operatorname{Pr}(\text{Effect}_{i}|\text{Cause})</script><p>如果再考虑之前的例子，即为：</p><script type="math/tex; mode=display">\begin{aligned}&\operatorname{Pr}(\text{Cavity} | \text{toothache} \land  \text{catch}) \\&= α \operatorname{Pr}(\text{toothache} \land  \text{catch} | \text{Cavity}) \operatorname{Pr}(\text{Cavity}) \\&= α \operatorname{Pr}(\text{toothache} | \text{Cavity}) \operatorname{Pr}(\text{catch} | \text{Cavity}) \operatorname{Pr}(\text{Cavity})\end{aligned}</script><h2 id="Bayesian-networks"><a href="#Bayesian-networks" class="headerlink" title="Bayesian networks"></a>Bayesian networks</h2><p>引入贝叶斯网咯同样是因为 Inference by enumeration 过于繁琐，而朴素贝叶斯的假设又过于理想，因此需要更加强大的工具。</p><p>贝叶斯网络是一种图模型，为有向无环图(DAG)。给出贝叶斯网络之后，就很容易得到条件独立性的关系。想要通过贝叶斯网络得到联合概率分布，可以使用以下公式：</p><script type="math/tex; mode=display">\operatorname{Pr}(X_1, \ldots X_{N}) = \prod_{i} \operatorname{Pr}(X_{i}| Parents(X_{i}))</script><p>例如：<br><img src='../../figure/人工智能笔记/5-Uncertainty/bayesian_network_example.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="Local-Structures-amp-Independencies"><a href="#Local-Structures-amp-Independencies" class="headerlink" title="Local Structures &amp; Independencies"></a>Local Structures &amp; Independencies</h3><p>然后分析贝叶斯网络中的几种独立关系。独立关系的分析是从公式 $\operatorname{Pr}(X<em>1, \ldots X</em>{N}) = \prod<em>{i} \operatorname{Pr}(X</em>{i}| Parents(X_{i}))$ 以及概率论中的链式法则出发。<br><img src='../../figure/人工智能笔记/5-Uncertainty/conditional-independence_semantics.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><p>下面用一个例子直观的解释以上的独立性与条件独立性。</p><p>对于左边的情况，即给定 $B$，$A,C$ 独立(B decouples A and C)。考虑这种情形：<br><img src='../../figure/人工智能笔记/5-Uncertainty/cascade.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>本来是智商影响成绩，成绩影响推荐信，所以智商越高，得到推荐信的概率越大。但是当成绩已经出来了之后，智商就无法间接影响推荐信了。</p><p>对于中间的情况，即给定 $B$，$A,C$ 独立(B decouples A and C)。考虑这种情形：<br><img src='../../figure/人工智能笔记/5-Uncertainty/common_parent.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>本身课程的成绩和SAT的成绩有关联，就是因为两者都是由智商决定，一般一个分数高，另一个分数也高。但是当智商已知，两者就无关了。</p><p>对于右边的情况，即给定 $C$，$A,B$ 相关(C couples A and B)。考虑这种情形：<br><img src='../../figure/人工智能笔记/5-Uncertainty/v_structures.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>本身考试难度和一个人的智商无关。但是假如已知分数，比如一个同学考试分数很低，那么我们就可以用难度和智商相互推断，比如当我们知道这个同学智商很高，就可以推断考试很难。</p><h3 id="Bayes-Nets-Inference"><a href="#Bayes-Nets-Inference" class="headerlink" title="Bayes Nets Inference"></a>Bayes Nets Inference</h3><p>对于图模型来说，有三个主要的问题</p><ul><li>表征(representation)。贝叶斯网络本身就是表征了相关性的信息。</li><li>推断(Inference)。给出一系列的询问(query)，希望得到回答。</li><li>学习(learing)。比如贝叶斯学习和朴素贝叶斯分类器。贝叶斯学习就是从贝叶斯推理中拓展出来的。</li></ul><h3 id="Queries"><a href="#Queries" class="headerlink" title="Queries"></a>Queries</h3><ul><li><p>推理查询(inferential query)1：可能性(Likelihood)<br>就是计算某个确定事件发生的概率。(What is the probability of evidence?)</p><script type="math/tex; mode=display">\operatorname{Pr}(x_{v}) = \sum_{x_{H}}\operatorname{Pr}(X_{H},X_{v})=\sum_{x_1}\cdots \sum_{x_{k}}\operatorname{Pr}(x_1, \ldots ,x_k, x_v)</script></li><li><p>推理查询2：条件概率(Conditional Probability)</p><script type="math/tex; mode=display">\operatorname{Pr}(Y|x_{V})= \sum_{z}P(Y,Z=z|x_{V})</script></li><li><p>推理查询3：最有可能的指派(Most Probable Assignment)<br>即考虑那种结果可能性是最大的。这个查询和2不同之处在于这里不需要精确求出概率，只需要进行比较即可。</p></li></ul><h2 id="Approaches-to-Inference"><a href="#Approaches-to-Inference" class="headerlink" title="Approaches to Inference"></a>Approaches to Inference</h2><p>假如有了一个贝叶斯网络，已知一些先验概率和条件概率，需要求出未知的一些概率值，这就需要一些推断方式。</p><h3 id="Example-A-Bayesian-Network"><a href="#Example-A-Bayesian-Network" class="headerlink" title="Example: A Bayesian Network"></a>Example: A Bayesian Network</h3><p>假如有一个食物网，我们希望知道当草的条件不好时老鹰离开的概率。即求出 $P(A|H=h)$<br><img src='../../figure/人工智能笔记/5-Uncertainty/example_for_bayesian_network.png' width=450 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="Inference-on-General-BN-via-Variable-Elimination"><a href="#Inference-on-General-BN-via-Variable-Elimination" class="headerlink" title="Inference on General BN via Variable Elimination"></a>Inference on General BN via Variable Elimination</h3><p>想要求条件概率分布，可以先求出联合概率分布，然后再将无关的变量做边缘化。即：</p><script type="math/tex; mode=display">\operatorname{Pr}(X_1,e) = \sum_{x_n}\sum_{x_3}\sum_{x_2}\prod_{i} \operatorname{Pr}(x_i|pa_{i})</script><p>但无疑直接计算是非常复杂的。因此我们需要采用和乘法分配律类似的方法。比如上式在对 $x_2$ 求和时，可以先将所有无关项提出，就能大大简化加法计算。</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>我们以前面提到的食物网为例，展示计算过程</p><ul><li>此时的查询(query)为 $\operatorname{Pr}(A|h)$，因此需要消掉 $B,C,D,E,F,G,H$。</li><li>已知条件为 $\operatorname{Pr}(a), \operatorname{Pr}(b), \operatorname{Pr}(c|b), \operatorname{Pr}(d|a), \operatorname{Pr}(e|c,d), \operatorname{Pr}(f|a), \operatorname{Pr}(g|e), \operatorname{Pr}(h|e,f)$。</li><li>然后需要选择一个消除(Elimination)的顺序。</li></ul><ol><li><p>首先消除 $H$。记</p><script type="math/tex; mode=display">m_{h}(e,f)=\operatorname{Pr}(h=\tilde{h}|e,f) = \sum_{h} \operatorname{Pr}(h|e,f)\delta(h=\tilde{h})</script><p>则计算式：</p><script type="math/tex; mode=display">\operatorname{Pr}(a) \operatorname{Pr}(b) \operatorname{Pr}(c|b) \operatorname{Pr}(d|a) \operatorname{Pr}(e|c,d) \operatorname{Pr}(f|a) \operatorname{Pr}(g|e) \operatorname{Pr}(h|e,f) \\ \Rightarrow \operatorname{Pr}(a) \operatorname{Pr}(b) \operatorname{Pr}(c|b) \operatorname{Pr}(d|a) \operatorname{Pr}(e|c,d) \operatorname{Pr}(f|a) \operatorname{Pr}(g|e) m_{h}(e,f)</script></li><li><p>消除 $G$</p><script type="math/tex; mode=display">m_{g}(e) = \sum_{g}\operatorname{Pr}(g|e)=1</script><script type="math/tex; mode=display">\operatorname{Pr}(a) \operatorname{Pr}(b) \operatorname{Pr}(c|b) \operatorname{Pr}(d|a) \operatorname{Pr}(e|c,d) \operatorname{Pr}(f|a) \operatorname{Pr}(g|e) m_{h}(e,f) \\\Rightarrow \operatorname{Pr}(a) \operatorname{Pr}(b) \operatorname{Pr}(c|b) \operatorname{Pr}(d|a) \operatorname{Pr}(e|c,d) \operatorname{Pr}(f|a) m_{h}(e,f)</script></li><li><p>消除 $F$</p><script type="math/tex; mode=display">m_{f}(e,a)= \sum_{f}\operatorname{Pr}(f|a)m_{h}(e,f)</script><script type="math/tex; mode=display">\operatorname{Pr}(a) \operatorname{Pr}(b) \operatorname{Pr}(c|b) \operatorname{Pr}(d|a) \operatorname{Pr}(e|c,d) \operatorname{Pr}(f|a) m_{h}(e,f) \\\Rightarrow \operatorname{Pr}(a) \operatorname{Pr}(b) \operatorname{Pr}(c|b) \operatorname{Pr}(d|a) \operatorname{Pr}(e|c,d) m_{f}(e,a)</script><p>……</p></li></ol><p>最后总结一下总体消除流程：</p><script type="math/tex; mode=display">\begin{aligned}& \operatorname{Pr}(e|c,d) \operatorname{Pr}(f|a) \operatorname{Pr}(g|e) \operatorname{Pr}(h|e,f) \\ &\Rightarrow \operatorname{Pr}(a) \operatorname{Pr}(b) \operatorname{Pr}(c|b) \operatorname{Pr}(d|a) \operatorname{Pr}(e|c,d) \operatorname{Pr}(f|a) \operatorname{Pr}(g|e) m_{h}(e,f) \\&\Rightarrow\operatorname{Pr}(a) \operatorname{Pr}(b) \operatorname{Pr}(c|b) \operatorname{Pr}(d|a) \operatorname{Pr}(e|c,d) \operatorname{Pr}(f|a) m_{h}(e,f) \\& \Rightarrow \operatorname{Pr}(a) \operatorname{Pr}(b) \operatorname{Pr}(c|b) \operatorname{Pr}(d|a) \operatorname{Pr}(e|c,d) m_{f}(e,a) \\&\Rightarrow\operatorname{Pr}(a) \operatorname{Pr}(b) \operatorname{Pr}(c|b) \operatorname{Pr}(d|a) m_{e}(a,c,d) \\&\Rightarrow\operatorname{Pr}(a) \operatorname{Pr}(b) \operatorname{Pr}(c|b) m_{d}(a,c) \\&\Rightarrow \operatorname{Pr}(a) \operatorname{Pr}(b) m_{c}(a,b) \\&\Rightarrow\operatorname{Pr}(a)m_{b}(a)\end{aligned}</script><p>最后计算结果：</p><script type="math/tex; mode=display">\operatorname{Pr}(a|\tilde{h}) = \frac{\operatorname{Pr}(a)m_{b}(a)}{\sum_{a}\operatorname{Pr}(a)m_{b}(a)}</script><h4 id="Computational-and-Space-Complexity"><a href="#Computational-and-Space-Complexity" class="headerlink" title="Computational and Space Complexity"></a>Computational and Space Complexity</h4><p>主要的操作是乘法和加法，具体的复杂度和化简每一项的复杂度，因此消除的顺序非常重要。但是我们又没有办法找到最优的消元顺序，所以复杂度不可控。</p><h3 id="Bayes-Nets-Sampling"><a href="#Bayes-Nets-Sampling" class="headerlink" title="Bayes Nets Sampling"></a>Bayes Nets Sampling</h3><p>当一个网络过于复杂，难以计算，我们就可以通过采样的方式进行估计。</p><p>考虑一种最简单的情况，红、绿、蓝三种方块出现的概率为 $0.6, 0.1, 0.3$。那么我们进行采样，比如让数字 $u$ 在 $[0,1)$ 之间取值，假如 $u\in [0,0.6)$ 为红色，$u\in [0.6,0.7)$，为绿色，$u\in [0.7,1)$ 为蓝色。经过多次采样，我们可能得到如下结果：<br><img src='../../figure/人工智能笔记/5-Uncertainty/sampling_example.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>那么我们就可以通过采样得到方块的数量来估计概率。</p><h4 id="Prior-Sampling"><a href="#Prior-Sampling" class="headerlink" title="Prior Sampling"></a>Prior Sampling</h4><p>先验采样，最简单的采样方式。就是按照贝叶斯网络，从上往下采样。<br><img src='../../figure/人工智能笔记/5-Uncertainty/prior_sampling.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>以下图为例：<br><img src='../../figure/人工智能笔记/5-Uncertainty/prior_sampling_example.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>我们首先从 Cloudy 开始采样，假设为真(用绿色表示)。然后根据 Cloudy 为真的结果，采样子节点 Sprinkler 和 Rain，这两个子节点采样时就基于父节点为真的条件。最后再采样 Wet Grass。</p><p>最后计算概率时，就是计算贝叶斯网络的联合概率分布。</p><script type="math/tex; mode=display">S_{PS}(x_1, \ldots x_n) = \prod_{i=1}^{n} \operatorname{Pr}(x_i|Parent(X_{i})) = \operatorname{Pr}(x_1, \ldots x_n)</script><p>最终分布的估算为：</p><script type="math/tex; mode=display">\begin{aligned}\operatorname*{lim}_{N\to\infty}\hat{\operatorname{Pr}}(x_{1},\ldots,x_{n})& =\operatorname*{lim}_{N\to\infty}N_{PS}(x_{1},\ldots,x_{n})/N  \\&=S_{PS}(x_{1},\ldots,x_{n}) \\&=\operatorname{Pr}(x_{1}\ldots x_{n})\end{aligned}</script><h4 id="Rejection-Sampling"><a href="#Rejection-Sampling" class="headerlink" title="Rejection Sampling"></a>Rejection Sampling</h4><p>我们注意到先验采样完全忽略了证据变量的取值，而是完全随机，因此有很多样本时不符合条件的。拒绝采样则是在采样后将这些不符合条件的采样丢弃。比如说我们现在需要估计：$\operatorname{Pr}(Rain|Sprinkler =true)$，总共采了 $100$ 个样本，其中有 $27$ 个满足 $Sprinkler =true$，那么我们则只用这些样本来计算。</p><p>因此拒绝采样主要用来估计条件概率，而上面的先验采样计算的是联合概率。</p><h4 id="Likelihood-Weighting"><a href="#Likelihood-Weighting" class="headerlink" title="Likelihood Weighting"></a>Likelihood Weighting</h4><p>但是我们发现，假如证据变量的概率非常低，那么就会有大量的样本被丢弃，也就是说很多采样是无效的，这导致采样效率低下。所以这里引入似然加权采样。</p><p>似然加权采样的思路是固定证据变量的取值，只对非证据变量采样，然后根据采样的结果与证据变量的一致程度对每个样本进行加权。<br><img src='../../figure/人工智能笔记/5-Uncertainty/likelihood_weighting_sampling.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>以下图为例，此时证据变量 Sprinkler 和 Wet Grass 都为真。<br><img src='../../figure/人工智能笔记/5-Uncertainty/likelihood_weighting_sampling_example.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>首先从 Cloudy 开始采样，假设为真。然后考虑子节点 Sprinkler，该节点为证据节点，因此直接赋值为真，同时 $w=w<em>0.1$。再对 Rain 进行采样。最后考虑 Wet Grass，这个子节点同样为证据节点，直接赋值为真，$w=w</em>0.99$。整个流程结束后，返回各个随机变量取到的值，以及 $w=0.099$。</p><p>似然加权采样最终给出的就是条件概率：</p><script type="math/tex; mode=display">\begin{aligned}S_\text{WS}{ ( z , e ) }\cdot w(z,e)& =\prod_{i=1}^l\operatorname{Pr}(z_i|\text{Parents}(z_i))\prod_{i=1}^m\operatorname{Pr}(e_i|\text{Parents}(e_i))  \\&=\operatorname{Pr}(\mathbf{z},\mathbf{e})\end{aligned}</script><h4 id="Approximate-inference-using-MCMC"><a href="#Approximate-inference-using-MCMC" class="headerlink" title="Approximate inference using MCMC"></a>Approximate inference using MCMC</h4><p>似然加权采样虽然主动考虑了证据变量，但是采样时证据变量只能影响子节点的采样，而不能影响父节点。但是假如有一组父子节点，子节点为证据变量 $E=e$，但是父节点的某些取值 $H=h$ 有 $\operatorname{Pr}(e|h)$ 很小，那么这些采样的权重就很小，也属于作用不大的采样。这里我们引入马尔可夫采样。</p><p>与前面的采样方式不同的是，马尔可夫采样不是从父节点到子节点一个一个采样，而是先给所有变量赋值，得到一个样本，然后再对这个样本进行改造。下面是该采样算法的伪代码：<br><img src='../../figure/人工智能笔记/5-Uncertainty/MCMC_sampling.png' width=700 style="display: block; margin-left: auto; margin-right: auto;"></p><h5 id="Markov-blanket"><a href="#Markov-blanket" class="headerlink" title="Markov blanket"></a>Markov blanket</h5><p>代码中 $mb(Z_i)$ 指的是 $Z_i$ 变量的马尔可夫毯。其中一个节点的马尔可夫毯包含了它的父节点，子节点和子节点的 co-parent。<br><img src='../../figure/人工智能笔记/5-Uncertainty/markov_blanket.png' width=250 style="display: block; margin-left: auto; margin-right: auto;"></p><p>这里引入马尔可夫毯，是因为贝叶斯网络有一些性质，使得非马尔可夫毯的变量和该变量无关。这是因为我们在分析条件概率的时候，假如给定所有其他节点：</p><script type="math/tex; mode=display">\operatorname{Pr}(x_i|x_{j\neq i}) = \frac{\operatorname{Pr}(x_1, \ldots ,x_{D})}{\int \operatorname{Pr}(x_1, \ldots ,x_{D}) \mathrm{d} x_i} = \frac{\prod_{k} \operatorname{Pr}(x_k|pa_{k}) }{\int \prod_{k} \operatorname{Pr}(x_{k}|pa_{k})\mathrm{d}x_i}</script><p>观察上式，分母中有些项可以移出积分，那么将一些公共因子约掉。而不能从积分中提出的项有这么几种类型：$\operatorname{Pr}(_|x<em>i), \operatorname{Pr}(x_i|\</em>), \operatorname{Pr}(_|x<em>i,\</em>)$，对应的就是马尔可夫毯中的变量。</p><h5 id="The-Markov-chain"><a href="#The-Markov-chain" class="headerlink" title="The Markov chain"></a>The Markov chain</h5><p>继续考虑之前的例子。考虑当 Sprinkler=true, WetGrass=true 时的条件概率，变量的赋值共有下图的四种状态<br><img src='../../figure/人工智能笔记/5-Uncertainty/the_markov_chain.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"> </p><p>可以证明，经过足够多次采样，这几个状态的转移最终会达到稳态分布，同时在每个状态上停留的时间(也就是采样到的概率)和实际的概率是一致的。</p><p>比如采样 $100$ 次之后，有 $31$ 次 Rain=true，$69$ 次 Rain=false，那么 $\hat{\operatorname{Pr}}(Rain|Sprinkler=true, WetGrass=true)=<0.31,0.69>$</p>]]></content>
      
      
      <categories>
          
          <category> artificial intelligence </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Logical Agents</title>
      <link href="/posts/feee944d.html"/>
      <url>/posts/feee944d.html</url>
      
        <content type="html"><![CDATA[<h2 id="Knowledge-based-agents"><a href="#Knowledge-based-agents" class="headerlink" title="Knowledge-based agents"></a>Knowledge-based agents</h2><h3 id="Knowledge-Bases"><a href="#Knowledge-Bases" class="headerlink" title="Knowledge Bases"></a>Knowledge Bases</h3><p><img src='../../figure/人工智能笔记/4-Logical-Agents/knowledge_bases.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>在逻辑智能体中，知识库就是一系列的形式语言，我们告诉智能体可以怎么做，然后智能体就能依照我们提供的指示，从知识库中推导出新的知识。</p><h3 id="Logical-Agents"><a href="#Logical-Agents" class="headerlink" title="Logical Agents"></a>Logical Agents</h3><p>和CSP相比，逻辑智能体存放的内容更加复杂，形式更加丰富(命题逻辑、谓词逻辑)。<br><img src='../../figure/人工智能笔记/4-Logical-Agents/logical_agents.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>比如告诉一个逻辑智能体以下信息：</p><ul><li>事实(facts)：<ul><li>草是绿的</li><li>天是蓝的</li></ul></li><li>规则(rule)：<ul><li>吃太多糖果会生病</li><li>生病了就不用去学校</li></ul></li><li>观测条件(percepts and actions)：<ul><li>pat今天吃了很多糖果</li></ul></li></ul><p>智能体会推出结论：pat今天不用去学校</p><p><img src='../../figure/人工智能笔记/4-Logical-Agents/pseudo_code_for_KB_agent.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><h2 id="Wumpus-world"><a href="#Wumpus-world" class="headerlink" title="Wumpus world"></a>Wumpus world</h2><p><img src='../../figure/人工智能笔记/4-Logical-Agents/wumpus_world.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>想要让逻辑智能体解决这个问题，我们首先要将问题形式化。</p><h2 id="Logic-in-general-models-and-entailment"><a href="#Logic-in-general-models-and-entailment" class="headerlink" title="Logic in general - models and entailment"></a>Logic in general - models and entailment</h2><ul><li>逻辑语句(logics)就是包含了能够推出结论的信息的形式化语句(formal language)。</li><li>语法(syntax)定义了一个句子(sentence)应当是怎样的</li><li>语义(semantics)定义了句子的是真还是假(meaning)</li></ul><h3 id="Entailment"><a href="#Entailment" class="headerlink" title="Entailment"></a>Entailment</h3><p>逻辑蕴含(entailment)指的是一者能够推出另一者</p><script type="math/tex; mode=display">KB \models \alpha</script><p>这里是知识库KB蕴含 $\alpha$，即假如KB为真，那么 $\alpha$ 一定为真。逻辑蕴含关系能够让智能体得到新知识。</p><h3 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h3><p>我们说 $m$ 是关于句子 $\alpha$ 的一个模型，也就是说在 $m$ 的条件下 $\alpha$ 为真。我们用 $M(\alpha)$ 表示 $\alpha$ 所有模型的集合。因此 $KB \models \alpha$ 等价于</p><script type="math/tex; mode=display">M(KB) \subseteq M(\alpha)</script><p><img src='../../figure/人工智能笔记/4-Logical-Agents/models.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></p><p>下面演示通过模型检验的方式进行逻辑推导，以前面的Wumpus world游戏为例。假如玩家已经探索了(1, 1)和(2, 1)坐标，然后可以列出所有可能的模型，再根据KB中的规则得到 $M(KB)$<br><img src='../../figure/人工智能笔记/4-Logical-Agents/wumpus_world_kb.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>然后记语句 $\alpha_1$ 为“[1, 2]是安全的”，可以得到 $M(\alpha_1)$ 如下：<br><img src='../../figure/人工智能笔记/4-Logical-Agents/wumpus_world_alpha1.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>可以看出 $KB \models \alpha_1$，所以 $\alpha_1$ 为真。但是如果记 $\alpha_2$ 为“[2, 2]是安全的”，那么得到 $M(\alpha_2)$ 如下：<br><img src='../../figure/人工智能笔记/4-Logical-Agents/wumpus_world_alpha2.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>可以看出无法得到 $\alpha_2$ 为真。</p><h3 id="Wumpus-world-sentence"><a href="#Wumpus-world-sentence" class="headerlink" title="Wumpus world sentence"></a>Wumpus world sentence</h3><p>假如想要使用推导的话，需要将这个游戏形式化。</p><ul><li>令 $P_{ij}$ 为真表示 $(i,j)$ 点上有陷阱</li><li>令 $B_{ij}$ 为真表示 $(i,j)$ 点有微风</li></ul><p>假如此时玩家探索了 $(1, 1)$ 坐标和 $(1, 2)$ 坐标，那么可以得到知识：$\neg P<em>{1, 1}, \neg B</em>{1, 1}, B<em>{2, 1}$。根据规则：“陷阱的周围有微风”，可以得到 $B</em>{1, 1}\Leftrightarrow (P<em>{1, 2} \lor P</em>{2,1}), B<em>{2, 1}\Leftrightarrow (P</em>{1, 1}\lor P<em>{2, 2} \lor P</em>{3,1})$</p><h2 id="Inference-rules-and-theorem-proving"><a href="#Inference-rules-and-theorem-proving" class="headerlink" title="Inference rules and theorem proving"></a>Inference rules and theorem proving</h2><h3 id="resolution"><a href="#resolution" class="headerlink" title="resolution"></a>resolution</h3><p>归结法的推导：<br>对于两个CNF $l<em>1 \lor  \cdots \lor l_k，m_1 \lor \cdots \lor m_n$，假如存在 $l_i$ 和 $m_j$ 互补，那么就归结出 $l_1 \lor  \cdots \lor  l</em>{i-1} \lor l<em>{i+1} \lor \cdots \lor \cdots l_k \lor  m_1 \lor \cdots \lor m</em>{j-1} \lor m_{j+1} \lor  \cdots  \lor  m_n$</p><p>也就是说想要使用归结法，要首先将逻辑表达式变成合取范式。</p><h4 id="Resolution-algorithm"><a href="#Resolution-algorithm" class="headerlink" title="Resolution algorithm"></a>Resolution algorithm</h4><p>使用归结法实际上是在使用反证法。假如我们希望证明 $KB \Rightarrow \alpha$，那么需要证明 $KB \land  \lnot \alpha$ 是不可满足的。</p><p>于是我们将 $KB$ 给出的条件转化为合取范式(CNF)，同时将 $\lnot \alpha$ 也一起放入，假如经过归结，发现得到空集，这就说明 $KB \land  \lnot \alpha$ 不可满足，$KB \Rightarrow \alpha$。</p><h3 id="Horn-Form"><a href="#Horn-Form" class="headerlink" title="Horn Form"></a>Horn Form</h3><p>霍恩子句是一种更加严格的子句。在前面我们提到需要将 $KB$ 化为合取范式，而假如其中的子句满足至多有一个变量为正(positive)，那么该子句就是霍恩子句。比如：$\lnot L<em>{1,1} \lor \lnot Breeze \lor B</em>{1,1}$。</p><p>使用霍恩子句是为了让子句更方便地变成肯定前件式，便于推导，比如<br>$\lnot L<em>{1,1} \lor \lnot Breeze \lor B</em>{1,1} \Leftrightarrow L<em>{1,1} \land  Breeze \rightarrow B</em>{1,1}$ </p><h3 id="forward-chaining"><a href="#forward-chaining" class="headerlink" title="forward chaining"></a>forward chaining</h3><p>就是利用肯定前件式直接往后推，比如这个例子，就是在知道A,B的前提下，一步一步推导出其他条件<br><img src='../../figure/人工智能笔记/4-Logical-Agents/forward_chaining.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="backward-chaining"><a href="#backward-chaining" class="headerlink" title="backward chaining"></a>backward chaining</h3><p>将forward的顺序反过来，思路为：我们需要一个条件，然后看实现这个条件还需要什么其他条件，以此类推往前追溯。<br><img src='../../figure/人工智能笔记/4-Logical-Agents/backward_chaining.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>上面就是一个backwards chaining的例子。</p>]]></content>
      
      
      <categories>
          
          <category> artificial intelligence </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Constraint Satisfaction Problems</title>
      <link href="/posts/fd6da8cd.html"/>
      <url>/posts/fd6da8cd.html</url>
      
        <content type="html"><![CDATA[<p>最开始的人工智能做的都是search，而之后的机器学习才开始做inference，会自己学习知识。而CSP问题则介于两者之间，它会把inference的思路融入到search中，这是人工智能的一大进步，智能体在搜索的时候会进行思考。</p><h2 id="Constraint-Satisfaction-Problems-CSP"><a href="#Constraint-Satisfaction-Problems-CSP" class="headerlink" title="Constraint Satisfaction Problems(CSP)"></a>Constraint Satisfaction Problems(CSP)</h2><h3 id="What-is-Search-For"><a href="#What-is-Search-For" class="headerlink" title="What is Search For?"></a>What is Search For?</h3><ul><li>一种问题是寻找路径，即一系列行动。</li><li>另一种是识别，识别最终的目标状态，路径则不重要。</li></ul><p>这里的目标满足问题(CSP)主要关心识别的问题，即只关心最终状态，不关心路径。</p><h3 id="State-Representation"><a href="#State-Representation" class="headerlink" title="State Representation"></a>State Representation</h3><p><img src='../../figure/人工智能笔记/3-Constraint-Satisfaction-Problems/state_representation.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>对于CSP问题</p><ul><li>一个状态由一系列变量 $X_{i}(i=1, 2, \ldots n)$ 的集合构成，值域为 $D_i$</li><li>目标测试由一系列约束 $C_i(i=1, 2, \ldots m)$ 来决定。</li></ul><p>CSP问题相较于之前搜索算法的进步：</p><ul><li>原子状态(atomic state) $\rightarrow$ (factored state)</li><li>搜索(search) $\rightarrow$ 搜索+推断(inference)</li><li>特定算法(specific) $\rightarrow$ 通用算法(general)<ul><li>搜索问题对于每个问题都需要根据问题进行设计，而CSP问题则有一些通用的算法，只要问题能够建模成CSP问题，就能用特定的算法解决。</li></ul></li></ul><h3 id="Example-Map-Coloring"><a href="#Example-Map-Coloring" class="headerlink" title="Example: Map-Coloring"></a>Example: Map-Coloring</h3><p><img src='../../figure/人工智能笔记/3-Constraint-Satisfaction-Problems/map_coloring.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><ul><li>变量：WA，NT，Q，NSW，V，SA，T</li><li>定义域：$D_i$ = {red, green, blue}</li><li>约束：相邻区域必须颜色不同</li></ul><p>将其抽象成一个约束满足问题：<br><img src='../../figure/人工智能笔记/3-Constraint-Satisfaction-Problems/constraint_graph.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></p><p>一个节点对应一个变量，一条边对应一个约束。</p><p>把这个问题当成约束满足问题，相比最简单的搜索问题，一个优势是可以减小搜索空间，加快搜索。</p><h3 id="Varieties-of-CSPs"><a href="#Varieties-of-CSPs" class="headerlink" title="Varieties of CSPs"></a>Varieties of CSPs</h3><ul><li>变量取离散值<ul><li>有限域，假如有 $n$ 个变量，$d$ 种取值，那么会有 $O(d^{n})$ 种选择</li><li>无限域，那么就需要一些约束条件</li></ul></li><li>连续变量<ul><li>有各种约束和优先级，可能用线性规划来解决</li></ul></li></ul><h3 id="Standard-search-formulation-incremental"><a href="#Standard-search-formulation-incremental" class="headerlink" title="Standard search formulation (incremental)"></a>Standard search formulation (incremental)</h3><p>对于所有的约束满足问题，初始状态、目标测试和后继函数都可以进行统一的定义</p><ul><li>初始状态：空的指派</li><li>后继函数：选择一个还未赋值变量对其进行控制</li><li>目标测试：看所有变量的赋值有没有冲突</li></ul><h2 id="Backtracking-Search"><a href="#Backtracking-Search" class="headerlink" title="Backtracking Search"></a>Backtracking Search</h2><p>回溯搜索本质上也是一种深度优先搜索，我们把用于约束满足问题的单变量赋值的深度优先搜索称为回溯搜索。回溯搜索是一种没有信息指导的搜索，只需要在每个节点考虑单变量的赋值。</p><h3 id="Two-improvements"><a href="#Two-improvements" class="headerlink" title="Two improvements"></a>Two improvements</h3><ul><li>每次只考虑一个变量的赋值，并且变量的赋值是可交换的(即赋值的顺序不影响最终结果)</li><li>每一次赋值之后需要检查是否满足目标</li></ul><p>搜索树越深，已经赋值的变量越多，需要检查的约束也越多。</p><p>地图染色的例子如下<br><img src='../../figure/人工智能笔记/3-Constraint-Satisfaction-Problems/backtracking_example.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="Pseudo-code"><a href="#Pseudo-code" class="headerlink" title="Pseudo code"></a>Pseudo code</h3><p><img src='../../figure/人工智能笔记/3-Constraint-Satisfaction-Problems/backtracking_search_pseudo_code.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><p>其中 $\text{SELECT-UNASSIGNED-VARIANBLE}(\text{VARIABLE}[csp], assignment, csp)$ 和 $\text{for each } value \text{ in ORDER-DOMAINJ-VALUES}(VAR, assignemnt, csp)$ 这两点都非常重要，选择策略是否合适会影响算法的效率。</p><p>改进回溯算法，就是需要改进这两个选择的函数。</p><h3 id="Improving-backtracking-efficiency"><a href="#Improving-backtracking-efficiency" class="headerlink" title="Improving backtracking efficiency"></a>Improving backtracking efficiency</h3><p>对于<strong>变量的选择</strong>：</p><ol><li>首先可以选择约束比较多的变量(most constrained variable)，比如说做数独的时候通常先填那些基本已经确定的，因为此时这个变量能够选择的空间就比较小。(minimum remaining values heuristic)</li><li>其次可以选择对其他变量影响最多的(most constraining variable, Tie-breaker)，即选择那些在约束条件中出现次数最多的。比如说地图染色中，我们会倾向于选择中间的点开始染色。</li></ol><p>以上操作相当于做剪枝</p><p>对于<strong>变量的赋值</strong>：<br>选择对其他变量影响最少的(least constraining value)。<br><img src='../../figure/人工智能笔记/3-Constraint-Satisfaction-Problems/least_constraining_value.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><p>比如说上面这个地图染色的例子中，假如按照上面那种方法进行染色，就有更大的概率继续给后面的变量赋值，也就更有可能找到最终的解。</p><p>以上的操作是让当前道路找到满足条件解的成功率更高。</p><h2 id="Interleaving-search-and-inference"><a href="#Interleaving-search-and-inference" class="headerlink" title="Interleaving search and inference"></a>Interleaving search and inference</h2><p>除了以上两步的改进，还可以进行进一步的算法优化，即将搜索(search)和推理(inference)结合起来。这里的推理比较简单，就是进行约束的传播。</p><p>注：机器学习中的inference和传统人工智能的inference有所差异。机器学习中指的主要是一个推断预测的过程；而在经典的人工智能中，则是做知识的推断。比如在CSP中，inference就是要推出一些新的约束，这些新的约束就可以看成新的知识，加入到知识库中。</p><h3 id="Forward-checking"><a href="#Forward-checking" class="headerlink" title="Forward checking"></a>Forward checking</h3><p>就是要追踪没有被赋值过的变量所有剩下的取值，当发现有变量没有合法的取值的时候，就停止此次搜索。</p><p>下图是地图染色的例子，每次染色之后考虑邻居的取值范围的改变。这是一种简单的追踪。<br><img src='../../figure/人工智能笔记/3-Constraint-Satisfaction-Problems/forward_checking_example.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>可以看出我们此时需要一个新的数据结构来存储信息。所以Forward checking相当于首次在search中加入了inference。</p><p>但是前向检查仍有不足，因为它只更新了邻居的情况。比如像上面例子的第三行，NT和SA的选择都只剩蓝色，但是它们又都是邻居，此时应当已经可以结束搜索，而前向搜索不能解决这个问题。所以还需要对算法进行进一步改进。</p><h3 id="AC-3-algorithm"><a href="#AC-3-algorithm" class="headerlink" title="AC-3 algorithm"></a>AC-3 algorithm</h3><h4 id="Arc-consistency"><a href="#Arc-consistency" class="headerlink" title="Arc consistency"></a>Arc consistency</h4><p>弧(Arc)：这里指从某一个变量到另一个变量的一条边，是有方向的。</p><p>弧 $X \rightarrow Y$ 是一致的，当且仅当对于 $X$ 的每个取值 $x$，变量 $Y$ 都能找到某个取值 $y$ 使其满足约束。</p><p>比如下图中，从SA到NSW有一条弧，那么对于SA中的每一个取值(这里正好只有蓝色)，NSW中应当都要找出值以满足约束(比如可以选择红色)。所以我们认为这条弧是相容的。<br><img src='../../figure/人工智能笔记/3-Constraint-Satisfaction-Problems/arc_consistency_example.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="Arc-Consistency-Algorithm-3"><a href="#Arc-Consistency-Algorithm-3" class="headerlink" title="Arc Consistency Algorithm #3"></a>Arc Consistency Algorithm #3</h4><p>在使用弧相容算法时，假如一个区域的取值发生变化(或者是被染色)，那么就需要建立一条从它的邻居指向它的弧，并且改变邻居的取值范围使这条弧相容。在算法的实现中，需要一个队列来储存需要检查的弧；同时检查某个弧时假如改变了某个节点的定义域，则会像队列中加入新的弧。</p><p><img src='../../figure/人工智能笔记/3-Constraint-Satisfaction-Problems/AC_3_algo.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><p>AC-3算法是backtracking的一种改进，相当于在对某个节点赋值之后，对其他节点的定义域进行修改，即将csp改为AC-3(csp)。</p><h4 id="Limitations-of-Arc-Consistency"><a href="#Limitations-of-Arc-Consistency" class="headerlink" title="Limitations of Arc Consistency"></a>Limitations of Arc Consistency</h4><p>对于下图来说，虽然实际上无法正确染色，但是弧相容算法检查不出错误。<br><img src='../../figure/人工智能笔记/3-Constraint-Satisfaction-Problems/limitation_of_arc_consistency.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="Complexity-of-a-single-run-of-AC-3"><a href="#Complexity-of-a-single-run-of-AC-3" class="headerlink" title="Complexity of a single run of AC-3"></a>Complexity of a single run of AC-3</h4><p>假如有 $n$ 个变量，每个变量有 $d$ 种取值。</p><p>对于函数 $REMOVE-INCONSISTENT-VALUE(X<em>{i}, X</em>{j})$，时间复杂度为 $O(d^{2})$，</p><p>（这里没搞懂）</p><h2 id="Local-search-for-CSPs"><a href="#Local-search-for-CSPs" class="headerlink" title="Local search for CSPs"></a>Local search for CSPs</h2><p>对于约束满足问题，也可以使用爬山算法，模拟退火算法等方法。这种方法同样是给一个初始的赋值，然后逐渐改变赋值使得最终约束都被满足。</p><ul><li>修改赋值时，首先选择那些不满足约束的变量</li><li>给变量重新赋值时，尽量让冲突最少</li></ul><p>比如说使用爬山法，可以定义启发式函数为违背约束的个数，然后逐渐改变赋值使得约束越来越少，并且需要减少最快。<br><img src='../../figure/人工智能笔记/3-Constraint-Satisfaction-Problems/local_search_for_csp.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p>]]></content>
      
      
      <categories>
          
          <category> artificial intelligence </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据链路层</title>
      <link href="/posts/c8c4683d.html"/>
      <url>/posts/c8c4683d.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据链路层的设计"><a href="#数据链路层的设计" class="headerlink" title="数据链路层的设计"></a>数据链路层的设计</h2><h3 id="数据链路层在协议栈中的位置"><a href="#数据链路层在协议栈中的位置" class="headerlink" title="数据链路层在协议栈中的位置"></a>数据链路层在协议栈中的位置</h3><ul><li>向下：利用物理层提供的位流服务</li><li>向上：向网络层提供明确的 (well-defined) 服务接口</li></ul><p>在局域网中，数据链路层(DLL)还会分成逻辑链路控制(LLC)和介质访问控制(MAC)。局域网属于通信质量比较高的共享信道，而本章考虑的主要是经典的数据链路层，考虑点对点的通信。</p><h3 id="数据链路层提供的服务"><a href="#数据链路层提供的服务" class="headerlink" title="数据链路层提供的服务"></a>数据链路层提供的服务</h3><p>用确认的有无以及连接的有无做区分</p><ul><li>确认指的是接收方接收到信息之后是否会发送确认信息给发送方</li><li>连接的有无指的是状态的有无,状态用于记录通信过程中发生的事，比如发送方是谁，数据的传输量等历史信息，可以用来做认证或者提供更可靠的服务</li></ul><p>服务的种类：</p><ul><li>无确认 无连接 服务(Unacknowledged connectionless)<br>  • 接收方不对收到的帧进行确认<br>  • 适用场景：误码率低的可靠信道；实时通信；<br>  • 网络实例：以太网(有线传输)</li><li>有确认 无连接 服务(Acknowledged connectionless)<br>  • 每一帧都得到单独的确认<br>  • 适用场景：不可靠的信道(无线信道)<br>  • 网络实例：802.11</li><li>有确认 有连接 服务(Acknowledged connection-oriented)<br>  • 适用场景：长延迟的不可靠信道</li></ul><p>事实上也存在无确认有连接的服务，这里的连接主要记录信息，用于收费。</p><h3 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h3><ul><li>成帧(最大的功能)<ul><li>将比特流划分成“帧”的主要目的是为了检测和纠正物理层在比特传输中可能出现的错误</li></ul></li><li>差错控制<ul><li>比如说一些错误或者丢失</li></ul></li><li>流量控制<ul><li>解决传输两侧传输速率不匹配的问题，防止高速率的发送方发送的数据不会淹没低速率的接收方，避免<strong>缓冲区溢出</strong></li></ul></li></ul><h3 id="成帧——如何表示一个帧的开始"><a href="#成帧——如何表示一个帧的开始" class="headerlink" title="成帧——如何表示一个帧的开始"></a>成帧——如何表示一个帧的开始</h3><p>分组(packet)和帧(frame)的关系<br><img src='../../figure/计算机网络笔记/数据链路层/分组与帧的关系.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>只有确定帧的开始，才能进行帧的<strong>定界</strong>和<strong>同步</strong>(指的是上一帧没接受成功，但是通过定界符可以知道下一帧，因此下一帧还是能够正常接收的)。</p><h4 id="字节计数法："><a href="#字节计数法：" class="headerlink" title="字节计数法："></a>字节计数法：</h4><ul><li>在每个帧的帧头用数字表示帧的长度</li><li>这种方法简单明确，但是不允许传输错误。一个字节的差错可能导致后面所有帧的失效</li><li><img src='../../figure/计算机网络笔记/数据链路层/字节计数法.png' width=450 style="display: block; margin-left: auto; margin-right: auto;"></li></ul><h4 id="带字节填充的定界符法"><a href="#带字节填充的定界符法" class="headerlink" title="带字节填充的定界符法"></a>带字节填充的定界符法</h4><ul><li>定义一个特殊的字节为定界符FLAG，比如 $01111110$，即 $0x_7E$，用于区分前后两个不同的帧</li><li><img src='../../figure/计算机网络笔记/数据链路层/带字节填充的定界符法.png' width=450 style="display: block; margin-left: auto; margin-right: auto;"></li><li>但是这种方法需要考虑假如有效载荷中假如恰好包含定界符FLAG，会导致定界符的错误判断。因此需要对有效载荷进行字节填充，发送方在FLAG之前加上转义字符ESC，接收方接收到后再自定将转义字符去掉，就能得到正确的有效填充。</li><li><img src='../../figure/计算机网络笔记/数据链路层/字节填充.png' width=450 style="display: block; margin-left: auto; margin-right: auto;"></li><li>这种方法能够解决问题，但是代价太大。假如有效载荷中出现了很多FLAG和ESC的内容，那么就需要假如非常多的额外的字节。</li></ul><h4 id="带比特填充的定界符法"><a href="#带比特填充的定界符法" class="headerlink" title="带比特填充的定界符法"></a>带比特填充的定界符法</h4><ul><li>假如定界符还是 $01111110$，那么发送发可以检查有效载荷，假如出现连续的五个 $1$ 比特，那么就插入一个 $0$ 比特。对于接受方来说，只要扫描有效载荷，遇到五个 $1$ 比特之后删掉后面的一个 $0$ 即可。</li><li><img src='../../figure/计算机网络笔记/数据链路层/带比特填充的定界符法.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></li></ul><h4 id="物理层编码违例"><a href="#物理层编码违例" class="headerlink" title="物理层编码违例"></a>物理层编码违例</h4><p>核心思想：选择的定界符在数据层不会出现</p><ul><li>4B/5B编码方案<ul><li>4比特数据映射成5比特编码，剩余的一半码字(16个码字)未使用，可以用做帧定界符</li><li>例如： 00110组合不包含在4B/5B编码中，可做帧定界符</li></ul></li><li>前导码<ul><li>存在很长的 前导码(preamble)，可以用作定界符</li><li>例如：传统以太网、802.11</li></ul></li><li>曼切斯特编码 / 差分曼切斯特编码<ul><li>正常的信号在周期中间有跳变，持续的高电平(或低电平)为违例码，可以用作定界符</li><li>例如：802.5令牌环网</li></ul></li></ul><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>链路层存在的一个问题：信道的噪声导致数据传输问题<br>• 差错(incorrect)：数据发生错误<br>• 丢失(lost)：接收方未收到<br>• 乱序(out of order)：先发后到，后发先到<br>• 重复(repeatedly delivery)：一次发送，多次接收</p><p>解决方案：差错检测与纠正、确认重传<br>• 确认：接收方校验数据(差错校验)，并给发送方应答，防止<strong>差错</strong><br>• 定时器：发送方启动定时器，防止<strong>丢失</strong><br>• 顺序号：接收方检查序号，防止<strong>乱序</strong>递交、<strong>重复</strong>递交</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>解决方案</p><ul><li>基于反馈 (feedback-based) 的流量控制<ul><li>接受方收到数据之后再向发送方发送反馈，发送方收到了反馈之后才能继续发送。这里的反馈就是确认帧。</li></ul></li><li>基于速率 (rate-based) 的流量控制<ul><li>发送方根据内建机制，自行限速</li></ul></li></ul><h2 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h2><h3 id="差错检测与纠正概述"><a href="#差错检测与纠正概述" class="headerlink" title="差错检测与纠正概述"></a>差错检测与纠正概述</h3><p>通常采用增加冗余信息(或称校验信息)的策略<br>比如说每个比特传三份，如果每比特的三份中有一位出错，可以纠正。这种方法虽然方便，但是冗余信息巨大。</p><p>我们希望保证一定差错检测和纠错能力的前提下，如何减少冗余信息量。</p><ul><li>考虑的问题<ul><li>信道的特征和传输需求</li><li>冗余信息的计算方法、携带的冗余信息量</li><li>计算的复杂度等</li></ul></li><li>两种主要策略<ul><li>检错码(error-detecting code)</li><li>纠错码(error-correcting code)</li></ul></li></ul><p>一些基本概念</p><ul><li>码字 (code word)：一个包含 $m$ 个数据位和 $r$ 个校验位的 $n$ 位单元<ul><li>描述为 $(n, m)$ 码，$n=m+r$</li></ul></li><li>码率 (code rate)：码字中不含冗余部分所占的比例，可以用 $m/n$ 表示</li><li>海明距离 (Hamming distance)：两个码字之间不同对应比特的数目<ul><li>例：0000000000 与 0000011111 的海明距离为5</li><li>如果两个码字的海明距离为d，则需要d个单比特错就可以把一个码字转换成另一个码字</li><li>为了检查出d个错（比特错），可以使用海明距离为 $d+1$ 的编码</li><li>为了纠正d个错，可以使用海明距离为 $2d+1$ 的编码</li></ul></li></ul><h3 id="典型的纠错码"><a href="#典型的纠错码" class="headerlink" title="典型的纠错码"></a>典型的纠错码</h3><p>纠错码指的是发送方在每个数据块中加入足够的冗余信息，使得接收方能够判断接收到的数据是否有错，并能纠正错误(定位出错的位置)。主要用于错误发生比较频繁的信道上，如无线链路；也经常用于物理层，以及更高层(例如，实时流媒体应用和内容分发)</p><p>使用纠错码的技术通常称为前向纠错(FEC，Forward Error Correction)</p><h3 id="典型的检错码"><a href="#典型的检错码" class="headerlink" title="典型的检错码"></a>典型的检错码</h3><p>检错码指的是在被发送的数据块中，包含一些冗余信息，但这些信息只能使接收方推断是否发生错误，但不能推断哪位发生错误，接收方可以请求发送方<strong>重传</strong>数据。主要用在高可靠、误码率较低的信道上，例如光纤链路</p><h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>增加1位校验位，可以检查奇数位错误</p><ul><li>偶校验：保证1的个数为偶数个</li><li>奇校验：保证1的个数为奇数个</li></ul><p>(如果考虑二维奇偶校验，那么可以用来纠错)</p><h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><p>TCP/IP体系中主要采用的校验方法</p><ul><li>发送方：进行 16 位二进制补码求和运算，计算结果取反，随数据一同发送</li><li>接收方：进行 16 位二进制补码求和运算（包含校验和），结果非全1，则检测到错误</li></ul><p><img src='../../figure/计算机网络笔记/数据链路层/校验和.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="循环冗余校验CRC"><a href="#循环冗余校验CRC" class="headerlink" title="循环冗余校验CRC"></a>循环冗余校验CRC</h4><p>CRC校验码计算方法</p><ul><li>设原始数据 $D$ 为 $k$ 位二进制位模式</li><li>如果要产生 $n$ 位CRC校验码，事先选定一个 $n+1$ 位二进制位模式 $G$ (称为生成多项式，收发双方提前商定)，$G$ 的最高位为 $1$</li><li>将原始数据 $G$ 乘以 $2^{n}$ （相当于在 $D$ 后面添加 $n$ 个 $0$），产生 $k+n$ 位二进制位模式，用 $G$ 对该位模式做模 $2$ 除，得到余数 $R$（$n$ 位，不足 $n$ 位前面用 $0$ 补齐）即为CRC校验码</li></ul><p><img src='../../figure/计算机网络笔记/数据链路层/CRC错误校验示例.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><h2 id="基本的数据链路层协议"><a href="#基本的数据链路层协议" class="headerlink" title="基本的数据链路层协议"></a>基本的数据链路层协议</h2><h3 id="有错信道上的单工停等式协议"><a href="#有错信道上的单工停等式协议" class="headerlink" title="有错信道上的单工停等式协议"></a>有错信道上的单工停等式协议</h3><ul><li>发送方发送数据，假如接收方正确地接收了数据，则返回哑帧确认，发送方收到确认信息后发送下一帧。假如传输过程中出了问题，发送方在一定时间内没有收到确认帧，则重发。</li><li>或者发送方发送数据，假如接收方正确地接收了数据，返回肯定确认帧；假如接收数据有误，则返回否定确认帧。</li></ul><p><img src='../../figure/计算机网络笔记/数据链路层/停-等式协议.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></p><p>对于以上两种方法，后者速度显然更快，因为前者必须等待到设定时间才能继续发送。设定时间不能太短，至少需要超过信息来回传输的时间；但设置时间也不能太长，否则信道利用率太低。但是实际上，由于前者实现起来更加方便，所以使用的更加广泛。</p><p>为了进行乱序和重复的问题，可以给信号进行标号。</p><p>为了流量控制，可以让发送方接收到上一个确认信号再继续发送信号。但是假如网络延时非常大(长肥网络)，比如说卫星通信，此时信道利用率会非常低。此时可以需要使用流水线(pipeline)的方法改进，这就是滑动窗口协议。</p><h2 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h2><p>一次传输多个帧，比如说一次传 $6$ 个，每收到一个确认帧，窗口就可以后移。比如说接收到 $6$ 的确认帧之后，窗口后移，后面的 $5$ 进入滑动窗口内。<br><img src='../../figure/计算机网络笔记/数据链路层/滑动窗口协议.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>解决了效率之后，还需要再考虑数据传输出错的情形。</p><ul><li>可以将错误帧及其之后的帧全部重发</li><li>接收方可以将后面的正确帧进行缓存，等原来的错误帧重发之后，再填入接收方。</li></ul><h3 id="回退N协议"><a href="#回退N协议" class="headerlink" title="回退N协议"></a>回退N协议</h3><ul><li>当接收端收到一个出错帧或乱序帧时，丢弃所有的后继帧，并且不为这些帧发送确认</li><li>发送端超时后，重传所有未被确认的帧</li></ul><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><img src='../../figure/计算机网络笔记/数据链路层/回退N协议.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>比如以上图为例，假设N为 $5$，并且接收方在接收第 $2$ 帧时出错，那么对于接收方来说，后面的所有帧都被丢弃；对于发送方来说，在接收到 $0$ 和 $1$ 的确认信号之后，滑动窗口向下滑动两个单位，继续发送 $5$ 和 $6$ 两帧，但这两帧最后会被丢弃。</p><p>回到发送方，$2$ 号帧的计时器等待超时，后面所有帧重传，即 $2, 3, 4, 5, 6$。</p><p>同时再考虑 $2$ 号帧之后成功接收的帧，以 $3$ 号为例。此时有两种选择</p><ul><li>不会确认帧，因为反正之后发送方会重传</li><li>回复确认帧，但是回复的是ACK1，而不能回复ACK3。(这是由于计算机网络中常用的累计确认的方法，即假如收到了某一帧的确认帧，那么表明这一帧之前所有的帧都被正确收到。)</li></ul><h4 id="协议基本思想"><a href="#协议基本思想" class="headerlink" title="协议基本思想"></a>协议基本思想</h4><ul><li>目的<ul><li>对可以连续发出的最多帧数（已发出但未确认的帧）作限制</li></ul></li><li>序号使用<ul><li>循环重复使用有限的帧序号</li></ul></li><li>流量控制：接收窗口驱动发送窗口的转动</li><li>发送窗口：其大小记作 $W<em>{T}$，表示在收到对方确认的信息之前，可以连续发出的最多数据帧数。其中 $W</em>{T}\le 2^{n}-1$。(假如 $W_{T}=2^{n}$，即滑动窗口大小等于序号数量，那么当发送方一次发送了所有数据，接收方成功接收，但是确认信号又全部丢失。这个时候发送方重发所有信号，接收方会误以为是下一组的帧，从而会产生错误)</li><li>接收窗口：其大小记作 $W<em>{R}$ ，$W</em>{R}=1$，因为必须按照顺序接收帧</li><li>累计确认：不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认</li></ul><h3 id="选择性重传"><a href="#选择性重传" class="headerlink" title="选择性重传"></a>选择性重传</h3><p>若发送方发出连续的若干帧后，收到对其中某一帧的否认帧，或某一帧的定时器超时， 则只重传该出错帧或计时器超时的数据帧。(回退N协议的发送方只有一个计时器，但是这里每一帧都有)</p><h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><p><img src='../../figure/计算机网络笔记/数据链路层/选择性重传.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>以上图为例，同样设N为 $5$，假如第 $2$ 帧发生错误但是第 $3$ 帧正确，那么接收方在接收到第 $3$ 帧后将返回NAK2，表示第 $2$ 帧没有正确接收；而发送方在接收到NAK2或者第 $2$ 帧计时器超时之后，则会重传。而第 $3$ 帧之后的几帧假如正确接收，可以选择返回ACK1。</p><p>一段时间后，第 $2$ 帧的重传被正确接收，那么将检查接收方缓存区内的序号，此时可以看出将返回ACK6，表示第 $6$ 帧以及前几帧都被正确的接收了。</p><h4 id="协议实现分析"><a href="#协议实现分析" class="headerlink" title="协议实现分析"></a>协议实现分析</h4><p>发送方：</p><ol><li>窗口尺寸：$1&lt;W<em>{T}≤2^{n-1}$，最多连续发送窗口中的 $W</em>{T}$ 个PDU。</li><li>窗口滑动：与回退N帧协议相同</li><li>选择重发：收到NAK (k)，重发PDU (k)</li><li>超时重发：超过T未收到期望的ACK，重发当前超时未应答的PDU</li><li>超次数失败：超过最大重发次数 $N_{max}$ 仍无正确应答，报告上层失败</li></ol><p>接收方：</p><ol><li>窗口尺寸：$1&lt;W_{R}≤2^{n-1}$</li><li>窗口滑动：窗口底部数据上交，窗口向前滑动一步</li><li>窗口内接收：窗口内的PDU全部接收，存储出错的后续PDU，按序交付；窗口外的PDU一律丢弃</li><li>确认策略：按序到达的PDU可立即确认，也可延迟确认(收到多帧后一起确认)ACK (k)；出错用否定性确认NAK(k)（期望重发k号PDU）</li></ol><p>假如 $W_{T}=2^{n-1}+1$，同样发生上面的错误，即接收方的确认信息再次全部丢失。假设 $n=3$，可以看出重传的部分数据序号与接收方接收下一段数据的信号会恰好相同，从而发生误判。<br><img src='../../figure/计算机网络笔记/数据链路层/选择性重传窗口大小.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></p><h2 id="数据链路协议实例"><a href="#数据链路协议实例" class="headerlink" title="数据链路协议实例"></a>数据链路协议实例</h2><h3 id="点到点链路层协议PPP"><a href="#点到点链路层协议PPP" class="headerlink" title="点到点链路层协议PPP"></a>点到点链路层协议PPP</h3><p>PPP协议是目前使用最多的数据链路层协议之一。有连接，无确认。</p><ul><li>帧数据的纠错功能<ul><li>数据链路层的PPP协议只进行检错，出现问题直接丢弃。PPP协议是不可靠传输协议</li></ul></li><li>流量控制功能<ul><li>PPP协议未实现点到点的流量控制</li></ul></li><li>可靠传输功能<ul><li>PPP为不可靠协议，不使用帧的序号。不可靠网络中可能使用有序号的工作方式。</li></ul></li><li>多点连接功能<ul><li>PPP协议不支持多点线路，只支持点对点的链路通信。</li></ul></li><li>单工和半双工链路<ul><li>PPP协议支持全双工链路</li></ul></li></ul><h4 id="PPP协议帧格式"><a href="#PPP协议帧格式" class="headerlink" title="PPP协议帧格式"></a>PPP协议帧格式</h4><p><img src='../../figure/计算机网络笔记/数据链路层/PPP协议帧格式.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p>]]></content>
      
      
      <categories>
          
          <category> computer network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Convolutional-modern</title>
      <link href="/posts/1d8caec6.html"/>
      <url>/posts/1d8caec6.html</url>
      
        <content type="html"><![CDATA[<h1 id="深度卷积神经网络-AlexNet"><a href="#深度卷积神经网络-AlexNet" class="headerlink" title="深度卷积神经网络 AlexNet"></a>深度卷积神经网络 AlexNet</h1><h2 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h2><p>AlexNet是因此此次深度学习热潮的第一个网络。</p><p>在此之前(2000年左右)使用的主流机器学习模型是核方法。核方法首先提取特征，然后选择核函数来计算相似性，形成一个凸优化问题，因此有很漂亮的定理。同时当时处理图片(计算机视觉)主要考虑的是几何学，核心思想是做特征抽取，把计算机视觉问题转化为几何问题，如果有比较好的几何模型，就能建立凸优化(或者非凸优化)的函数，只要几何模型建立的比较好，那么就能得到非常好的结果。</p><p>在当时的计算机视觉中，最重要的工作是特征抽取，当时也提出了各种从图像中提取特征的方法。只要提取特征比较好，具体的机器学习算法不重要。</p><p>而现今神经网络的兴起，很重要的原因是数据量的爆炸以及硬件性能的提升。AlexNet在第三次ImageNet竞赛中拿到了冠军，这个神经网络相当于一个更深更大的LeNet，主要改进了</p><ul><li>使用了丢弃法</li><li>ReLu</li><li>MaxPooling</li></ul><p>这次竞赛AlexNet引起了人们计算机视觉方法论的改变，通过CNN学习特征更加简单，同时CNN和Softmax一起训练，更加高效。<br><img src='../../figure/动手学深度学习/alexnet_imagenet.png' width=250 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="AlexNet-架构"><a href="#AlexNet-架构" class="headerlink" title="AlexNet 架构"></a>AlexNet 架构</h3><p>对于第一层，AlexNet的核更大，因为图片更大，需要更大的窗口看到更多东西。同时输出通道数为96，是希望在第一层就能学习到更多信息。$3\times 3$ 的池化层能够允许像素向左以及向右的偏差，使用MaxPooling值更大，学习更快。<br><img src='../../figure/动手学深度学习/alexnet_structure_1.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>对于第二层，进一步增加输出通道数，同样是要识别更多的模式。同时与LeNet相比，又增加了3个卷积层。<br><img src='../../figure/动手学深度学习/alexnet_structure_2.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>对于最后一层，结构相似，不过AlexNet识别的种类更多，因此全连接层的隐藏层更大。<br><img src='../../figure/动手学深度学习/alexnet_structure_3.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="更多细节"><a href="#更多细节" class="headerlink" title="更多细节"></a>更多细节</h3><p>AlexNet还对图片进行了数据增强，因为CNN对光照等比较敏感，所以可以先对图片进行各种处理<br><img src='../../figure/动手学深度学习/data_enhancement.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h1 id="使用块的网络-VGG"><a href="#使用块的网络-VGG" class="headerlink" title="使用块的网络 VGG"></a>使用块的网络 VGG</h1><h2 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h2><p>在学习AlexNet的时候我们遇到的最大的问题是这个网络长得不规则，结构不清晰。如果想要将卷积神经网络设计的更深，那么应该要有更好的设计框架，这就是VGG。</p><p>如何做到更深更大？</p><ul><li>全连接层(太贵)</li><li>更多的卷积层</li><li>将卷积层组合成块</li></ul><h3 id="VGG-块"><a href="#VGG-块" class="headerlink" title="VGG 块"></a>VGG 块</h3><p>VGG块就是AlexNet中一个部分的拓展，VGG块中的卷积层可以重复 $n$ 次，以及卷积层可以有 $m$ 个通道。<br><img src='../../figure/动手学深度学习/VGG_block.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>这里使用 $3\times 3$ 而不是用 $5\times 5$ 的卷积层，是因为经过测试发现，在计算量相同的情况下，$3\times 3$ 的卷积层效果更好。</p><h3 id="VGG-架构"><a href="#VGG-架构" class="headerlink" title="VGG 架构"></a>VGG 架构</h3><p>多个VGG块后接全连接层，不同次数重复块可以得到不同的架构，如VGG-16，VGG-19。<br><img src='../../figure/动手学深度学习/vgg_structure.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><h1 id="网络中的网络-NiN"><a href="#网络中的网络-NiN" class="headerlink" title="网络中的网络 NiN"></a>网络中的网络 NiN</h1><h2 id="NiN"><a href="#NiN" class="headerlink" title="NiN"></a>NiN</h2><h3 id="全连接层的问题"><a href="#全连接层的问题" class="headerlink" title="全连接层的问题"></a>全连接层的问题</h3><p>卷积层需要的参数比较少，只要 $c_i\times c_o\times k^{2}$ 个，但是卷积层之后的全连接层参数非常多：</p><ul><li>LeNet: $16\times 5\times 5\times 120=48k$</li><li>AlexNet: $256\times 5\times 5\times 4096=26M$</li><li>VGG: $512\times 7\times 7\times 4096=102M$</li></ul><p>因此NiN的思想就是完全不使用全连接层，而是用卷积层替代。</p><h3 id="NiN块"><a href="#NiN块" class="headerlink" title="NiN块"></a>NiN块</h3><p>一个卷积层之后跟两个全连接层，可以使用一个卷积层之后再跟两个 $1\times 1$ 且步幅也为 $1$ 的卷积层来替代，这两个卷积层的作用就相当于全连接层。</p><h3 id="NiN架构"><a href="#NiN架构" class="headerlink" title="NiN架构"></a>NiN架构</h3><ul><li>无全连接层</li><li>交替使用NiN块核步幅为2的最大池化层，逐步减小高宽和增大通道数</li><li>最后使用全局平均池化层得到输出，类别数就是输入通道数</li></ul><p><img src='../../figure/动手学深度学习/NiN_structure.png' width= 500 style="display: block; margin-left: auto; margin-right: auto;"></p><h1 id="含并行连结的网络-GoogLeNet"><a href="#含并行连结的网络-GoogLeNet" class="headerlink" title="含并行连结的网络 GoogLeNet"></a>含并行连结的网络 GoogLeNet</h1><h2 id="GoogLeNet"><a href="#GoogLeNet" class="headerlink" title="GoogLeNet"></a>GoogLeNet</h2><h3 id="Inception-块"><a href="#Inception-块" class="headerlink" title="Inception 块"></a>Inception 块</h3><p>4个路径从不同层面抽取信息，然后在输出通达维合并。使用多种结构，就可以不用纠结到底哪种更好。<br><img src='../../figure/动手学深度学习/inception_block.png' width= 500 style="display: block; margin-left: auto; margin-right: auto;"></p><p><img src='../../figure/动手学深度学习/inception_block_channel_num.png' width= 500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>图中的白色块可以认为是抽取通道信息，蓝色的块是抽取空间信息。</p><p>和单 $3\times 3$ 或者 $5\times 5$ 卷积层相比，inception块有更少的参数和计算复杂度<br><img src='../../figure/动手学深度学习/inception_paramters.png' width= 300 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="GoogLeNet-1"><a href="#GoogLeNet-1" class="headerlink" title="GoogLeNet"></a>GoogLeNet</h3><p>可以理解为多个inception块堆起来。<br><img src='../../figure/动手学深度学习/googlenet.png' width= 300 style="display: block; margin-left: auto; margin-right: auto;"></p><h1 id="批量归一化"><a href="#批量归一化" class="headerlink" title="批量归一化"></a>批量归一化</h1><h2 id="批量归一化-1"><a href="#批量归一化-1" class="headerlink" title="批量归一化"></a>批量归一化</h2><p>当神经网络特别深的时候，假设数据在底部，预测结果在顶部，那么梯度在上面会比较大，越到下面就越小(很多比较小的数相乘)，因此上层的参数会不断更新，而下层则变化很慢，导致上面很快就会收敛，下层则要一直训练。但是每次下层一变化，上层的参数又要重新学习，最终导致整体收敛变慢。(底层学习的是一些比较具体的纹理特征，而上层得到的则是一些更高维的特征)</p><p>因此我们希望在改变底部参数的时候避免顶部重复训练，这就需要批量归一化。</p><h3 id="批量归一化-2"><a href="#批量归一化-2" class="headerlink" title="批量归一化"></a>批量归一化</h3><p>固定小批量里的均值和方差，就能让各层相对稳定。同时具体的分布可以学习，但会有一定的限制</p><script type="math/tex; mode=display">x_{i+1}=\gamma \frac{x_i-\mu_{B}}{\sigma_{B}}+\beta</script><p>式中 $\gamma$ 和 $\beta$ 是可以学习的参数。</p><p>假如批量归一化可以作用在：</p><ul><li>全连接层和卷积层的输出上，激活函数之前</li><li>全连接层和卷积层的输入上</li></ul><p>对于全连接层，作用在特征维；对于卷积层，作用在通道维。</p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><ul><li>xavier也有类似normalization的东西，这两者有什么区别？<ul><li>本质上没有区别，都是希望让模型更稳定。但是xavier是在初始的时候进行设置，而batch normalization能在整个训练过程中对每一层进行操作。</li></ul></li><li>为什么加了batch normalization收敛时间变短？<ul><li>加了bn能让梯度变大一点，对权重的更新会变快</li></ul></li></ul><h1 id="残差网络-ResNet"><a href="#残差网络-ResNet" class="headerlink" title="残差网络 ResNet"></a>残差网络 ResNet</h1><h2 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h2><h3 id="加更多的层总是能改进精度吗？"><a href="#加更多的层总是能改进精度吗？" class="headerlink" title="加更多的层总是能改进精度吗？"></a>加更多的层总是能改进精度吗？</h3><p><img src='../../figure/动手学深度学习/nested_function_classes.png' width= 500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>假设 $f^{<em>}$ 是需要学习的最优值，$F$ 是学习的函数，图中函数的大小代表模型的复杂程度，一个函数；(比如说 $F_1$)能学到的最好的值就是在图中离 $f^{</em>}$ 最近的位置。我们可以增加模型的层数，使得模型更加复杂，从而学到更大的区域，比如图中 $F_1$ 到 $F_6$。</p><p>但是我们可以注意到，如果像左图中，虽然模型更加复杂了，但是学偏了，相比更小的模型反而偏差更大。但是如果能像右图中，大的模型总是能包含小的模型，那么我们至少可以保证模型不会更差。ResNet的核心思想就是实现右图，让情况不会更差。</p><h3 id="残差块"><a href="#残差块" class="headerlink" title="残差块"></a>残差块</h3><p>串联一个层改变函数类，如果我们希望扩大函数类，那么就给残差块加入快速通道来得到 $f(x)=x+g(x)$ 的结构。假如虚线框内的模型没有作用，那么依然能够包含原来的模型。(这只是一种解释方法)<br><img src='../../figure/动手学深度学习/resnet_block.png' width= 450 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="ResNet-架构"><a href="#ResNet-架构" class="headerlink" title="ResNet 架构"></a>ResNet 架构</h3><p>类似VGG和GoogleNet的总体架构，但是将块替换成了ResNet块。</p><p>残差块可以使得很深的网络更加容易训练，甚至可以训练一千层的网络。残差网络也对之后的网络产生了非常深远的影响。</p><h2 id="QA-1"><a href="#QA-1" class="headerlink" title="QA"></a>QA</h2><ul><li>为什么 $f(x)=x+g(x)$ 能使得更大的模型包含原来的小模型？<ul><li>我们在训练 $f(x)$ 的时候，如果模型发现加上 $g(x)$ 对模型的效果并不好，那么在做梯度下降的时候 $g(x)$ 就得不到较大的梯度，权重会很小。</li></ul></li><li>残差网络名字的由来？<ul><li>$f(x)=x+g(x)$ 可以理解为我们先训练了下面的小网络，然后 $g(x)$ 项用于在原有的基础网络上做微调，就相当于残差。</li></ul></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 动手学深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adversarial Search</title>
      <link href="/posts/fa6cbd68.html"/>
      <url>/posts/fa6cbd68.html</url>
      
        <content type="html"><![CDATA[<h2 id="Multi-Agent-System"><a href="#Multi-Agent-System" class="headerlink" title="Multi-Agent System"></a>Multi-Agent System</h2><p>涉及到多人之间的博弈，但是数量不会特别多，否则应该使用经济学中的原理而非人工智能。同时多智能体系统要有明确的行动规则，比如说篮球比赛现在想要建模还比较困难，因为规则太复杂了。</p><h2 id="A-Special-Case"><a href="#A-Special-Case" class="headerlink" title="A Special Case"></a>A Special Case</h2><p>现在只考虑只有<strong>两个智能体</strong>开展<strong>零和博弈</strong>的情形，两个玩家<strong>轮流行动</strong>，都默认采取<strong>最佳策略</strong>。同时环境确定且可观测。(Two-Player Sequential Zero-Sum Complete-Information)</p><h3 id="Tic-Tac-Toe"><a href="#Tic-Tac-Toe" class="headerlink" title="Tic-Tac-Toe"></a>Tic-Tac-Toe</h3><p><img src='../../figure/人工智能笔记/2-Adversarial-Search/tic_tac_toe.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="Solution-Concept"><a href="#Solution-Concept" class="headerlink" title="Solution Concept"></a>Solution Concept</h4><p>我们在玩这个游戏的时候总是会想如何阻止对方连成一条线，这里可以显示出玩家总是会认为对方会做出最优的策略。</p><h3 id="Game-as-Search-Problem"><a href="#Game-as-Search-Problem" class="headerlink" title="Game as Search Problem"></a>Game as Search Problem</h3><p>对于一棵搜索树，一个状态后面会有许多后继状态，这和两个人的博弈是类似的。</p><p>定义：</p><ul><li>$S_0$：初始状态</li><li>Players(s)：在状态 $s$ 行动的玩家</li><li>Action(s)：一个合法的行动</li><li>Result(s,a)；状态 $s$ 在行动 $a$ 之后的后继状态</li><li>Terminal-Tests(s)：表示游戏是否在状态 $s$ 终止</li><li>Utility(s,p)：表示某个终止状态状态 $s$ 对于玩家 $p$ 的效用值，其中 $p \in \left{ MAX, MIN \right}$。</li><li>Game：在游戏数(搜索树)中搜索</li></ul><p>因此我们需要找到一条路径，从初始状态到终止状态。并且对于 MAX 玩家而言，希望终止状态效用函数能最大化；对于 MIN 玩家而言，希望终止状态效用函数能最小化。而在玩家每一步的行动中，他们都会采取对自己最有利的策略。</p><p><img src='../../figure/人工智能笔记/2-Adversarial-Search/game_tree.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="Minimax-Algorithm"><a href="#Minimax-Algorithm" class="headerlink" title="Minimax Algorithm"></a>Minimax Algorithm</h3><h4 id="Brute-force"><a href="#Brute-force" class="headerlink" title="Brute force"></a>Brute force</h4><p>该算法是为了找出上面提到的路径。算法的执行顺序为：假如知道某个节点 $s$ 所有后继节点的 minimax 值，那么就能确定节点 $s$ 的值，其中</p><ul><li>假如 Player(s)=MAX，那么节点 $s$ 的值为后继节点的最大值</li><li>假如 Player(s)=MIN，那么节点 $s$ 的值为后继节点的最小值</li></ul><p>即：</p><script type="math/tex; mode=display">MINMAX(s)=\begin{cases}    UTILITY(s) & \text{if } TERMINAL-TEST(s)\\    \max_{a\in Action(s)} MINMAX(RESULT(s,a))& \text{if } PLAYER(s)=MAX\\    \min_{a\in Action(s)} MINMAX(RESULT(s,a))& \text{if } PLAYER(s)=MIN\\\end{cases}</script><p>因此这种算法相当于对整棵树进行搜索。</p><p>比如下面这颗搜索树，使用 minimax 算法的结果如下：<br><img src='../../figure/人工智能笔记/2-Adversarial-Search/mininax_algorithm_illustration.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="Properties-of-minimax-algorithm"><a href="#Properties-of-minimax-algorithm" class="headerlink" title="Properties of minimax algorithm"></a>Properties of minimax algorithm</h4><ul><li>是完备的(只要搜索树是有限的)</li><li>是最优的(只要对手同样采取最优策略)</li><li>时间复杂度为 $O(b^{m})$(该算法其实就是深度优先搜索，$b$ 为每次能采取的行动种数，$m$ 为整盘棋的总步数)</li><li>空间复杂度为 $O(bm)$</li></ul><p>可以看出该算法对于一些比较大型的游戏而言是不可行的，比如下棋时 $b\thickapprox 25, m\thickapprox 100$，那么计算量显然是无法接受的。因此对于很多实际问题而言，我们无法做到搜索整棵树，而是只能搜索树的一部分。</p><h4 id="Minimax-Algorithm-1"><a href="#Minimax-Algorithm-1" class="headerlink" title="Minimax Algorithm"></a>Minimax Algorithm</h4><p>为了实现较快的计算，可以限制搜索树的深度，比如限制为 $d$。但是与此同时，因为无法搜索到叶节点得到准确的效用值，我们需要给中间节点定义评估函数(evaluation function) $e(s)$。</p><p>对于一个评估函数</p><ul><li>评估函数对于终止状态的排序应当和效用值对终止状态的排序应当是相同的。</li><li>因为评估函数需要多次计算，所以为了节约时间，应当便于计算</li><li>评估函数的值应当与获胜的概率密切相关</li></ul><p>比如对于象棋而言，我们可以依据棋盘上棋子的数量和种类来定义一个评估函数。</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>比如对于 Tic-Tac-Toe 游戏，我们定义 × 是 MAX 一方，而每种状态的评估函数定义为 $e(s)=$ 对于 MAX 玩家目前任然开放的行、列、对角线的数量-对于 MIN 玩家目前任然开放的行、列、对角线的数量。</p><p>假如考虑从头开始，第一步为 × 玩家先走，那么得到的限制深度 $d=2$ 的搜索树为：<br><img src='../../figure/人工智能笔记/2-Adversarial-Search/example_minimax_algo.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>对各个叶节点使用评估函数估算，然后逐层推回根节点，就能知道 × 玩家应当先走哪一步。假如是从中间某一部开始，那么可以同理计算。</p><h3 id="alpha-beta-Pruning"><a href="#alpha-beta-Pruning" class="headerlink" title="$\alpha-\beta$ Pruning"></a>$\alpha-\beta$ Pruning</h3><p>之前的算法是限制搜索树的深度，于此同时我们还可以对搜索树进行剪枝，减小其复杂度。这就是 $\alpha-\beta$ 剪枝。</p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><p>首先从一个例子入手<br><img src='../../figure/人工智能笔记/2-Adversarial-Search/alpha_beta_pru_example.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>我们希望得到根节点的最优解，那么</p><ol><li>首先看最左边的B节点，得到值为 $3$，此时可以确定A节点的下限应当为 $3$</li><li>然后再看C节点，C的第一个子节点为 $2$，这说明C节点上限为 $2$，则C的上限低于A的下限，C必然不可能更新A。</li><li>所以C的其他子节点都直接不用考虑</li></ol><p>$\alpha-\beta$ 剪枝就是这样的思路。</p><h4 id="Why-is-it-called-alpha-beta"><a href="#Why-is-it-called-alpha-beta" class="headerlink" title="Why is it called $\alpha-\beta?$"></a>Why is it called $\alpha-\beta?$</h4><p>$\alpha$ 对于某个MAX节点来说，是当前子结点中最好的(即最大的)值，这个值就限定了该MAX节点的下限。那么对于该MAX的某个MIN子节点来说，如果MIN子节点在某个时刻的值 $v$ 小于 $\alpha$，这个分枝就应该被剪掉。</p><p>$\beta$ 同理。</p><h4 id="pseudo-code"><a href="#pseudo-code" class="headerlink" title="pseudo code"></a>pseudo code</h4><script type="math/tex; mode=display">\begin{aligned}& \textbf{function ALPHA-BETA-SEARCH}(state)\text{returns an action}\\& \quad v\leftarrow\text{MAX-VALUE}(state,-\infty,+\infty)\\& \quad \textbf{return the }action\text{ in ACTIONS}(state)\text{ with value }v\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}& \textbf{function MAX-VALUE}(state,\alpha,\beta)\textbf{ returns }a\textit{ utility value} \\& \quad\textbf{if TERMINAL-TEST}(state)\textbf{ then return UTILITY}(state) \\& \quad v\leftarrow-\infty  \\& \quad \text{for each a in ACTIONS(state) do}  \\&  \quad \quad v\leftarrow\operatorname{MAX}(v,\operatorname{MIN-VALUE}(\operatorname{RESULT}(s,a),\alpha,\beta)) \\& \quad \quad \textbf{if }v\geq\beta\textbf{ then return }v \\& \quad \quad \alpha\leftarrow\mathrm{MAX}(\alpha,v) \\& \quad \text{return } v\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}&\textbf{function MIN-VALUE}(state,\alpha,\beta)\textbf{ returns }a\textit{ utility value} \\&\quad \textbf{if TERMINAL-TEST}(state)\textbf{ then return UTILITY}(state) \\&\quad v\leftarrow+\infty  \\&\quad\text{for each a in ACTIONS(state) do} \\&\quad \quad v\leftarrow\mathrm{MIN}(v,\mathrm{MAX-VALUE}(\mathrm{RESULT}(s,a),\alpha,\beta)) \\&\quad \quad\textbf{if }v\leq\alpha\textbf{ then return }v \\&\quad \quad \beta\leftarrow\operatorname{MIN}(\beta,v) \\&\quad \text{return } v\end{aligned}</script><p>在上述伪代码中，$\textbf{if }v\geq\beta\textbf{ then return }v$ 就是剪枝的操作。</p><h4 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h4><ul><li>MAX玩家更新 $\alpha$ 节点，MIN玩家更新 $\beta$ 节点</li><li>节点 $\alpha, \beta$ 的值从上向下传递</li><li>节点的效用值 $v$ 从下向上传</li><li>$\alpha-\beta$ 剪枝不会影响最终的结果</li><li>后继节点出现的顺序会很大的影响算法的效率，在最好的情况下，时间复杂度为 $O(b^{m / 2})$，其中 $b$ 为分支数，$m$ 为深度；而在最差的情况下，时间复杂度为 $O(b^{m})$</li></ul><h4 id="Iterative-Deepening-Search"><a href="#Iterative-Deepening-Search" class="headerlink" title="Iterative Deepening Search"></a>Iterative Deepening Search</h4><p>$\alpha-\beta$ 剪枝同样也是一种深度优先搜索，所以同样也可以使用迭代加深的算法，同样也可以使用启发式函数来评估。</p>]]></content>
      
      
      <categories>
          
          <category> artificial intelligence </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Convolutional neural networks</title>
      <link href="/posts/b4771890.html"/>
      <url>/posts/b4771890.html</url>
      
        <content type="html"><![CDATA[<h1 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h1><h2 id="从全连接到卷积"><a href="#从全连接到卷积" class="headerlink" title="从全连接到卷积"></a>从全连接到卷积</h2><p>分类猫和狗的图片，假设图片有12M像素，那么对于RGB图片而言有36M个元素，如果使用单隐藏层MLP的话，参数的数量甚至会超过世界上所有猫和狗的数量，这显然是不合理的。</p><p>图片识别应该遵循两个原则：</p><ul><li>平移不变性</li><li>局部性</li></ul><h3 id="重新考察全连接层"><a href="#重新考察全连接层" class="headerlink" title="重新考察全连接层"></a>重新考察全连接层</h3><ul><li>输入和输出为矩阵</li><li>权重变为4维的张量 $(h,w)$ 到 $(h’,w’)$<script type="math/tex; mode=display">h_{i,j}=\sum_{k,l}w_{i,j,k,l}x_{k,l} = \sum_{a,b}v_{i,j,a,b}x_{i+a,j+b}</script></li><li>$V$ 是 $W$ 的重新索引 $v<em>{i,j,a,b}=w</em>{i,j,i+a,j+b}$</li></ul><h4 id="平移不变性"><a href="#平移不变性" class="headerlink" title="平移不变性"></a>平移不变性</h4><p>如果使用 $h<em>{i,j}=\sum</em>{k,l}w<em>{i,j,k,l}x</em>{k,l} = \sum<em>{a,b}v</em>{i,j,a,b}x<em>{i+a,j+b}$，$x$ 的平移会导致 $h$ 的平移，因此 $v$ 不应该依赖于 $(i,j)$，所以有 $v</em>{i,j,a,b}=v_{a,b}$</p><script type="math/tex; mode=display">\therefore h_{i,j}=\sum_{a,b}v_{a,b}x_{i+a,j+b}</script><p>这就是二维交叉相关，在深度学习中被称为二维卷积。</p><h4 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h4><p>现在有 $h<em>{i,j}=\sum</em>{a,b}v<em>{a,b}x</em>{i+a,j+b}$，如果考虑局部性，当评估 $h<em>{i,j}$ 时，我们不应该使用远离 $x</em>{i,j}$ 的参数，所以当 $\left\vert a \right\vert ,\left\vert b \right\vert &gt;\Delta$ 时，应当使得 $v_{a,b}=0$</p><script type="math/tex; mode=display">\therefore h_{i,j}=\sum_{a=-\Delta}^{\Delta}\sum_{b=-\Delta}^{\Delta}v_{a,b}x_{i+a,j+b}</script><h2 id="卷积层-1"><a href="#卷积层-1" class="headerlink" title="卷积层"></a>卷积层</h2><h3 id="二维卷积层"><a href="#二维卷积层" class="headerlink" title="二维卷积层"></a>二维卷积层</h3><p><img src='../../figure/动手学深度学习/6-Convolutional-neural-networks/2d_convolution_layer.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><ul><li>输入 $\bm{X}: n_h\times n_w$</li><li>核 $\bm{W}: k_h\times k_w$</li><li>偏差 $b\in \mathbb{R}$</li><li>输出 $\bm{Y}:(n_h-k_h+1)\times (n_w-k_w+1)$<script type="math/tex; mode=display">\bm{Y}=\bm{X} \ast \bm{W}+b</script></li></ul><h3 id="一维和三维交叉相关"><a href="#一维和三维交叉相关" class="headerlink" title="一维和三维交叉相关"></a>一维和三维交叉相关</h3><ul><li><p>一维</p><script type="math/tex; mode=display">y_i=\sum_{a=1}^{h}w_a x_{i+a}</script><ul><li>文本</li><li>语言</li><li>时序序列</li></ul></li><li><p>三维</p><script type="math/tex; mode=display">y_{i,j,k}=\sum_{a=1}^{h}\sum_{b=1}^{w}\sum_{c=1}^{d} w_{a,b,c}x_{i+a,j+b,k+c}</script><ul><li>视频</li><li>医学图像</li><li>气象图像</li></ul></li></ul><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><ul><li>卷积层为什么不是越大越好？<ul><li>这个问题类似于全连接层不是越宽越好，通常比较深的全连接层比宽的效果更好。卷积层同样也是核小一点，同时做的深一点效果号。所以通常选择 $5\times 5$，$3\times 3$ 之类大小的卷积核。</li></ul></li></ul><h1 id="卷积层的填充和步幅"><a href="#卷积层的填充和步幅" class="headerlink" title="卷积层的填充和步幅"></a>卷积层的填充和步幅</h1><h2 id="填充和步幅"><a href="#填充和步幅" class="headerlink" title="填充和步幅"></a>填充和步幅</h2><h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>如果输入和核的形状为 $n_h\times n_w, k_h\times k_w$，那么输出形状 $(n_h-k_h+1)\times (n_w-k_w+1)$。可以看出更大的卷积核可以更快地减小输出大小。如果图片不是很大，那么可能就做不了更深的卷积神经网络。</p><p>一种解决方法是在四周进行填充。<br><img src='../../figure/动手学深度学习/6-Convolutional-neural-networks/padding.png' width=450 style="display: block; margin-left: auto; margin-right: auto;"></p><p>如果填充 $p_h$ 行和 $p_w$ 列，输出形状为 $(n_h-k_h+p_h+1)\times (n_w-k_w+p_w+1)$。通常取 $p_h=k_h-1, p_w=k_w-1$。</p><ul><li>当 $k_h$ 为奇数：在上下两侧填充 $p_h/2$</li><li>当 $k_h$ 为偶数：在上侧填充 $\left\lceil p_h /2 \right\rceil$，在下册填充 $\left\lfloor p_h /2 \right\rfloor$</li></ul><h3 id="步幅"><a href="#步幅" class="headerlink" title="步幅"></a>步幅</h3><p>如果输入比较大，但是卷积核比较小，那么如果希望输出比较小，会导致需要非常深的神经网络。</p><p>因此可以增加步幅，步幅指的是行/列的滑动长度。比如做高度为3宽度为2的步幅<br><img src='../../figure/动手学深度学习/6-Convolutional-neural-networks/stride.png' width=450 style="display: block; margin-left: auto; margin-right: auto;"></p><ul><li>给定高度 $s_h$ 和宽度 $s_w$ 的步幅，输出形状为 $\lfloor(n_h-k_h+p_h+s_h)/s_h\rfloor\times\lfloor(n_w-k_w+p_w+s_w)/s_w\rfloor$</li><li>如果 $p_h=k_h-1, p_w=k_w-1$，输出形状为 $\lfloor(n_h+s_h-1)/s_h\rfloor\times\lfloor(n_w+s_w-1)/s_w\rfloor$</li><li>如果输入高度和宽度可以被步幅整除，输出形状为 $(n_h / s_h)\times (n_w / s_w)$</li></ul><h2 id="QA-1"><a href="#QA-1" class="headerlink" title="QA"></a>QA</h2><ul><li>卷积神经网络的超参数的重要程度如何(核大小、填充、步幅)<ul><li>一般而言填充会使得图片的高度和宽度不变(为了方便)，而步幅一般选为 $1$，除非计算量太大，才可能在某些层使步幅为 $2$，用于控制计算复杂度。因此核大小通常是最关键的。</li></ul></li><li>现在已经有很多经典的网络结构了，在平时使用的时候需要自己设计卷积核还是直接套用经典网络结构？<ul><li>通常是直接使用经典网络结构，比如ResNet。除非输入的形状非常特殊，比如是一个 $20\times 1000$ 的图片，那就需要在经典架构上稍微做一点调整。自己设计的话也行，但是效果可能没有那么好。同时在实际应用中网络结构的影响可能没有那么大，而数据的处理可能会有更大的影响。</li></ul></li><li>为什么通常使用 $3\times 3$ 的卷积核，$3$ 个像素视野感觉很小。<ul><li>如果神经网络足够深的话就不小了，随着深度的增加，最后一层的某个像素对应到原图片的很大的面积。</li></ul></li><li>有没有办法让超参数一起训练？<ul><li>使用NAS。可以直接暴力搜索，或者自己设计求解。这种情况一般适用于需要在一些特殊的硬件上跑神经网络，才会需要搜索一个特殊的超参数。否则一般是不用的。</li></ul></li></ul><h1 id="卷积层里的多输入多输出通道"><a href="#卷积层里的多输入多输出通道" class="headerlink" title="卷积层里的多输入多输出通道"></a>卷积层里的多输入多输出通道</h1><h2 id="多输入多输出通道"><a href="#多输入多输出通道" class="headerlink" title="多输入多输出通道"></a>多输入多输出通道</h2><h3 id="多个输入通道"><a href="#多个输入通道" class="headerlink" title="多个输入通道"></a>多个输入通道</h3><p>彩色图片可能有RGB三个通道，如果转换为灰度会丢失信息。</p><p>假如有多个通道，那么每个通道都有一个卷积核，结果是所有通道卷积结果的和<br><img src='../../figure/动手学深度学习/6-Convolutional-neural-networks/multi_in_channel.png' width=450 style="display: block; margin-left: auto; margin-right: auto;"></p><ul><li>输入 $\bm{X}:c_i\times n_h\times n_w$</li><li>输出 $\bm{W}:c_i\times k_h\times k_w$</li><li>输出 $\bm{Y}:m_h\times m_w$</li></ul><h3 id="多个输出通道"><a href="#多个输出通道" class="headerlink" title="多个输出通道"></a>多个输出通道</h3><p>我们可以有多个三维卷积核，每个和生成一个输出通道。即设置 $c_o$ 个上面的多输入通道的卷积核。</p><script type="math/tex; mode=display">\begin{aligned}&\text{ 输入 }\mathbf{X}:c_i\times n_h\times n_w \\&\text{ 核 }\mathbf{W}:c_o\times c_i\times k_h\times k_w \\&\text{ 输出 }\mathbf{Y}:c_o\times m_h\dot{\times}m_w\end{aligned}</script><h3 id="多个输入和输出通道"><a href="#多个输入和输出通道" class="headerlink" title="多个输入和输出通道"></a>多个输入和输出通道</h3><p>每个输出通达可以识别特定模式，输入通道识别并组合输入中的模式。</p><h3 id="1-times-1-卷积层"><a href="#1-times-1-卷积层" class="headerlink" title="$1\times 1$ 卷积层"></a>$1\times 1$ 卷积层</h3><p>这是一个受欢迎的选择。这个卷积层不识别空间模式，只是融合通道。相当于输入形状为 $n_h n_w\times c_i$，权重为 $c_o\times c_i$ 的全连接层。<br><img src='../../figure/动手学深度学习/6-Convolutional-neural-networks/1_mul_1_convolution_layer.png' width=450 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="二维卷积层-1"><a href="#二维卷积层-1" class="headerlink" title="二维卷积层"></a>二维卷积层</h3><ul><li>输入 $\bm{X}:c_i\times h_n\times n_w$</li><li>核 $\bm{W}:c_o\times c_i\times k_h\times k_w$</li><li>偏差 $\bm{B}:c_o\times c_i$</li><li>输出 $\bm{Y}:c_o\times m_h\times m_w$</li></ul><p>计算复杂度 $O(c_i c_o k_h k_w m_h m_w)$</p><h2 id="QA-2"><a href="#QA-2" class="headerlink" title="QA"></a>QA</h2><ul><li>如何设计通道数量？<ul><li>假如宽度和高度都减半了，那么一般通道数会加倍。否则通道数通常不变。</li></ul></li><li>同一层不同通道卷积核大小必须一样吗？<ul><li>设置成一样计算效率更高(利于GPU并行)，但是没有强制规定要一样。</li></ul></li></ul><h1 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h1><h2 id="池化层-1"><a href="#池化层-1" class="headerlink" title="池化层"></a>池化层</h2><p>卷积对位置敏感，比如如果要检测垂直边缘，稍微偏移一点就偏离了边缘。但是这并不是我们希望的，因为实际情况下物体的边缘并不是完全准确的。所以需要引入池化层来解决这个问题。<br><img src='../../figure/动手学深度学习/6-Convolutional-neural-networks/detecting_edge.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="二维最大池化"><a href="#二维最大池化" class="headerlink" title="二维最大池化"></a>二维最大池化</h3><p>返回滑动窗口中的最大值<br><img src='../../figure/动手学深度学习/6-Convolutional-neural-networks/2d_max_pooling.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></p><p>使用最大池化之后，发现可以允许一定距离的位移。</p><h3 id="填充，步幅和多个通道"><a href="#填充，步幅和多个通道" class="headerlink" title="填充，步幅和多个通道"></a>填充，步幅和多个通道</h3><p>池化层和卷积层类似，都具有填充和步幅，但是没有可以学习的参数。在每个输入通道应用池化层获得相应的输出通道，因此池化层的输出通道数=输入通道数。</p><h1 id="LeNet"><a href="#LeNet" class="headerlink" title="LeNet"></a>LeNet</h1><h2 id="LeNet-1"><a href="#LeNet-1" class="headerlink" title="LeNet"></a>LeNet</h2><p>用于识别手写的数字<br><img src='../../figure/动手学深度学习/6-Convolutional-neural-networks/LeNet.png' width=700 style="display: block; margin-left: auto; margin-right: auto;"></p><p>使用了几个卷积层加上全连接层。</p><h2 id="QA-3"><a href="#QA-3" class="headerlink" title="QA"></a>QA</h2><ul><li>在跑得动的情况下，中间计算层的输出通道应该尽量大吗？<ul><li>如果太大会导致过拟合。一般中间层的大小和数据的复杂度相关。</li></ul></li><li>目前的深度学习是否都需要较多的训练数据？如果数据体量很小是否不适合用深度学习？<ul><li>现在已经可以实现在很少的训练样本上训练神经网络了。在真实的产业应用中不会从零开始学习，而是有先验知识的，而是会在很大的数据集上训练好一些模型作为起始点，再在小数据集上做微调。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 动手学深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode中C/C++配置文件</title>
      <link href="/posts/8117db7e.html"/>
      <url>/posts/8117db7e.html</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://code.visualstudio.com/docs/cpp/config-mingw">官方文档</a></p><div class="note info flat"><p>这里使用的是 <a href="http://mingw-w64.org/">mingw-w64</a> 的 g++ 编译器和 gdb 调试器。</p></div><h2 id="task-json"><a href="#task-json" class="headerlink" title="task.json"></a>task.json</h2><p>该配置文件用于指定编译 <code>.cpp</code> 文件时的配置。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++.exe 生成活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\mingw64\\bin\\g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><ul><li><code>label</code> 用于呈现该任务在任务列表中的名称</li><li><code>command</code> 用于指定使用的编译器</li><li><code>args</code> 用于指定传递给编译器的命令行参数<ul><li><code>-fdiagnostics-color=always</code> 是一个编译器选项，用于启用带颜色的诊断信息。</li><li><code>-g</code> 是一个编译器选项，表示需要生成调试信息</li><li><code>$&#123;file&#125;</code> 是一个变量，表示当前文件的路径。这里指的就是需要编译当前的文件</li><li><code>-o</code> 是一个编译器选项，用于指定输出文件的名称。</li><li><code>$&#123;fileDirname&#125;\$&#123;fileBasenameNoExtension&#125;.exe</code> 是一个变量和字符串的组合，表示输出文件的路径和名称。<ul><li><code>$&#123;fileDirname&#125;</code> 代表当前文件所在的目录路径，</li><li><code>$&#123;fileBasenameNoExtension&#125;</code> 代表当前文件的基本名称（不包含扩展名），<code>.exe</code> 表示输出文件的扩展名为.exe。</li></ul></li></ul></li><li><code>options</code> 字段用于指定任务的附加选项<ul><li><code>&quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;</code> 指定工作目录为当前文件所在的目录</li></ul></li><li><code>problemMatcher</code> 用于识别任务输出中的错误、警告或其他特定的消息，并将其解析为可在编辑器中显示或处理的格式，从而让编辑器可以根据任务输出中的问题信息，如编译错误或警告，将其在源代码中进行高亮显示、导航到错误位置、生成错误列表等。<ul><li><code>$gcc</code> 表示用于解析GCC编译器的输出</li></ul></li><li><code>detail</code> 中的内容是任务列表中作为描述的内容</li></ul><h2 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h2><p>该配置文件用于指定调试 <code>.cpp</code> 文件时的配置。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++.exe 生成和调试活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\mingw64\\bin\\gdb.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++.exe 生成活动文件&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><ul><li><code>name</code>: 配置项的名称，用于在调试器界面中显示。</li><li><code>type</code>: 调试器的类型。在这个示例中，使用的是 <code>cppdbg</code>，表示 C/C++ 调试器。</li><li><code>request</code>: 指定调试器的请求类型。<ul><li>在这个示例中，使用的是 <code>launch</code>，表示启动调试器。其他请求类型还有 <code>attach</code>(附加到正在运行的进程进行调试)和 <code>attachCore</code>(附加到核心转储文件进行调试)</li></ul></li><li><code>program</code>: 指定要调试的可执行文件路径。<code>$&#123;fileDirname&#125;\$&#123;fileBasenameNoExtension&#125;.exe</code> 表示使用的是当前文件所在目录下的可执行文件路径</li><li><code>args</code>: 传递给可执行文件的命令行参数。</li><li><code>stopAtEntry</code>: 指定是否在程序入口处停止。</li><li><code>cwd</code>: 指定调试器的当前工作目录。</li><li><code>environment</code>: 指定调试器的环境变量。</li><li><code>externalConsole</code>: 指定是否在外部控制台中运行程序。<ul><li>在这个示例中，设置为 <code>false</code>，调试的时候就会直接使用vscode中的面板。</li><li>如果设置为 <code>true</code>，就会跳出来一个黑窗口</li></ul></li><li><code>MIMode</code>: 指定调试器的 MI(Machine Interface)模式，用于定义调试器和其他工具之间的交互方式。使用MI模式，外部工具可以向GDB发送各种命令，如设置断点、执行程序、单步执行、查询变量值等<ul><li>在这个示例中，使用的是 <code>gdb</code>，表示使用 GNU Debugger。</li></ul></li><li><code>miDebuggerPath</code>: 指定调试器的可执行文件路径。在这个示例中，使用的是 <code>D:\mingw64\bin\gdb.exe</code>，表示使用 MinGW-w64 工具链下的 GDB。</li><li><code>setupCommands</code>: 配置调试器的附加命令。</li><li><code>preLaunchTask</code>: 在启动调试器之前执行的任务。在这个示例中，指定了一个名为 <code>C/C++: g++.exe 生成活动文件</code> 的任务。</li><li><code>version</code>: launch.json 文件的版本号。在这个示例中，使用的是 <code>2.0.0</code>。</li></ul><h2 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Win32&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;_DEBUG&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;UNICODE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;_UNICODE&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\mingw64\\bin\\g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;windows-gcc-x64&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>name</code> 配置项的名称。</li><li><code>includePath</code> 指定编译器应该搜索头文件的路径。<ul><li><code>$&#123;workspaceFolder&#125;/**</code> 表示在工作目录下搜索所有子目录。这样可以确保编译器在编译过程中能够找到所需的头文件。</li></ul></li><li><code>defines</code> 定义预处理器宏。预处理器宏是在代码编译之前由预处理器处理的标识符。</li><li><code>compilerPath</code> 用来推断C++标准库头文件的路径。当扩展知道这些文件的位置时，它可以提供智能代码补全和跳转到定义等功能。</li><li><code>cStandard</code> 指定C语言的标准版本。</li><li><code>cppStandard</code> 指定C++语言的标准版本。</li><li><code>intelliSenseMode</code> 指定智能感知(IntelliSense)模式。IntelliSense是一个代码补全和代码分析功能，它可以提供代码提示、语法检查等功能。<ul><li><code>windows-gcc-x64</code> 表示使用适用于Windows平台的gcc编译器的智能感知模式。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物理层</title>
      <link href="/posts/652d7ab3.html"/>
      <url>/posts/652d7ab3.html</url>
      
        <content type="html"><![CDATA[<h2 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h2><h3 id="物理层功能"><a href="#物理层功能" class="headerlink" title="物理层功能"></a>物理层功能</h3><ul><li>位置：物理层是网络体系结构中的最低层<ul><li>不是连接计算机的具体物理设备，也不是负责信号传输的具体物理媒体</li></ul></li><li>功能：如何在连接各计算机的传输媒体上传输数据比特流<ol><li>数据链路层将数据比特流传送给物理层</li><li>物理层将比特流按照传输媒体的需要进行<strong>编码</strong></li><li>然后将信号通过传输媒体传输到下一个节点的物理层</li></ol></li><li>作用：尽可能地<strong>屏蔽掉不同传输媒体和通信手段的差异</strong>，为数据链路层提供一个统一的数据传输服务</li></ul><h3 id="物理层接口特性"><a href="#物理层接口特性" class="headerlink" title="物理层接口特性"></a>物理层接口特性</h3><p><strong>物理层协议</strong>是DTE和DCE间的约定，规定了两者之间的接口特性</p><ul><li>数据终端设备(DTE)<ul><li>一种具有一定的数据处理和转发能力的设备，可以是数据的源点或终点</li></ul></li><li>数据电路端设备(DCE)<ul><li>在DTE和传输线路之间提供<strong>信号变换</strong>和<strong>编码</strong>的功能，负责建立、保持和释放数据链路</li></ul></li></ul><p><img src='../../figure/计算机网络笔记/物理层/数据通信系统组成.png' width=450 style="display: block; margin-left: auto; margin-right: auto;"></p><ul><li>标准化的DTE/DCE接口具有<ul><li>机械特性、电气特性、功能特性、过程特性</li></ul></li></ul><h4 id="物理层机械特性"><a href="#物理层机械特性" class="headerlink" title="物理层机械特性"></a>物理层机械特性</h4><p>涉及接口的物理结构，通常采用接线器来实现机械上的连接，定义接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。<br><img src='../../figure/计算机网络笔记/物理层/各种类型物理接口.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="物理层电气特性"><a href="#物理层电气特性" class="headerlink" title="物理层电气特性"></a>物理层电气特性</h4><p>规定了发送器和接收器的<strong>电路特性</strong>、<strong>负载要求</strong>、<strong>传输速率</strong>和<strong>连接距离</strong>等，如发送信号电平、发送器和接收器的输出阻抗、平衡特性等</p><p>举例： ITU-T V/X系列有关建议的某些电气特性<br><img src='../../figure/计算机网络笔记/物理层/ITU-T电气特性.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="物理层功能特性"><a href="#物理层功能特性" class="headerlink" title="物理层功能特性"></a>物理层功能特性</h4><p>描述接口执行的功能，定义接线器的每一引脚(针，Pin)的作用</p><p>举例：10BASE-T RJ-45 接口功能特性<br><img src='../../figure/计算机网络笔记/物理层/接口功能特性.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="物理层过程特性"><a href="#物理层过程特性" class="headerlink" title="物理层过程特性"></a>物理层过程特性</h4><p>指明对于不同功能的各种可能事件的出现顺序<br><img src='../../figure/计算机网络笔记/物理层/物理层过程特性.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h2 id="数据通信基础"><a href="#数据通信基础" class="headerlink" title="数据通信基础"></a>数据通信基础</h2><h3 id="基本概念与术语"><a href="#基本概念与术语" class="headerlink" title="基本概念与术语"></a>基本概念与术语</h3><h4 id="通信、消息、信息、信号与数据"><a href="#通信、消息、信息、信号与数据" class="headerlink" title="通信、消息、信息、信号与数据"></a>通信、消息、信息、信号与数据</h4><ul><li>通信(communication)：在两台计算机之间传递消息</li><li>消息(message)：可以是图像、文字、语音等可以被通信双方理解并且可以被相互传递的东西。</li><li>数据(data)：消息的载体</li><li>信息(information)：消息中的有效部分</li><li>信号(signal)：通信过程中的数据的载体</li></ul><h4 id="数据的信号表示"><a href="#数据的信号表示" class="headerlink" title="数据的信号表示"></a>数据的信号表示</h4><p>数据</p><ul><li>数字(digital)：如文字</li><li>模拟(analog)：如语音</li></ul><p>信号同样有数字信号和模拟信号。</p><p>数据可以编码(encode)成信号：</p><ul><li>数字数据 $\rightarrow$ 数字信号：直接使用高低电位，得到基带信号</li><li><p>数字数据 $\rightarrow$ 模拟信号：可以调幅(ASK)、调频(FSK)、调相(PSK)。<br><img src='../../figure/计算机网络笔记/物理层/数字数据编码.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p></li><li><p>模拟数据 $\rightarrow$ 模拟信号：同样可以调幅(AM)、调频(FM)、调相(PM)<br><img src='../../figure/计算机网络笔记/物理层/模拟数据编码.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p></li><li><p>模拟数据 $\rightarrow$ 数字信号：采样，如语音信号的PCM调制</p><ul><li>在时间上采样(采样率)，比如声音有 $44.1Hz, 48Hz, 96Hz, 192Hz$</li><li>在值域上近似(采样深度)，比如 $16bits, 32bits$，表示用多少个比特来记录一个数值</li></ul></li></ul><h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><h4 id="数字通信和模拟通信"><a href="#数字通信和模拟通信" class="headerlink" title="数字通信和模拟通信"></a>数字通信和模拟通信</h4><ul><li>以模拟信号来传送消息的通信方式称为模拟通信，而传输模拟信号的通信系统称为模拟通信系统</li><li>以数字信号来传送消息的通信方式称为数字通信，而传输数字信号的通信方式称为数字通信系统</li></ul><h4 id="基带传输和频带传输"><a href="#基带传输和频带传输" class="headerlink" title="基带传输和频带传输"></a>基带传输和频带传输</h4><ul><li>基带传输：指不搬移信号频谱的传输体制</li><li>频带传输：指利用<strong>调制解调器</strong>搬移信号频谱的传输体制<ul><li>就是让基带信号和载波进行调制<br><img src='../../figure/计算机网络笔记/物理层/信号调制.png' width=350 style="display: block; margin-left: auto; margin-right: auto;"></li></ul></li></ul><p>频带传输是为了让不同协议的信号之间尽量不相互干扰，同时也可以调整带宽来控制某种协议的传输速度。</p><h4 id="传输模式-单工、半双工、双工"><a href="#传输模式-单工、半双工、双工" class="headerlink" title="传输模式(单工、半双工、双工)"></a>传输模式(单工、半双工、双工)</h4><ul><li>单工：指两个站之间只能沿一个指定的方向传送数据信号</li><li>半双工：指两个站之间可以在两个方向上传送数据信号，但不能同时进行，又称“双向交替”模式，发/收之间的转向时间为 $20～50ms$</li><li>全双工：指两个站之间可以在两个方向上同时传送数据信号<h4 id="同步方式-同步-异步"><a href="#同步方式-同步-异步" class="headerlink" title="同步方式(同步/异步)"></a>同步方式(同步/异步)</h4></li><li>异步传输的协议设计比较复杂，接收方需要识别信号什么时候开始，什么时候结束</li><li>同步传输协议更加简单，但是精确地实现同步比较困难<div style="display: flex;">  <img src="../../figure/计算机网络笔记/物理层/异步传输.png" width="350" style="display: block; margin: 0 auto;">  <img src="../../figure/计算机网络笔记/物理层/同步传输.png" width="350" style="display: block; margin: 0 auto;"></div></li></ul><h4 id="数据传输类型-串行、并行"><a href="#数据传输类型-串行、并行" class="headerlink" title="数据传输类型(串行、并行)"></a>数据传输类型(串行、并行)</h4>  <div style="display: flex;">    <img src="../../figure/计算机网络笔记/物理层/串行传输.png" width="250" style="display: block; margin: 0 auto;">    <img src="../../figure/计算机网络笔记/物理层/并行传输.png" width="250" style="display: block; margin: 0 auto;">  </div><h3 id="传输损伤"><a href="#传输损伤" class="headerlink" title="传输损伤"></a>传输损伤</h3><ul><li>误码(Error)。指信号在传输过程中码元发生的差错，即接收与发送数字信号的单个数字之间的差异</li><li>抖动(Jitter)。指码元出现的时刻随时间频繁地变化，也就是各有效瞬间相对于理想时间位置的短时间偏移</li><li>漂移(Wander)。指码元各有效瞬间相对于理想时间位置的长期缓慢偏移</li><li>滑动(Slip)。指一个信号序列在传输过程中，不可恢复地丢失或增加若干码元</li><li>时延(Delay)。指信号的各有效瞬间相对于理想时间位置的滞后或推迟</li></ul><p>干扰：</p><ul><li>环境干扰指大气干扰(如雷电、电离层闪烁等)、城区人为干扰(如工业干扰、汽车干扰等，wifi信号收到微波炉影响)和非恶意的邻道干扰等(比如在考场周围的电磁干扰)；</li><li>人为恶意干扰：指带有恶意或敌意的人为干扰。</li></ul><h3 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h3><h4 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h4><p>这里是对于数字信号而言</p><ul><li>调制速率(波特率、码元速率)：指单位时间内调制信号波形的变换次数，其单位是波特。$R_{B}=1 /T$</li><li>数据信号速率(比特率)：指单位时间内通过信道的信息量，其单位是比特/秒。$R_{b}=\frac{1}{T} \log_2 M$</li></ul><p>波特和比特的不同之处在于，有时候一个码元可能有不止两种的状态，而是 $M$ 种(比如说有 $M$ 个电位)，那么一个码元所含有的信息就相当于 $\log_2M$ 个比特。</p><h4 id="常见不同进制调制方式举例"><a href="#常见不同进制调制方式举例" class="headerlink" title="常见不同进制调制方式举例"></a>常见不同进制调制方式举例</h4><p>这里是对模拟信号而言(模拟信号传递数字数据)</p><p>通常由于频率是模拟信号的稀缺的资源(大的带宽能带来更大的传输速率)，因此调制的时候我们通常使用调幅和调相。而对于幅值和相位，我们可以用极坐标系中的一个点来代表。</p><p>假如1个码元对应1个比特，那么极坐标系下只需要2个点，这就是 BPSK。QPSK中1个码元对应2个比特，QAM中对应4个。<br><img src='../../figure/计算机网络笔记/物理层/不同进制调试方式.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><ul><li>在通信领域(模拟传输)，带宽指某个信号具有的频带宽度。单位是赫(或千赫、兆赫、吉赫、太赫等)。如话音信号的带宽是 $3.1kHz(300Hz～ 3400Hz)$。</li><li>在计算机领域(数字传输)，带宽指计算机网络的通信线路所能传送数据的能力，即在单位时间内从网络中某一点到另一点所能达到的“最高数据速率”。单位是 $b/s (bit/s)$ </li></ul><h4 id="信道容量"><a href="#信道容量" class="headerlink" title="信道容量"></a>信道容量</h4><ul><li><p>模拟信道容量<br><strong>香农定律</strong>指出：</p><script type="math/tex; mode=display">C=B \log_2(1+\frac{S}{N})</script><p>  其中 $C$ 是信道容量，$B$ 是信道带宽，$S /N$ 是平均信号信噪比，$S$ 是接收信号功率，$N$ 为噪声功率。</p></li><li><p>数字信道容量<br>对于一条有限带宽，无噪声的理想信道上，<strong>采样定理</strong>指出：</p><script type="math/tex; mode=display">C=2B \log_2M</script></li></ul><p>$M$ 是一个码元对应的比特数。</p><h4 id="传输质量"><a href="#传输质量" class="headerlink" title="传输质量"></a>传输质量</h4><ul><li>信噪比SNR：指信号通路某一点上的信号功率Ps与混在信号中的噪声功率PN之比值（常用对数表示）。<script type="math/tex; mode=display">SNR=10 \lg P_{S}/P_{N}</script></li><li>平均误码率：指单位时间内接收到的出错码元数占总码元数的比例<script type="math/tex; mode=display">P_e=\frac{n_e}{n}</script></li></ul><h2 id="复用技术"><a href="#复用技术" class="headerlink" title="复用技术"></a>复用技术</h2><p>复用 (multiplexing)技术的目的是：允许用户使用一个共享信道进行通信，避免相互干扰，降低成本，提高利用率。</p><h3 id="时分复用-TDM"><a href="#时分复用-TDM" class="headerlink" title="时分复用(TDM)"></a>时分复用(TDM)</h3><p><img src='../../figure/计算机网络笔记/物理层/时分复用.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><p>存在的不足：使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。因此可以引入统计时分复用</p><h3 id="统计时分复用-STDM"><a href="#统计时分复用-STDM" class="headerlink" title="统计时分复用(STDM)"></a>统计时分复用(STDM)</h3><p>统计时分复用（statistical time division multiplexing，STDM）是指动态地按需分配共用信道的时隙，即在每一次周期开始之前，先查询有哪些用户需要传输数据。</p><p><img src='../../figure/计算机网络笔记/物理层/统计时分复用.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="频分复用-FDM"><a href="#频分复用-FDM" class="headerlink" title="频分复用(FDM)"></a>频分复用(FDM)</h3><p>频分复用将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带<br><img src='../../figure/计算机网络笔记/物理层/频分复用.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>频分复用的信道利用率同样不高，不过相对时分复用而言，频分复用不需要做同步，更加方便</p><h3 id="波分复用-WDM"><a href="#波分复用-WDM" class="headerlink" title="波分复用(WDM)"></a>波分复用(WDM)</h3><p>和频分复用基本一样，只是波分复用用于光纤</p><h3 id="码分复用-CDMA"><a href="#码分复用-CDMA" class="headerlink" title="码分复用(CDMA)"></a>码分复用(CDMA)</h3><p>是指利用码序列相关性实现的多址通信，基本思想是靠不同的地址码来区分的地址。3G技术使用的主要就是这个复用技术。</p><p>不同使用者使用不同的地址码，而一组地址码可以理解为一组正交的向量基。比如有一组正交基 $(1, 0, 0), (0, 1, 0), (0, 0, 1)$，然后有3个用户A，B，C输入 $a, b, c$，那么在信道上传输的数据就为 $(1, 0, 0)\times a+ (0, 1, 0)\times b+ (0, 0, 1)\times c=(a,b,c)$，然后接收到数据之后再乘一个用户A对应的向量基 $(1, 0, 0)$，就能得到信息 $a$。<br><img src='../../figure/计算机网络笔记/物理层/码分复用.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="空分复用-SDM"><a href="#空分复用-SDM" class="headerlink" title="空分复用(SDM)"></a>空分复用(SDM)</h3><p>空分复用(Space Division Multiplexing,SDM)是指让同一个频段在不同的空间内得到重复利用。每个使用者占据一定的空间，从而避免相互干扰。手机网络之所以称为蜂窝网络，就是利用了这种技术。</p><p>最开始的空分复用指的是每个基站因为相隔比较远，因此不会相互干扰<br><img src='../../figure/计算机网络笔记/物理层/蜂窝网络.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></p><p>后来空分复用延伸到自适应天线阵列实现的空间分割，</p>]]></content>
      
      
      <categories>
          
          <category> computer network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>引言</title>
      <link href="/posts/8475ebc8.html"/>
      <url>/posts/8475ebc8.html</url>
      
        <content type="html"><![CDATA[<h2 id="网络实例"><a href="#网络实例" class="headerlink" title="网络实例"></a>网络实例</h2><h3 id="互联网的构成"><a href="#互联网的构成" class="headerlink" title="互联网的构成"></a>互联网的构成</h3><ul><li>网络边缘<ul><li>端系统：位于互联网边缘与互联网相连的计算机和其他设备</li><li>端系统由各类主机(host)构成：桌面计算机、移动计算机、服务器、其他智能终端设备</li></ul></li><li>网络核心<ul><li>由互联端系统的分组交换设备和通信链路构成的网状网络<ul><li>分组交换设备(路由器、链路层交换机)</li><li>连接分组交换设备的通信链路(光纤、铜缆、无线电、激光链路)</li></ul></li></ul></li></ul><p><img src='../../figure/计算机网络笔记/引言/网络边缘和网络核心.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><p>按照网络范围来分</p><ul><li>个域网PAN (Personal Area Network)<ul><li>能在便携式消费电器与通信设备之间进行短距离通信的网络</li><li>覆盖范围一般在10米半径以内，如蓝牙耳机等</li></ul></li><li>局域网LAN(Local Area Network)<ul><li>局部地区形成的区域网络，如企业网络</li><li>分布地区范围有限，可大可小，大到一栋建筑、小到办公室内的组网</li><li>电脑WLAN接入，打印机共享等等</li></ul></li><li>城域网MAN(Metropolitan Area Network )<ul><li>范围覆盖一个城市的网络</li></ul></li><li>广域网WAN(Wide Area Network)<ul><li>覆盖很大地理区域，乃至覆盖地区和国家</li></ul></li></ul><p>按照ISP类型来分</p><ul><li>Tier-1 ISP<ul><li>全球最高级别ISP，互不结算</li><li>比如中国电信、中国联通、中国移动</li></ul></li><li>Tier-2 ISP<ul><li>如教育网</li><li>需要向更高级别的ISP交流量费</li></ul></li></ul><p>Internet：特指遵循 TCP/IP 标准、利用路由器将各种计算机网络互连起来而形成的、覆盖全球的、特定的互连网，是一个专有名词。</p><h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><p>主机包括</p><ul><li>客户端：便携机、智能手机、平板电脑，智能手环等各类智能终端(都需要连入网络)</li><li>服务器：(服务器通常位于数据中心)</li></ul><p>主机的功能主要是运行应用程序、产生和接受信息。</p><h4 id="接入网概述"><a href="#接入网概述" class="headerlink" title="接入网概述"></a>接入网概述</h4><p>接入网的目标是将主机连接到边缘路由器上(<strong>边缘路由器</strong>是端系统Host去往任何其他远程端系统的路径上的第一台路由器)</p><p>接入网有有线接入和无线接入的方式。</p><ul><li>光纤到户FTTH：带宽大，线路稳定，在我国广泛使用<ul><li>分为有源光纤网络AON和无源光纤网络PON</li><li>PON中包括OLT(局部的光线路终端)和ONU光网络单元(如光猫ONT)，光猫ONT通过一个或多个无源分光器，连接到局端的光线路终端OLT<br><img src='../../figure/计算机网络笔记/引言/无源光纤网络.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></li></ul></li><li>数字用户线DSL(Digital Subscriber Line)<ul><li>复用之前的电话线，使用的是双绞线，成本低(国外使用广泛)</li><li>上下行速率不对称<br><img src='../../figure/计算机网络笔记/引言/数字用户线.png' width=450 style="display: block; margin-left: auto; margin-right: auto;"></li></ul></li><li>同轴电缆<ul><li>复用有线电视线，多个家庭共享有线电视的头端<br><img src='../../figure/计算机网络笔记/引言/同轴电缆.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></li></ul></li><li>无线局域网(WLAN)<ul><li>通常在建筑物内或者周围</li></ul></li><li>广域蜂窝接入网<ul><li>由移动蜂窝运营商提供</li></ul></li></ul><h4 id="物理介质"><a href="#物理介质" class="headerlink" title="物理介质"></a>物理介质</h4><ul><li>引导型介质：信号在固体介质中传播，例如铜、光纤、同轴电缆</li><li>非引导型介质：信号自由传播，例如无线电(陆地无线电、卫星无线电信道)</li></ul><p>主要的物理介质介绍：</p><ul><li>光纤：玻璃纤维携带光脉冲，每个脉冲一位；高速运行；低错误率</li><li>双绞线：两根绝缘铜线互相缠绕为一对<ul><li>电话线为1对双绞线；网线为4对双绞线，广泛用于计算机网络(以太网)双向传输</li><li>第5类：100 Mbps~1 Gbps；第6类：10Gbps</li></ul></li><li>同轴电缆：两根同心铜导线，双向传输</li><li>无线电：电磁频谱中各种“波段”携带的信号，半双工(发送方到接收方)<ul><li>无线局域网(WiFi)10-100 Mbps；10米</li><li>广域(如3/4/5G蜂窝)，在~10公里范围内</li><li>蓝牙：短距离，有限速率</li><li>地面微波：点对点；45 Mbps</li><li>卫星<ul><li>同步卫星：36000km高空， 280毫秒的往返时延</li><li>低轨卫星：近地，但围绕地球高速运动，需要大量卫星才能覆盖地球(采用低轨卫星降低通信时延)</li></ul></li></ul></li></ul><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><ul><li>目标：将海量的端系统互联起来</li><li>由各类交换机(路由器)和链路，构成的网状网络</li></ul><p>网络核心的两大功能：</p><ul><li>路由(全局操作)：确定数据分组从源到目标所使用的路径，需要路由协议和路由算法<strong>产生路由表</strong></li><li>转发(本地操作)：路由器或交换机将接收到的数据分组转发出去(即移动到该设备的某个输出接口)。根据从“入接口”收到分组头中的目的地址，<strong>查找本地路由表</strong>，确定“出接口”。</li></ul><p><img src='../../figure/计算机网络笔记/引言/路由器转发模型.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><ul><li>分组交换(packet switching)：通信双方以分组为单位、使用存储-转发机制，实现数据交互的通信方式<ul><li>每个分组的首部都含有地址(目的地址和源地址)等控制信息</li><li>每个分组在互联网中独立地选择传输路径，因此一个报文可以被拆成分组之后通过不同路径到达目的地。</li><li>支持灵活的统计多路复用</li></ul></li></ul><p><strong>存储转发技术</strong>：路由器需要接收到完整的整个数据分组以后，才能开始下一跳发送<br><strong>统计多路复用</strong>(statistical multiplexing)：主机A和B的报文分组按需共享带宽，<br><img src='../../figure/计算机网络笔记/引言/统计多路复用.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>面向连接的方式</p><p>先呼叫建立连接，实现端到端的资源(链路带宽资源、交换机的交换能力)预留，物理通路被通信双方独占，资源专用，即使空闲也不与其他连接共享。</p><ul><li>优点：由于建立连接并预留资源，因此传输性能好；</li><li>缺点：但如果传输中发生设备故障，则传输被中断。同时资源独占比较浪费。</li></ul><p>电路交换的多路复用：</p><ul><li><strong>频分多路复用</strong>FDM(按照频段高低不同)</li><li><strong>时分多路复用</strong>TDM(按照时间切片)</li></ul><h4 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h4><p>与分组交换类似，采用存储转发方式，但不将应用的大报文拆分成多个分组</p><p>几种交换方式的比较<br><img src='../../figure/计算机网络笔记/引言/典型交换方式的比较.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>网络协议是为进行网络中的数据交换而建立的规则、标准或约定。通信双方需要共同遵守，互相理解。</p><h3 id="网络协议三要素"><a href="#网络协议三要素" class="headerlink" title="网络协议三要素"></a>网络协议三要素</h3><ul><li>语法：规定传输数据的格式(如何讲)</li><li>语义：规定所要完成的功能(讲什么)</li><li>时序：规定各种操作的顺序(双方讲话的顺序)</li></ul><h3 id="协议层次结构"><a href="#协议层次结构" class="headerlink" title="协议层次结构"></a>协议层次结构</h3><ul><li>层次栈<ul><li>为了降低网络设计的复杂性，大部分网络都组成一个层次栈，每一层都建立在其下一层的基础上</li></ul></li><li>对等实体<ul><li>不同机器上构成相应层次的实体成为对等实体</li></ul></li><li>接口<ul><li>在每一对相邻层次之间的是接口；接口定义了下层向上层提供哪些<strong>原语操作与服务</strong></li></ul></li><li>网络体系结构<ul><li>层和协议的集合为网络体系结构，一个特定的系统所使用的一组协议，即每层的协议，称为<strong>协议栈</strong></li></ul></li></ul><p><img src='../../figure/计算机网络笔记/引言/协议层次结构.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="服务原语"><a href="#服务原语" class="headerlink" title="服务原语"></a>服务原语</h4><p>服务分类</p><ul><li>面向连接：按照电话系统模型建立的</li><li>无连接：按照邮政系统模型建立的</li></ul><p>服务由一组可用于用户进程以访问服务的原语(操作)形式指定，原语告诉服务执行某些操作或报告对等实体所采取的操作</p><p>面向连接服务的核心服务原语：<br><img src='../../figure/计算机网络笔记/引言/核心服务原语.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="服务与协议的关系"><a href="#服务与协议的关系" class="headerlink" title="服务与协议的关系"></a>服务与协议的关系</h3><ul><li>协议是“水平”的，服务是“垂直”的</li><li>实体使用协议来实现其定义的服务</li><li>上层实体通过接口使用下层实体的服务</li></ul><h2 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h2><h3 id="参考模型的必要性"><a href="#参考模型的必要性" class="headerlink" title="参考模型的必要性"></a>参考模型的必要性</h3><p>分层结构、统一标准、模块独立，能够满足计算机网络的复杂和异构，以及技术快速更新迭代的问题。</p><h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><h4 id="物理层-Physical-Layer"><a href="#物理层-Physical-Layer" class="headerlink" title="物理层(Physical Layer)"></a>物理层(Physical Layer)</h4><ul><li>定义如何在信道上传输0、1：Bits on the wire</li><li>机械接口(Mechanical)：网线接口大小形状、线缆排列等</li><li>电子信号(Electronic)：电压、电流等</li><li>时序接口(Timing)：采样频率、波特率、比特率等</li><li>介质(Medium)：各种线缆、无线频谱等<h4 id="数据链路层-Data-Link-Layer"><a href="#数据链路层-Data-Link-Layer" class="headerlink" title="数据链路层 (Data Link Layer)"></a>数据链路层 (Data Link Layer)</h4></li><li>实现<strong>相邻(Neighboring)网络实体</strong>间的数据传输</li><li>成帧(Framing)：从物理层的比特流中提取出完整的帧。形成帧有利于帮助数据的校验和纠错，为提供<strong>可靠数据通信</strong>提供可能</li><li>为设备提供<strong>物理地址(MAC address)</strong>：48位，设备的唯一网络标识，烧录在网卡，能够提供厂商信息。</li><li>提供流量控制，避免“淹没”(overwhelming):当快速的发送端遇上慢速的接收端，接收端缓存溢出</li><li>局域网<strong>共享信道</strong>上的访问控制(MAC)：同一个信道，同时传输信号，因此需要控制让信道满足多个设备的需求。<h4 id="网络层-Network-Layer"><a href="#网络层-Network-Layer" class="headerlink" title="网络层 (Network Layer)"></a>网络层 (Network Layer)</h4></li><li>将数据包跨越网络从<strong>源设备</strong>发送到<strong>目的设备</strong>(host to host)</li><li>使用IP地址，包含区域信息，便于查找</li><li>路由(Routing)：在网络中选取从源端到目的端转发路径，常常会根据网络可达性动态选取最佳路径，也可以使用静态路由</li><li>路由协议：路由器之间交互路由信息所遵循的协议规范，使得单个路由器能够获取网络的可达性等信息</li><li>服务质量(QoS)控制：处理网络拥塞、负载均衡、准入控制、保障延迟</li><li>异构网络互联：在异构编址和异构网络中路由寻址和转发<h4 id="传输层-Transport-Layer"><a href="#传输层-Transport-Layer" class="headerlink" title="传输层 (Transport Layer)"></a>传输层 (Transport Layer)</h4></li><li>将数据从源<strong>端口</strong>发送到目的<strong>端口</strong>(<strong>进程</strong>到<strong>进程</strong>)</li><li>网络层的控制主要面向<em>运营商</em>，传输层为<em>终端用户</em>提供端到端的数据传输控制</li><li>两类模式：可靠的传输模式(如TCP)，或不可靠传输模式(如UDP)<ul><li>可靠传输：可靠的端到端数据传输，适合于对通信质量有要求的应用场景，如文件传输等</li><li>不可靠传输：更快捷、更轻量的端到端数据传输，适合于对通信质量要求不高，对通信响应速度要求高的应用场景，如语音对话、视频会议等<h4 id="会话层-Session-Layer"><a href="#会话层-Session-Layer" class="headerlink" title="会话层 (Session Layer)"></a>会话层 (Session Layer)</h4></li></ul></li><li>利用传输层提供的服务，在应用程序之间建立和维持会话，并能使会话获得同步<h4 id="表示层-Presentation-Layer"><a href="#表示层-Presentation-Layer" class="headerlink" title="表示层(Presentation Layer)"></a>表示层(Presentation Layer)</h4></li><li>关注所传递信息的语法和语义，管理数据的表示方法，传输的数据结构<h4 id="应用层-Application-Layer"><a href="#应用层-Application-Layer" class="headerlink" title="应用层(Application Layer)"></a>应用层(Application Layer)</h4></li><li>通过应用层协议，提供应用程序便捷的网络服务调用</li></ul><h3 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h3><ul><li>链路层(Link Layer)<ul><li>描述了为满足无连接的互联网络层需求，链路必须具备的功能</li></ul></li><li>互联网层(Internet Layer)<ul><li>允许主机将数据包注入网络，让这些数据包独立的传输至目的地，并定义了数据包格式和协议(IPv4协议和IPv6协议)</li></ul></li><li>传输层(Transport Layer)<ul><li>允许源主机与目标主机上的对等实体，进行端到端的数据传输：TCP，UDP</li></ul></li><li>应用层(Application Layer)<ul><li>传输层之上的所有高层协议：DNS、HTTP、FTP、SMTP…</li></ul></li></ul><p>先有TCP/IP协议栈，然后有TCP/IP参考模型，参考模型只是用来描述协议栈的</p><p>IP分组交换的特点</p><ul><li>可在各种底层物理网络上运行(IP over everything)</li><li>可支持各类上层应用(Everything over IP)</li><li>每个IP分组携带各自的目的地址，网络核心功能简单(通过路由表转发分组)，适应爆炸性增长</li></ul><p>TCP/IP沙漏模型：<br><img src='../../figure/计算机网络笔记/引言/TCP-IP沙漏模型.png' width=150 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="分层模型与网络实例"><a href="#分层模型与网络实例" class="headerlink" title="分层模型与网络实例"></a>分层模型与网络实例</h3><p>分层模型与网络实例：<br><img src='../../figure/计算机网络笔记/引言/分层模型与网络实例.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><p>不同层对应不同的协议数据单元(PDU Protocol Data Unit)</p><h2 id="计算机网络度量单位"><a href="#计算机网络度量单位" class="headerlink" title="计算机网络度量单位"></a>计算机网络度量单位</h2><ul><li>比特率(bit rate)：<strong>主机</strong>在数字信道上传送数据的速率，也称数据率，单位是b/s(比特每秒)，也可以写为bps，(bit per second)，或 kbit/s、Mbit/s、 Gbit/s等</li><li>带宽：网络中<strong>某通道</strong>传送数据的能力，即单位时间内网络中的某信道所能通过的“最高数据率”，单位是 bit/s，即 “比特每秒”</li><li>包转发率(PPS)<ul><li>全称是Packet Per Second(包/秒)，表示交换机或路由器等网络设备以包为单位的转发速率</li><li>线速转发：交换机端口在满负载的情况下，对帧进行转发时能够达到该端口线路的最高速度</li></ul></li><li>时延(Delay)：时延 (delay 或 latency) 是指数据(一个报文或分组)从网络(或链路)的一端传送到另一端所需的时间，也称为延迟或迟延<ul><li>传输时延(transmission delay)：数据<strong>从结点进入到传输媒体介质</strong>所需要的时间，传输时延又称为发送时延</li><li>传播时延(propagation delay)：电磁波<strong>在信道中</strong>需要传播一定距离而花费的时间</li><li>处理时延(processing delay)：主机或路由器在收到分组时，为<strong>处理分组</strong>(例如分析首部、提取数据、差错检验或查找路由)所花费的时间</li><li>排队时延(queueing delay)：分组在路由器输入输出队列中<strong>排队等待</strong>处理所经历的时延<br><img src='../../figure/计算机网络笔记/引言/计算机网络时延.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"><br>总时延 $d<em>{total}=d</em>{proc}+d<em>{queue}+d</em>{trans}+d_{prop}$</li></ul></li><li>往返时延RTT(Round-Trip Time)：从发送方发送数据开始，到发送方收到来自接收方的确认，经历的总时间</li><li>时延带宽积 = 传播时延 $\times$ 带宽，即按比特计数的链路长度。可以理解为需要多少个bit才能把传播的链路塞满(可以把链路想象成水管，时延带宽积就是水管的体积)</li><li>吞吐量 (throughput)<ul><li>单位时间内通过某个网络(或信道、接口)的数据量，单位是 b/s</li></ul></li><li>有效吞吐量(goodput)<ul><li>单位时间内，目的地正确接收到的有用信息的数目（以 bit 为单位）</li></ul></li><li>利用率<ul><li><strong>信道利用率</strong>指出某信道有百分之几的时间是被利用的</li><li><strong>网络利用率</strong>则是全网络的信道利用率的加权平均值</li></ul></li><li>丢包率<ul><li>所丢失数据包的数量占所发送数据包的比率</li></ul></li><li>时延抖动：变化的时延称为抖动（Jitter）<ul><li>时延抖动起源于网络中的队列或缓冲，抖动难以精确预测</li><li>在语音、视频多媒体业务中，抖动往往会严重影响用户的体验</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> computer network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Solving Problems by Searching</title>
      <link href="/posts/19533d98.html"/>
      <url>/posts/19533d98.html</url>
      
        <content type="html"><![CDATA[<h2 id="Problem-solving-agent"><a href="#Problem-solving-agent" class="headerlink" title="Problem-solving agent"></a>Problem-solving agent</h2><p>问题求解智能体使用“原子”进行表征，表示一个状态<br><img src='../../figure/人工智能笔记/1-Solving-Problems-by-Searching/atomic%20representation.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="Search-problems-in-real-world"><a href="#Search-problems-in-real-world" class="headerlink" title="Search problems in real world"></a>Search problems in real world</h3><p>比如说地图导航、扫地机器人的路径规划</p><h3 id="Toy-Problem"><a href="#Toy-Problem" class="headerlink" title="Toy Problem"></a>Toy Problem</h3><p><img src='../../figure/人工智能笔记/1-Solving-Problems-by-Searching/toy-problems.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>早期的人工智能就是来解决这些小问题的。</p><h2 id="Problem-formulation"><a href="#Problem-formulation" class="headerlink" title="Problem formulation"></a>Problem formulation</h2><p>这些问题有一些共同点：</p><ul><li>有一个初始情况和比较确定的目标</li><li>有不同的简单行为(比如8-puzzle中每个数字可以上下左右移动)，执行特定行为的序列可能能够达到目标</li><li>搜索就是找到能够达到目标的序列</li><li>这些行为序列可能需要一定的代价(cost)</li></ul><p>当有一系列状态时，就可以形成一个状态空间(state space)，然后我们需要在状态空间中做搜索。比如我们想要从一个城市到另一个城市，地图如图<br><img src='../../figure/人工智能笔记/1-Solving-Problems-by-Searching/arad_to_bucharest_map.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>需要找到一条路径，就可以画出一个搜索树，其中初始状态就是树的根，树上的每一个节点表示一个状态，能够代表走过的路径。<br><img src='../../figure/人工智能笔记/1-Solving-Problems-by-Searching/search-the-state-space.png' width=600 style="display: block; margin-left: auto; margin-right: auto;"></p><p>这个问题形式化的说：</p><ul><li>有一个初始状态，就是树的根</li><li>有一系列行动，或者说后继函数，对应于树上每个节点的子节点</li><li>目标测试，即看有没有到达目的地</li><li>路径代价，即从一个城市到另一个的距离。我们可以</li><li>一个解决方案就是一个行动的序列，能够从初始状态到达目标状态</li><li>搜索策略：就是从树上的某个节点如何选择到达下一个节点。搜索策略可以分为无信息搜索和启发式搜索<ul><li>无信息搜索(Uninformed search)表示没有与问题相关的信息，仅仅是根据制定的规则进行搜索</li><li>启发式搜索(Heuristic search)指有与问题相关的信息，会综合考虑信息进行搜索</li></ul></li></ul><h2 id="Search-strategies"><a href="#Search-strategies" class="headerlink" title="Search strategies"></a>Search strategies</h2><p>搜索策略需要考虑以下几个方面：</p><ul><li>完备性(completeness)：当问题有解时，能够找到问题的解</li><li>时间复杂度(time complexity)：算法在最坏情况下需要的时间</li><li>空间复杂度(space complexity)：算法需要的内存空间</li><li>最优性(optimality)：能否找到代价最小的解？</li></ul><h3 id="Uniformed-search-strategies"><a href="#Uniformed-search-strategies" class="headerlink" title="Uniformed search strategies"></a>Uniformed search strategies</h3><p>无信息搜索主要包括：广度优先搜索(Breadth-first search)，深度优先搜索(Depth-first search)，深度受限搜索(Depth-limited search)，迭代加深搜索(Iterative deepending search)，一致代价搜索(Uniformed-cost search)。</p><h4 id="Breadth-first-search"><a href="#Breadth-first-search" class="headerlink" title="Breadth-first search"></a>Breadth-first search</h4><p>广度优先搜索的性质</p><ul><li>是完备的(只要深度 $b$ 是有限的)</li><li>时间复杂度 $1+b+b^{2}+ \cdots +b^{d}+b(b^{d}-1)=O(b^{d}+1)$，式子中的最后一项表示的是先扩展节点(将子节点放到队列中)，然后再做目标测试，在最坏情况下有 $b^{d}-1$ 个节点都要做扩展</li><li>空间复杂度 $O(b^{d+1})$，因为需要把每个节点都存在内存中。这里同样是先做拓展</li><li>能够满足最优性，因为是从浅到深搜索的，同时每步cost=1</li></ul><p>深度优先搜索的优缺点</p><ul><li>优点：能够找到到目标的最短路径</li><li>缺点：对空间的需求很高</li><li>改进为一致代价搜索(Dijkstra算法)</li></ul><h4 id="Uniform-cost-search"><a href="#Uniform-cost-search" class="headerlink" title="Uniform-cost search"></a>Uniform-cost search</h4><p>拓展代价最低的路径，边缘(fringe)为按照代价排序的优先队列</p><ul><li>如果每一步的代价都是正数 cost $\ge \varepsilon$，那么是完备的</li><li>时间复杂度 $O(b^{ceiling(C^{<em>} / \varepsilon)+1})$，其中 $C^{</em>}$ 为最优解的代价</li><li>空间复杂度 $O(b^{ceiling(C^{*} / \varepsilon)+1})$</li><li>满足最优</li></ul><h4 id="Depth-first-search"><a href="#Depth-first-search" class="headerlink" title="Depth-first search"></a>Depth-first search</h4><ul><li>如果深度是有限的，那么是完备的；否则不完备</li><li>时间复杂度 $O(b^{m})$，其中 $m$ 为树的最大深度，上面的 $d$ 是解所在的深度。如果 $m\gg d$ 的话，这个时间复杂度是很差的。</li><li>空间复杂度 $O(bm)$，线性空间</li><li>不满足最优(最优解可能在其他分支上)</li></ul><h4 id="Depth-limited-search-Iterative-deepening-search"><a href="#Depth-limited-search-Iterative-deepening-search" class="headerlink" title="Depth-limited search + Iterative deepening search"></a>Depth-limited search + Iterative deepening search</h4><p>限制搜索的深度，防止深度优先搜索中搜索过深的问题，但是这可能会导致找不到解(解可能在更深的地方)。因此接着引入迭代加深搜索。即使用深度限制搜索，但是会不断加深深度，知道最后找到解。</p><p>这个算法虽然看起来很naive，但是时间复杂度并不会增加太多。假如解的深度依然为 $d$，那么</p><ul><li>时间复杂度为 $db+(d-1)b^{2}+ \cdots +b^{d}=O(b^{d})$</li><li>空间复杂度 $O(bd)$</li><li>能够达到最优解(前提是step cost=1，和BFS一样)</li></ul><p>相当于结合了深度和广度优先搜索的优势</p><h2 id="Heuristic-search"><a href="#Heuristic-search" class="headerlink" title="Heuristic search"></a>Heuristic search</h2><p>启发式搜索像一个优化问题，每一步的操作都希望减小代价的预期值，同时最终的解是要求找到全局代价最小的解。</p><h3 id="Greedy-best-first-search"><a href="#Greedy-best-first-search" class="headerlink" title="Greedy best-first search"></a>Greedy best-first search</h3><p>对每个节点使用评估函数(evaluation function) $f(n)$，用于评估总的代价，然后在执行下一步的时候选择评估代价最小的操作。</p><p>贪心最佳优先搜索中， $f(n)=h(n)$，$h(n)$ 为启发式函数(heuristic function)，用于估计某个节点到目标节点的代价。比如说从地图上一个城市到另一个城市寻找最短路径的问题，启发式函数 $h(n)$ 就可以使用某个城市到终点的直线距离，虽然实际要走的路程并不等于直线距离，但是可以用这个来做一个估计。</p><h3 id="A-search"><a href="#A-search" class="headerlink" title="A* search"></a>A* search</h3><p>贪心最佳优先只估计某个节点到终点的距离，这是不太合理的，因此A*搜索还考虑了从起点到某个节点的距离，即 $f(n)=g(n)+h(n)$，其中 $g(n)$ 是从起点走到节点 $n$ 已经付出的最小代价(不是估计)。</p><h4 id="Admissible-heuristics"><a href="#Admissible-heuristics" class="headerlink" title="Admissible heuristics"></a>Admissible heuristics</h4><p>一个可接受的启发式函数(Admissible heuristics)需要满足：对于所有的节点 $n$，要有 $h(n)&lt;h^{<em>}(n)$，其中 $h^{</em>}(n)$ 表示从节点 $n$ 到终点的真实代价。</p><p>$h(n)&lt;h^{<em>}(n)$ 称为低估，反之成为高估。A</em>搜索想要生效，那么启发式函数就应该低估而不能高估，也就是说启发式函数一定要是可接受的。</p><h4 id="Consistent-heuristic"><a href="#Consistent-heuristic" class="headerlink" title="Consistent heuristic"></a>Consistent heuristic</h4><p>满足一致性的启发式函数需要满足 $h(n)\le c(n,a,n’)+h(n’)$，其中 $c(n,a,n’)$ 为从 $n$ 到 $n’$ 的真实代价<br><img src='../../figure/人工智能笔记/1-Solving-Problems-by-Searching/consistent_heuristics.png' width=150 style="display: block; margin-left: auto; margin-right: auto;"></p><p>对于通常的例子，满足可接受性的启发式函数也会满足一致性。</p><h4 id="Optimality-of-A"><a href="#Optimality-of-A" class="headerlink" title="Optimality of A*"></a>Optimality of A*</h4><p>如果 $h(n)$ 是可接受的，那么A<em> 在树搜索中一定能找到最优解；如果 $h(n)$ 是一致的，那么A</em> 在图搜索中能找到最优解。</p><p>第一条结论不难证明，因为 $h(n)$ 总是低估的。<br>假设 $G$ 是一个最优解，$G_2$ 是一个次优解，并且此时 $G_2$ 和 $n$ 都在边缘队列(fringe)中，其中 $n$ 是从起点到 $G$ 的路径中的一个节点。<br>因为 $G$ 是最优的，那么 $g(G)<g(G_2)=f(G_2)$，同时 $f(n)=g(n)+h(n)<g(n)+h^{*}(n)=g(G)<f(G_2)$，因此 $G_2$ 会一直呆在边缘队列中而不会被选中。最终被选中的只能是 $G$。<img src='../../figure/人工智能笔记/1-Solving-Problems-by-Searching/optimality_of_a.png' width=300 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="Properties-of-A"><a href="#Properties-of-A" class="headerlink" title="Properties of A*"></a>Properties of A*</h4><ul><li>是完备的(只要 $f\le f(G)$ 的节点是有限的)</li><li>时间复杂度为指数</li><li>空间复杂度：需要将所有节点都放在内存中</li><li>找到的解是最优的</li></ul><h3 id="Heuristic-function"><a href="#Heuristic-function" class="headerlink" title="Heuristic function"></a>Heuristic function</h3><p>给出一个启发式函数的设计实例。对于8-puzzle问题<br><img src='../../figure/人工智能笔记/1-Solving-Problems-by-Searching/8-puzzle-problem.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>我们可以选择没有放到目标位置上的数字个数作为启发式函数，那么此时 $h_1(S)=8$；也可以把曼哈顿距离之和作为启发式函数，那么此时 $h_2(S)=18$。不难看出这两种启发式函数都是低估的，因此都是可接受的。</p><p>而对于这两种启发式函数，使用曼哈顿距离的方法结果更好，因为这种启发式函数的估计值离真实情况更近，搜索错误的空间更小，能够更快地得到最优结果。</p><h2 id="Beyond-Classical-Search"><a href="#Beyond-Classical-Search" class="headerlink" title="Beyond Classical Search"></a>Beyond Classical Search</h2><p>Local search algorithms<br>局部搜索，不关系路径，只关心目标；从某个状态开始，通过不断地改进，从而到达理想的状态。比如说8皇后问题，只关心能不能到达8皇后互不冲突的目标，而不关心是通过什么方式达到这个目标；这个问题使用局部搜索的话也可以一次次的移动来改进结果。</p><p>因此局部搜索有两个主要优势</p><ul><li>占用内存较小(因为不像A*搜索那样需要记住中间的情况)</li><li>在极大甚至无穷的空间中能够找到一个比较好的结果</li></ul><h3 id="Hill-climbing-search"><a href="#Hill-climbing-search" class="headerlink" title="Hill-climbing search"></a>Hill-climbing search</h3><p>“就像一个有失忆症的人在大雾中爬珠穆朗玛峰”。不记录之前状态，只能看到附近的情况，因此容易陷入局部最优解。</p><h3 id="Simulated-annealing"><a href="#Simulated-annealing" class="headerlink" title="Simulated annealing"></a>Simulated annealing</h3><p>模拟退火，并不一定是每一步都向更优的结果走，而是有一定概率会选择比较差的结果。<br><img src='../../figure/人工智能笔记/1-Solving-Problems-by-Searching/simulate_annealing.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>模拟退火算法的一些问题</p><ul><li>代价函数(cost funtion)需要设计的比较好，因为这个函数需要被计算上百万次</li><li>可能和问题相关，并不一定能找到最优解</li><li>需要能量函数比较平滑，否则效果也不好。比如模拟退火比较适用于左边的图，而不适用于右边的图<br><img src='../../figure/人工智能笔记/1-Solving-Problems-by-Searching/energy_funtion_in_simulated_annealing.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></li></ul><h3 id="Local-beam-search"><a href="#Local-beam-search" class="headerlink" title="Local beam search"></a>Local beam search</h3><p>同时做 $k$ 次搜索</p><h3 id="Genetic-algorithms"><a href="#Genetic-algorithms" class="headerlink" title="Genetic algorithms"></a>Genetic algorithms</h3><p>遗传算法，模拟自然选择。遗传算法不一定能找到最优解，也不一定能收敛，但是可以限定遗传的代数来终止迭代。</p><p>遗传算法的术语：</p><ul><li>个体(individual)：任意一个候选解</li><li>种群(population)：所有的个体</li><li>适应度(fitness)：正在优化的目标函数</li><li>特性(trait)：个体的特征</li><li>基因组(genome)：个体所有的染色体，即特征的集合</li></ul><p>遗传算法的进行即问题的求解<br><img src='../../figure/人工智能笔记/1-Solving-Problems-by-Searching/vocabulary_in_GC.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><p>遗传算法的基本流程<br><img src='../../figure/人工智能笔记/1-Solving-Problems-by-Searching/general_framework_of_GC.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="Example-the-MAXONE-problem"><a href="#Example-the-MAXONE-problem" class="headerlink" title="Example: the MAXONE problem"></a>Example: the MAXONE problem</h4><p>即需要最大化字符串中1的数量</p><p>首先进行随机初始化<br>s1 = 1111010101 f (s1) = 7<br>s2 = 0111000101 f (s2) = 5<br>s3 = 1110110101 f (s3) = 7<br>s4 = 0100010011 f (s4) = 4<br>s5 = 1110111101 f (s5) = 8<br>s6 = 0100110000 f (s6) = 3</p><p>开始选择能够进行交叉遗传的个体：使用轮盘赌算法，根据适应度来决定被选中的概率，一个个体可能被选中多次。<br>s1’ = 1111010101 (s1)<br>s2’ = 1110110101 (s3)<br>s3’ = 1110111101 (s5)<br>s4’ = 0111000101 (s2)<br>s5’ = 0100010011 (s4)<br>s6’ = 1110111101 (s5)</p><p>然后将选中的个体两两配对，进行交叉重组。交叉有一定概率，比如说 $0.6$。交叉就是相互之间交换一小段染色体片段<br>Before crossover:<br>s1’ = 1111010101 s2’ = 1110110101<br>After crossover:<br>s1’’ = 1110110101 s2’’ = 1111010101</p><p>最后以一定的概率进行变异，变异有助于种群跳出局部解，能够提高种群多样性。<br>Initial strings   $\quad \quad$  After mutating<br>s1’’ = 1110110101 s1’’’ = 1110100101<br>s2’’ = 1111010101 s2’’’ = 1111110100<br>s3’’ = 1110111101 s3’’’ = 1110101111<br>s4’’ = 0111000101 s4’’’ = 0111000101<br>s5’’ = 0100011101 s5’’’ = 0100011101<br>s6’’ = 1110110011 s6’’’ = 1110110001</p>]]></content>
      
      
      <categories>
          
          <category> artificial intelligence </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ccf csp考试解题注意事项</title>
      <link href="/posts/b76167e5.html"/>
      <url>/posts/b76167e5.html</url>
      
        <content type="html"><![CDATA[<h3 id="关于输入输出"><a href="#关于输入输出" class="headerlink" title="关于输入输出"></a>关于输入输出</h3><p>假如一定需要使用 <code>cin</code> 和 <code>cout</code>，那么在 <code>main()</code> 函数开头加上<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>能够加速读写速度。</p><h3 id="关于浮点数"><a href="#关于浮点数" class="headerlink" title="关于浮点数"></a>关于浮点数</h3><p>浮点数相除如果除数和被除数都是整数，一定要加小数点，否则会执行整数相除。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> u == <span class="number">0</span> ? <span class="built_in">sqrt</span>((<span class="type">double</span>)<span class="number">1.0</span> / <span class="number">2.0</span>) : <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><h3 id="string类型字符串的读取"><a href="#string类型字符串的读取" class="headerlink" title="string类型字符串的读取"></a>string类型字符串的读取</h3><p>使用 <code>getline(cin, ___)</code> 读取字符串的时候，需要注意该函数可能会读取换行符。</p><h3 id="char-类型字符串的读取"><a href="#char-类型字符串的读取" class="headerlink" title="char[]类型字符串的读取"></a>char[]类型字符串的读取</h3><p>使用 <code>scanf(&quot;%s&quot;, &amp;__)</code> 读取字符串时，<code>char[]</code> 的长度一定要大于字符串最长长度，否则可能会出问题。</p><h3 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h3><p>对 <code>vector</code> 排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>()); <span class="comment">// 默认按升序排序</span></span><br></pre></td></tr></table></figure></p><p>对 <code>array</code> 排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; myArray = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(myArray.<span class="built_in">begin</span>(), myArray.<span class="built_in">end</span>()); <span class="comment">// 默认按升序排序</span></span><br></pre></td></tr></table></figure></p><p>对数组排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> myArray[] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">sizeof</span>(myArray) / <span class="built_in">sizeof</span>(myArray[<span class="number">0</span>]);</span><br><span class="line">std::<span class="built_in">sort</span>(myArray, myArray + size); <span class="comment">// 默认按升序排序</span></span><br></pre></td></tr></table></figure></p><p>自定义排序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较函数，按照 num 属性进行升序排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareByNum</span><span class="params">(<span class="type">const</span> MyStruct&amp; a, <span class="type">const</span> MyStruct&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.num &lt; b.num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;MyStruct&gt; myVector = &#123;</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="string">&quot;John&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="string">&quot;Alice&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">8</span>, <span class="string">&quot;Bob&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">&quot;David&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">9</span>, <span class="string">&quot;Eve&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">sort</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>(), compareByNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ccf-csp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++常见stl容器</title>
      <link href="/posts/3476ed94.html"/>
      <url>/posts/3476ed94.html</url>
      
        <content type="html"><![CDATA[<h2 id="常用stl容器的常用操作及其时间复杂度"><a href="#常用stl容器的常用操作及其时间复杂度" class="headerlink" title="常用stl容器的常用操作及其时间复杂度"></a>常用stl容器的常用操作及其时间复杂度</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>基于红黑树实现</p><ul><li>插入键值对，时间为 $O(\log n)$。使用 <code>operator[]</code> 或 <code>insert</code> 函数可以插入键-值对。如果键已经存在，<code>operator[]</code> 会更新对应的值，而 <code>insert</code> 则不会更新。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line"><span class="comment">// 使用 operator[]</span></span><br><span class="line">myMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">95</span>;</span><br><span class="line">myMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">85</span>;</span><br><span class="line"><span class="comment">// 使用 insert</span></span><br><span class="line">myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">90</span>));</span><br><span class="line">myMap.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;std::string, <span class="type">int</span>&gt;(<span class="string">&quot;Dave&quot;</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure></li><li>访问和修改值，时间为 $O(\log n)$。使用 <code>operator[]</code> 可以通过键访问和修改对应的值。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; myMap[<span class="string">&quot;Alice&quot;</span>] &lt;&lt; std::endl;  <span class="comment">// 访问值</span></span><br><span class="line">myMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">90</span>;  <span class="comment">// 修改值</span></span><br></pre></td></tr></table></figure></li><li>检查键是否存在，时间为 $O(\log n)$。<ul><li>使用 <code>count</code> 函数可以检查给定键在 <code>std::map</code> 中的出现次数。如果键存在，返回值大于 $0$；不存在则返回 $0$。</li><li>使用 <code>find</code> 函数可以检查给定键是否存在。如果键存在，返回指向该键-值对的迭代器；不存在则返回 <code>std::map::end()</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (myMap.<span class="built_in">count</span>(<span class="string">&quot;Alice&quot;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Alice&#x27;s score exists.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Alice&#x27;s score exists.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>删除键-值对，时间为 $O(\log n)$。使用 <code>erase</code> 函数可以删除给定键的键-值对。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myMap.<span class="built_in">erase</span>(<span class="string">&quot;Alice&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>获取键-值对个数，时间为 $O(1)$。使用 <code>size</code> 函数可以获取 <code>std::map</code> 中键-值对的个数。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Number of elements: &quot;</span> &lt;&lt; myMap.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li><li>清空 <code>std::map</code>，时间为 $O(n)$。使用 <code>clear</code> 函数可以清空 <code>std::map</code>，将其变为空。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myMap.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure></li><li>遍历 <code>std::map</code>，时间为 $O(n)$。使用迭代器可以遍历 <code>std::map</code> 中的所有键-值对。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;, Score: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (std::map&lt;std::string, <span class="type">int</span>&gt;::iterator it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;, Score: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>基于红黑树实现</p><ul><li>插入元素（<code>insert</code>）：平均时间复杂度为 $O(log n)$</li><li>删除元素（<code>erase</code>）：平均时间复杂度为 $O(log n)$</li><li>查找元素（<code>find</code>）：平均时间复杂度为 $O(log n)$</li><li>获取元素个数（<code>size</code>）：$O(1)$。</li><li>判断容器是否为空（<code>empty</code>）：$O(1)$。</li><li>遍历所有元素（使用迭代器）：$O(n)$。</li></ul><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><ul><li>插入元素（<code>push_back()</code>）<ul><li>平均时间复杂度: $O(1)$</li><li>最坏时间复杂度: $O(n)$，当需要重新分配内存时</li></ul></li><li>访问元素（使用索引）,平均时间复杂度: $O(1)$</li><li>删除元素（<code>pop_back()</code> 或 <code>erase()</code>），时间复杂度分别为 $O(1)$ 和 $O(n)$  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myVector.<span class="built_in">pop_back</span>();  <span class="comment">// 移除最后一个元素</span></span><br><span class="line">myVector.<span class="built_in">erase</span>(myVector.<span class="built_in">begin</span>() + <span class="number">1</span>);  <span class="comment">// 移除索引为 1 的元素</span></span><br></pre></td></tr></table></figure></li><li>获取元素个数（<code>size()</code>）：$O(1)$。</li><li>判断容器是否为空（<code>empty()</code>）：$O(1)$。</li><li>遍历所有元素（使用迭代器）：$O(n)$。</li><li>在指定位置插入元素（<code>insert()</code>），平均时间复杂度: $O(n)$  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it = myVector.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">myVector.<span class="built_in">insert</span>(it, <span class="number">20</span>);  <span class="comment">// 在索引为 1 的位置插入元素 20</span></span><br></pre></td></tr></table></figure></li><li>清空容器（<code>clear()</code>）：时间复杂度: $O(1)$</li></ul><p><code>vector</code> 的创建与初始化</p><ul><li>创建一维 <code>vector</code><ul><li>使用默认构造函数创建空的 <code>std::vector</code>，然后使用 <code>push_back()</code> 方法逐个添加元素。</li><li>使用初始化列表初始化 <code>std::vector</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;  <span class="comment">// 创建并初始化一维 vector</span></span><br></pre></td></tr></table></figure></li><li>使用构造函数并指定元素数量和默认值。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">myVector</span><span class="params">(<span class="number">5</span>, <span class="number">0</span>)</span></span>;  <span class="comment">// 创建包含 5 个元素，每个元素的值为 0 的一维 vector</span></span><br></pre></td></tr></table></figure></li></ul></li><li>创建二维 <code>vector</code><ul><li>使用默认构造函数和嵌套的 <code>std::vector</code> 创建一个空的二维 <code>std::vector</code>，然后使用嵌套的 <code>push_back()</code> 方法逐行添加元素。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; myVector;  <span class="comment">// 创建一个空的二维 vector</span></span><br><span class="line">myVector.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">myVector.<span class="built_in">push_back</span>(&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;);</span><br><span class="line">myVector.<span class="built_in">push_back</span>(&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;);</span><br></pre></td></tr></table></figure></li><li>使用初始化列表和嵌套的初始化列表初始化二维 <code>std::vector</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; myVector = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,  <span class="comment">// 第一行</span></span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,  <span class="comment">// 第二行</span></span><br><span class="line">        &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;   <span class="comment">// 第三行</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li><li>使用构造函数和嵌套的 <code>std::vector</code>，并指定行数和列数。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">myVector</span>(<span class="number">3</span>, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 创建一个 3x3 的二维 vector，每个元素的初始值为 0</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><ul><li>访问元素：使用下标操作符 <code>[]</code> 或 <code>at()</code> 方法可以访问指定位置的元素。时间复杂度：$O(1)$  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> element1 = myArray[<span class="number">0</span>];       <span class="comment">// 使用下标操作符访问第一个元素</span></span><br><span class="line"><span class="type">int</span> element2 = myArray.<span class="built_in">at</span>(<span class="number">2</span>);    <span class="comment">// 使用 at() 方法访问第三个元素</span></span><br></pre></td></tr></table></figure></li><li>获取元素个数（<code>size()</code>）：$O(1)$。</li><li>遍历所有元素（使用迭代器）：$O(n)$。</li><li>填充数组：<code>fill()</code> 方法可以将数组的所有元素设置为指定的值。时间复杂度：$O(n)$  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; myArray;</span><br><span class="line">myArray.<span class="built_in">fill</span>(<span class="number">0</span>);  <span class="comment">// 将数组的所有元素设置为 0</span></span><br></pre></td></tr></table></figure></li><li>比较操作：<code>==</code> 和 <code>!=</code> 操作符可用于比较两个数组是否相等。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; array1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; array2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">bool</span> isEqual = (array1 == array2);  <span class="comment">// 比较两个数组是否相等</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="遍历时删除元素"><a href="#遍历时删除元素" class="headerlink" title="遍历时删除元素"></a>遍历时删除元素</h3><p>需要使用指针进行遍历，否则删除时会出现问题<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator iter = affect_region.<span class="built_in">begin</span>(); iter != affect_region.<span class="built_in">end</span>();)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;r = *iter;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= r.second + <span class="number">7</span>)</span><br><span class="line">            iter = affect_region.<span class="built_in">erase</span>(iter);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            iter++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> stl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第26次ccf-csp认证试题解答</title>
      <link href="/posts/29c3e50a.html"/>
      <url>/posts/29c3e50a.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目1：归一化处理"><a href="#题目1：归一化处理" class="headerlink" title="题目1：归一化处理"></a><a href="http://118.190.20.162/view.page?gpid=T148">题目1：归一化处理</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">double</span> avg, var = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    avg = <span class="built_in">double</span>(sum) / n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        var += (a[i] - avg) * (a[i] - avg);</span><br><span class="line">    var /= n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, (a[i] - avg) / <span class="built_in">sqrt</span>(var));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目2：寻宝！大冒险！"><a href="#题目2：寻宝！大冒险！" class="headerlink" title="题目2：寻宝！大冒险！"></a><a href="http://118.190.20.162/view.page?gpid=T147">题目2：寻宝！大冒险！</a></h3><p>由于绿化覆盖的范围可能非常大($L&lt;10^{9}$)，因此直接将整幅图存下来是不现实的，我们只能将种有树的那些点存下来，数据规模为 $n&lt;1000$。</p><p>然后为了找到所有可能有宝藏的点，我们需要遍历所有的种树的点，然后检查附近区域能否与藏宝图一一对应。一次检查需要验证 $S^{2}$ 个点，完成整张绿化图的检查则需要验证 $O(nS^{2})$ 个点。如果验证每个点都需要遍历所有树，那时间复杂度为 $O(n^{2}S^{2})$，会出现问题。因此这里将每棵树的坐标从二维映射到一维，并且进行排序，查找时利用二分法，这样就能将时间复杂度降为 $O(S^{2}n \log n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> base = <span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">point tree[<span class="number">1000</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> tree_to_num[<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> treasure[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">have_tree</span><span class="params">(<span class="type">long</span> <span class="type">long</span> num_compare, <span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_possible_point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> n, <span class="type">int</span> S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, L, S;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;L, &amp;S);</span><br><span class="line">    <span class="type">int</span> possible_point = <span class="number">0</span>;     <span class="comment">// 可能的藏宝的地点的数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="comment">// 读取绿化图中所有的树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;(tree[i].x), &amp;(tree[i].y));</span><br><span class="line">        tree_to_num[i] = tree[i].x * base + tree[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(tree_to_num, tree_to_num + n); <span class="comment">// 对绿化图中的数进行排序，方便查找</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= S; ++i) <span class="comment">// 读取藏宝图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= S; ++j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(treasure[S - i][j]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[i].x + S &gt; L || tree[i].y + S &gt; L) <span class="comment">// 不能超出边界</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_possible_point</span>(tree[i].x, tree[i].y, n, S))</span><br><span class="line">            ++possible_point;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, possible_point);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_possible_point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> n, <span class="type">int</span> S)</span> <span class="comment">// 判断x，y这个点是不是可能的藏宝点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> num_compare;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= S; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= S; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            num_compare = (x + i) * base + (y + j);</span><br><span class="line">            <span class="keyword">if</span> (treasure[i][j] &amp;&amp; !<span class="built_in">have_tree</span>(num_compare, n))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!treasure[i][j] &amp;&amp; <span class="built_in">have_tree</span>(num_compare, n))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">have_tree</span><span class="params">(<span class="type">long</span> <span class="type">long</span> num_compare, <span class="type">int</span> n)</span> <span class="comment">// 给定一个long long值，判断这个位置有没有tree</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num_compare == tree_to_num[mid])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num_compare &gt; tree_to_num[mid])</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然如果直接使用 <code>set</code> 类型储存数据的话，也是同样的计算速度，代码会更简单一些。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; trees;</span><br><span class="line"><span class="type">int</span> treasure[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_possible_point</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; tree, <span class="type">int</span> S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, L, S;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;L, &amp;S);</span><br><span class="line">    <span class="type">int</span> possible_point = <span class="number">0</span>;     <span class="comment">// 可能的藏宝的地点的数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="comment">// 读取绿化图中所有的树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        trees.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(x, y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= S; ++i) <span class="comment">// 读取藏宝图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= S; ++j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(treasure[S - i][j]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; tree : trees)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree.first + S &gt; L || tree.second + S &gt; L) <span class="comment">// 不能超出边界</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_possible_point</span>(tree, S))</span><br><span class="line">            possible_point++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, possible_point);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_possible_point</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; tree, <span class="type">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= S; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= S; j++)</span><br><span class="line">            <span class="keyword">if</span> (trees.<span class="built_in">count</span>(<span class="built_in">make_pair</span>(tree.first + i, tree.second + j)) ^ treasure[i][j]) <span class="comment">// 这里没问题</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="题目3：角色授权"><a href="#题目3：角色授权" class="headerlink" title="题目3：角色授权"></a><a href="http://118.190.20.162/view.page?gpid=T146">题目3：角色授权</a></h3><p>本题可以先将存储角色及其属性，然后再存储每个用户所关联的角色。角色的数量为 $O(n)$，用户的数量为 $O(nm)$。</p><p>然后在进行查询时，查询所有的用户和用户组，查询次数为 $O(qn<em>{s})$，每次查询时都要遍历用户或用户组关联的所有角色，数量为 $O(n)$，查询每个角色是否具有权限的时间为 $O(\log n</em>{v})$，因此总时间为 $O(qn n_s \log n_v)$。时间复杂度虽然较大，但最后还是能过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">role_attr</span></span><br><span class="line">&#123;</span><br><span class="line">    set&lt;string&gt; oprt;          <span class="comment">// 操作类型</span></span><br><span class="line">    set&lt;string&gt; resource_cate; <span class="comment">// 资源种类</span></span><br><span class="line">    set&lt;string&gt; resource_name; <span class="comment">// 资源名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;string, role_attr&gt; role;   <span class="comment">// 角色，key为名称，value为属性</span></span><br><span class="line">map&lt;string, set&lt;string&gt;&gt; user; <span class="comment">// 用户，key为名称，value为绑定的角色名称的集合</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">have_access</span><span class="params">(string user_name, string oprt, string resource_cate, string resource_name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nv, no, nn;</span><br><span class="line">    string name, oprt, resource_cate, resource_name;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="comment">// 输入角色信息</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; name; <span class="comment">// 输入角色名</span></span><br><span class="line">        <span class="comment">// 接下来给角色各种属性</span></span><br><span class="line">        cin &gt;&gt; nv;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nv; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; oprt;</span><br><span class="line">            role[name].oprt.<span class="built_in">insert</span>(oprt);</span><br><span class="line">        &#125;</span><br><span class="line">        cin &gt;&gt; no;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; no; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; resource_cate;</span><br><span class="line">            role[name].resource_cate.<span class="built_in">insert</span>(resource_cate);</span><br><span class="line">        &#125;</span><br><span class="line">        cin &gt;&gt; nn;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; resource_name;</span><br><span class="line">            role[name].resource_name.<span class="built_in">insert</span>(resource_name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ns;</span><br><span class="line">    string role_name, user_name;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) <span class="comment">// 进行角色关联</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; role_name;</span><br><span class="line">        cin &gt;&gt; ns;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ns; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; user_name;                  <span class="comment">// 用户类型直接忽略</span></span><br><span class="line">            cin &gt;&gt; user_name;                  <span class="comment">// 输入用户姓名</span></span><br><span class="line">            user[user_name].<span class="built_in">insert</span>(role_name); <span class="comment">// 将角色名与用户名关联</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ng;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> authorized = <span class="literal">false</span>; <span class="comment">// 某个用户是否被授权了某种行为</span></span><br><span class="line">        queue&lt;string&gt; user_list;</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; user_name;</span><br><span class="line">        user_list.<span class="built_in">push</span>(user_name);</span><br><span class="line">        cin &gt;&gt; ng;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ng; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; user_name;</span><br><span class="line">            user_list.<span class="built_in">push</span>(user_name);</span><br><span class="line">        &#125;</span><br><span class="line">        cin &gt;&gt; oprt &gt;&gt; resource_cate &gt;&gt; resource_name;</span><br><span class="line">        <span class="keyword">while</span> (!user_list.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">have_access</span>(user_list.<span class="built_in">front</span>(), oprt, resource_cate, resource_name))</span><br><span class="line">            &#123;</span><br><span class="line">                authorized = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            user_list.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (authorized)</span><br><span class="line">            cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">have_access</span><span class="params">(string user_name, string oprt, string resource_cate, string resource_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (string role_name : user[user_name])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (role[role_name].oprt.<span class="built_in">count</span>(oprt) || role[role_name].oprt.<span class="built_in">count</span>(<span class="string">&quot;*&quot;</span>))</span><br><span class="line">            <span class="keyword">if</span> (role[role_name].resource_cate.<span class="built_in">count</span>(resource_cate) || role[role_name].resource_cate.<span class="built_in">count</span>(<span class="string">&quot;*&quot;</span>))</span><br><span class="line">                <span class="keyword">if</span> (role[role_name].resource_name.<span class="built_in">count</span>(resource_name) || role[role_name].resource_name.<span class="built_in">empty</span>())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码开头的 <code>ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);</code> 是用于加速读写的。因为这里需要以空格为划分读取字符串，所以使用 <code>scanf</code> 不太方便，于是使用了 <code>cin</code>。</p>]]></content>
      
      
      <categories>
          
          <category> ccf-csp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第27次ccf-csp认证试题解答</title>
      <link href="/posts/4ac43c2e.html"/>
      <url>/posts/4ac43c2e.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目1：如此编码"><a href="#题目1：如此编码" class="headerlink" title="题目1：如此编码"></a><a href="http://118.190.20.162/view.page?gpid=T153">题目1：如此编码</a></h3><p>使用整数相除和取模即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;                      <span class="comment">// n 为题目的数量，m 为加密后的数字</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">25</span>], b[<span class="number">25</span>], c[<span class="number">25</span>] = &#123;<span class="number">1</span>&#125;; <span class="comment">// a[i] 为第 i 道题的选项数量</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(a[i]));</span><br><span class="line">        c[i] = c[i - <span class="number">1</span>] * a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] = m / c[i - <span class="number">1</span>];</span><br><span class="line">        m %= c[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="题目2：何以包邮"><a href="#题目2：何以包邮" class="headerlink" title="题目2：何以包邮"></a><a href="http://118.190.20.162/view.page?gpid=T152">题目2：何以包邮</a></h3><p>类似背包问题，使用动态规划。要求花费最小，即删除的书价格最大。但是这里的动态规划无需计算所用情况，使用函数进行递归并且记忆一些情况即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cost[<span class="number">32</span>][<span class="number">300002</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 所有元素设为0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">drop</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> exc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cost[n][exc] == <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (exc &gt;= a[n])</span><br><span class="line">            cost[n][exc] = <span class="built_in">max</span>(<span class="built_in">drop</span>(a, n - <span class="number">1</span>, exc), <span class="built_in">drop</span>(a, n - <span class="number">1</span>, exc - a[n]) + a[n]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cost[n][exc] = <span class="built_in">drop</span>(a, n - <span class="number">1</span>, exc);</span><br><span class="line">    <span class="keyword">return</span> cost[n][exc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x;    <span class="comment">// n 为挑选的书的数量，x为包邮最低价</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">35</span>];   <span class="comment">// a[i] 为第 i 本书的价格</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 用于记录书的总价</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> excessive = sum - x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum - <span class="built_in">drop</span>(a, n, excessive));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="题目3：防疫大数据"><a href="#题目3：防疫大数据" class="headerlink" title="题目3：防疫大数据"></a><a href="http://118.190.20.162/submitlist.page?gpid=T151">题目3：防疫大数据</a></h3><p>本题如果完全按照题目的流程走，可以正好卡着时间线过。</p><p>由题目，我们知道一个用户进入风险名单，当且仅当：</p><blockquote><ul><li>该用户在近 7 日内曾经出现在接收到的漫游数据中，并且近 7 日内有到访某个地区的记录；</li><li>该用户在近 7 日内到访的地区在到访的那一日处于风险状态；</li><li>上述存在风险的地区自到访日至生成名单当日持续处于风险状态。</li></ul></blockquote><p>那么我们只需要把7天之内哪些地区在哪些日期处于高风险状态储存起来，然后遍历时间在7天之内的漫游数据，就能找出所有的风险用户。更新高风险地区的时间复杂度为 $O(nr<em>{i}\log r_i)$，遍历漫游数据并且声称风险名单的时间复杂度为 $O(n m</em>{i}\log m_i)$，再考虑一下系数，时间复杂度基本能满足题目要求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">roaming_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> u, r, d;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">roaming_data</span>(<span class="type">int</span> d, <span class="type">int</span> u, <span class="type">int</span> r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;u = u;</span><br><span class="line">        <span class="keyword">this</span>-&gt;r = r;</span><br><span class="line">        <span class="keyword">this</span>-&gt;d = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">roaming_data</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; affect_region; <span class="comment">// 储存地址和时间</span></span><br><span class="line">vector&lt;roaming_data&gt; items;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> ri, mi, pij;</span><br><span class="line">    <span class="type">int</span> d, u, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator iter = affect_region.<span class="built_in">begin</span>(); iter != affect_region.<span class="built_in">end</span>();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;r = *iter;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= r.second + <span class="number">7</span>)</span><br><span class="line">                iter = affect_region.<span class="built_in">erase</span>(iter);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                iter++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;ri, &amp;mi);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ri; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pij);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">7</span>; k++) <span class="comment">// 输入风险地区信息</span></span><br><span class="line">                affect_region.<span class="built_in">insert</span>(&#123;pij, i + k&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; mi; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;d, &amp;u, &amp;r); <span class="comment">// 输入漫游数据信息</span></span><br><span class="line">            items.<span class="built_in">push_back</span>(<span class="built_in">roaming_data</span>(d, u, r));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line"></span><br><span class="line">        vector&lt;roaming_data&gt; update_items;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; affect_users;</span><br><span class="line">        <span class="keyword">for</span> (roaming_data item : items)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i - item.d &gt;= <span class="number">7</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = item.d; j &lt;= i; j++) <span class="comment">// 考虑用户到达当地至今日，该地区是否一直处于高风险状态</span></span><br><span class="line">                <span class="keyword">if</span> (affect_region.<span class="built_in">count</span>(&#123;item.r, j&#125;) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">            &#123;</span><br><span class="line">                update_items.<span class="built_in">push_back</span>(item);</span><br><span class="line">                affect_users.<span class="built_in">insert</span>(item.u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        items.<span class="built_in">clear</span>();</span><br><span class="line">        items = update_items;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u : affect_users)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, u);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要在遍历一个 <code>set</code> 的时候删除一些元素，可以利用 <code>iter</code> 指针，如果直接遍历会导致报错。</p>]]></content>
      
      
      <categories>
          
          <category> ccf-csp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第28次ccf-csp认证试题解答</title>
      <link href="/posts/167ef031.html"/>
      <url>/posts/167ef031.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目1：现值计算"><a href="#题目1：现值计算" class="headerlink" title="题目1：现值计算"></a><a href="http://118.190.20.162/view.page?gpid=T160">题目1：现值计算</a></h3><p>直接算<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">double</span> interest, power = <span class="number">1</span>, profit = <span class="number">0</span>, earning;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %lf&quot;</span>, &amp;n, &amp;interest);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;earning);</span><br><span class="line">        profit += earning * power;</span><br><span class="line">        power /= (<span class="number">1</span> + interest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf&quot;</span>, profit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="题目2：训练计划"><a href="#题目2：训练计划" class="headerlink" title="题目2：训练计划"></a><a href="http://118.190.20.162/view.page?gpid=T159">题目2：训练计划</a></h3><p>利用题目已知条件：</p><blockquote><p>每项科目最多只依赖一项别的科目，且满足依赖科目的编号小于自己</p></blockquote><p>我们以在输入每项科目需要时间的时候直接计算出该科目能够开始的最早时间。如果想要知道最晚开始时间，则可以从后开始扫描，计算每一项后面的项目需要多长时间才能完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> time, finish_time; <span class="comment">// time 表示完成这个科目的时间，finish_time 表示完成这个任务加上后面所有任务的时间</span></span><br><span class="line">    <span class="type">int</span> start_time = <span class="number">1</span>;    <span class="comment">// 最早的开始的时间</span></span><br><span class="line">    node *depend = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> pre, time;</span><br><span class="line">    <span class="type">bool</span> pass = <span class="literal">true</span>; <span class="comment">// 表示是否能完成所有科目，如果能，pass为true</span></span><br><span class="line">    node sub[<span class="number">105</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pre);</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="number">0</span>)</span><br><span class="line">            sub[i].depend = &amp;sub[pre];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;time);</span><br><span class="line">        sub[i].time = time;</span><br><span class="line">        <span class="keyword">if</span> (sub[i].depend) <span class="comment">// 更新start_time</span></span><br><span class="line">            sub[i].start_time = sub[i].depend-&gt;start_time + sub[i].depend-&gt;time;</span><br><span class="line"></span><br><span class="line">        sub[i].finish_time = time; <span class="comment">// 初始化finish_time</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= <span class="number">1</span>; i--)                                                       <span class="comment">// 更新 finish_time</span></span><br><span class="line">        <span class="keyword">if</span> (sub[i].depend &amp;&amp; pass)                                                     <span class="comment">// 如果某个结点有父节点而且有必要计算</span></span><br><span class="line">            <span class="keyword">if</span> (sub[i].depend-&gt;finish_time &lt; sub[i].depend-&gt;time + sub[i].finish_time) <span class="comment">// 如果这条线路是最慢的</span></span><br><span class="line">            &#123;</span><br><span class="line">                sub[i].depend-&gt;finish_time = sub[i].depend-&gt;time + sub[i].finish_time; <span class="comment">// 更新</span></span><br><span class="line">                <span class="keyword">if</span> (sub[i].depend-&gt;finish_time &gt; n)                                    <span class="comment">// 超过总时间了</span></span><br><span class="line">                    pass = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, sub[i].start_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pass)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, n - sub[i].finish_time + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目3：JPEG解码"><a href="#题目3：JPEG解码" class="headerlink" title="题目3：JPEG解码"></a><a href="http://118.190.20.162/view.page?gpid=T158">题目3：JPEG解码</a></h3><p>在读取矩阵内容的时候注意一下顺序即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Q[<span class="number">8</span>][<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;          <span class="comment">// 量化矩阵</span></span><br><span class="line"><span class="type">int</span> M[<span class="number">8</span>][<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;          <span class="comment">// 图像矩阵</span></span><br><span class="line"><span class="type">double</span> transformed_M[<span class="number">8</span>][<span class="number">8</span>]; <span class="comment">// 经过余弦变换之后的图像矩阵</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scan_data</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_matrix</span><span class="params">(<span class="type">int</span> matrix[][<span class="number">8</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_matrix</span><span class="params">(<span class="type">double</span> matrix[][<span class="number">8</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quantify_matrix</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">alpha</span><span class="params">(<span class="type">int</span> u)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform_matrix</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) <span class="comment">// 读取量化矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(Q[i][j]));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="comment">// 扫描数据的个数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T); <span class="comment">// 要进行的任务</span></span><br><span class="line">    <span class="built_in">scan_data</span>(n);    <span class="comment">// 读取压缩后的矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">quantify_matrix</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">quantify_matrix</span>();</span><br><span class="line">        <span class="built_in">transform_matrix</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DEBUG: get invalid T!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_matrix</span>(M);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scan_data</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, p = <span class="number">0</span>, q = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(M[p][q]));</span><br><span class="line">        <span class="keyword">if</span> ((p + q) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="number">7</span>)</span><br><span class="line">                q++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="number">0</span>)</span><br><span class="line">                p++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                q--, p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="number">0</span>)</span><br><span class="line">                q++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="number">7</span>)</span><br><span class="line">                p++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                q++, p--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_matrix</span><span class="params">(<span class="type">int</span> matrix[][<span class="number">8</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_matrix</span><span class="params">(<span class="type">double</span> matrix[][<span class="number">8</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\t&quot;</span>, matrix[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quantify_matrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j)</span><br><span class="line">            M[i][j] *= Q[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">alpha</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == <span class="number">0</span> ? <span class="built_in">sqrt</span>((<span class="type">double</span>)<span class="number">1.0</span> / <span class="number">2.0</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform_matrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            transformed_M[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; <span class="number">8</span>; ++u)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; <span class="number">8</span>; ++v)</span><br><span class="line">                &#123;</span><br><span class="line">                    transformed_M[i][j] += <span class="built_in">alpha</span>(u) * <span class="built_in">alpha</span>(v) * M[u][v] * <span class="built_in">cos</span>(pi / <span class="number">8</span> * (i + (<span class="type">double</span>)<span class="number">1.0</span> / <span class="number">2.0</span>) * u) * <span class="built_in">cos</span>(pi / <span class="number">8</span> * (j + (<span class="type">double</span>)<span class="number">1.0</span> / <span class="number">2.0</span>) * v);</span><br><span class="line">                &#125;</span><br><span class="line">            transformed_M[i][j] = <span class="number">1.0</span> / <span class="number">4.0</span> * transformed_M[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            M[i][j] = <span class="built_in">round</span>(transformed_M[i][j] + <span class="number">128</span>);</span><br><span class="line">            M[i][j] = <span class="built_in">min</span>(M[i][j], <span class="number">255</span>);</span><br><span class="line">            M[i][j] = <span class="built_in">max</span>(M[i][j], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++在进行浮点数运算的时候，记得将运算过程中的常数都用浮点数表示，否则编译器会将其是为整数，相除时也执行整数相除。</p>]]></content>
      
      
      <categories>
          
          <category> ccf-csp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第29次ccf-csp认证试题解答</title>
      <link href="/posts/75792915.html"/>
      <url>/posts/75792915.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目1：土地丈量"><a href="#题目1：土地丈量" class="headerlink" title="题目1：土地丈量"></a><a href="http://118.190.20.162/view.page?gpid=T165">题目1：土地丈量</a></h3><p>本题的重点在于计算两个矩形相交的面积。经过分析和观察可以发现，假如两个矩形左下角和右上角的坐标分别为 $(x_1,y_1), (x_2,y_2)$ 和 $(x_3,y_3), (x_4, y_4)$，同时两矩形相交，那么相交得到的矩形左下角坐标为：$(\max(x_1,x_3), \max(y_1, y_3))$，右上角为 $(\min(x_2,x_4), \min(y_2,y_4))$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">rectangle</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">rectangle</span>(<span class="type">int</span> left, <span class="type">int</span> bottom, <span class="type">int</span> right, <span class="type">int</span> top)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = left, <span class="keyword">this</span>-&gt;right = right;</span><br><span class="line">        <span class="keyword">this</span>-&gt;bottom = bottom, <span class="keyword">this</span>-&gt;top = top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (right - left) * (top - bottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> bottom, <span class="type">int</span> right, <span class="type">int</span> top)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = left, <span class="keyword">this</span>-&gt;right = right;</span><br><span class="line">        <span class="keyword">this</span>-&gt;bottom = bottom, <span class="keyword">this</span>-&gt;top = top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left, right, bottom, top;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_insert</span><span class="params">(rectangle r1, rectangle r2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r1.left &gt;= r2.right || r2.left &gt;= r1.right || r1.bottom &gt;= r2.top || r2.bottom &gt;= r1.top)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert_area</span><span class="params">(rectangle r1, rectangle r2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">is_insert</span>(r1, r2))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">rectangle <span class="title">insert_r</span><span class="params">(max(r1.left, r2.left), max(r1.bottom, r2.bottom), min(r1.right, r2.right), min(r1.top, r2.top))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> insert_r.<span class="built_in">get_area</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left, bottom, right, top;</span><br><span class="line">    <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="function">rectangle <span class="title">new_r</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, a, b)</span>, r</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;left, &amp;bottom, &amp;right, &amp;top);</span><br><span class="line">        r.<span class="built_in">resize</span>(left, bottom, right, top);</span><br><span class="line">        area += <span class="built_in">insert_area</span>(r, new_r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, area);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个结构体，假如需要定义其构造函数，有时需要注意重载一个默认构造函数。</p><h3 id="题目2：垦田计划"><a href="#题目2：垦田计划" class="headerlink" title="题目2：垦田计划"></a><a href="http://118.190.20.162/view.page?gpid=T164">题目2：垦田计划</a></h3><p>本题只需假设一个最短的时间，然后不断计算查看已有资源是否足够即可。同时假定的最短时间使用二分法进行不断尝试。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; times;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; com_resources;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">satisfy</span><span class="params">(<span class="type">int</span> guess_time)</span> <span class="comment">// 手上的资源足够让总时间减少到guess_time</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> require_resource = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (times[i] &lt;= guess_time)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        require_resource += (times[i] - guess_time) * com_resources[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (require_resource &lt;= m)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> time, com_resource;</span><br><span class="line">    <span class="type">int</span> max_time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 读取数据，并且获得最长时间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;time, &amp;com_resource);</span><br><span class="line">        <span class="keyword">if</span> (time &gt; max_time)</span><br><span class="line">            max_time = time;</span><br><span class="line">        times.<span class="built_in">push_back</span>(time);</span><br><span class="line">        com_resources.<span class="built_in">push_back</span>(com_resource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">satisfy</span>(k))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, k);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left_bound = k, right_bound = max_time;</span><br><span class="line">    <span class="type">int</span> guess_time = (left_bound + right_bound) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left_bound &lt; right_bound)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">satisfy</span>(guess_time))</span><br><span class="line">            right_bound = guess_time;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left_bound = guess_time + <span class="number">1</span>;</span><br><span class="line">        guess_time = (left_bound + right_bound) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, guess_time);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里因为 <code>n</code> 的不确定性使用了 <code>vector</code>，事实上直接开一个足够大的数组也是可以的。</p><h3 id="题目3：LDAP"><a href="#题目3：LDAP" class="headerlink" title="题目3：LDAP"></a><a href="http://118.190.20.162/view.page?gpid=T163">题目3：LDAP</a></h3><p>本题只要使用递归来解析语法即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">user_attr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> label = <span class="number">0</span>; <span class="comment">// 属性的编号</span></span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>; <span class="comment">// 属性的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">user</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dn = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> attr_num = <span class="number">0</span>;</span><br><span class="line">    user_attr attr[<span class="number">500</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user usr[<span class="number">2500</span>];          <span class="comment">// 定义用户</span></span><br><span class="line">string expr[<span class="number">500</span>];        <span class="comment">// 定义表达式</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; matched_usr; <span class="comment">// 用于储存最终输出的用户</span></span><br><span class="line"><span class="type">int</span> n, m;                <span class="comment">// n为用户的数量，m为表达式的数量</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">translate_base_expr</span><span class="params">(string expr)</span></span>;                  <span class="comment">// 处理简单语句</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">translate_expr</span><span class="params">(string expr)</span></span>;                       <span class="comment">// 处理一般语句</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">match_expr</span><span class="params">(<span class="type">int</span> usr, <span class="type">int</span> label, <span class="type">int</span> value, <span class="type">bool</span> positive)</span></span>; <span class="comment">// 判断某个用户的某个属性是否具有该值</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_union</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;vec1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;vec2)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vec1, vector&lt;<span class="type">int</span>&gt; vec2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> attr_num;               <span class="comment">// 要输入的属性值的个数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);            <span class="comment">// 输入用户的数目</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 输入用户的dn值和属性</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;(usr[i].dn), &amp;(usr[i].attr_num));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; usr[i].attr_num; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;(usr[i].attr[j].label), &amp;(usr[i].attr[j].value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="built_in">getline</span>(cin, expr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        matched_usr = <span class="built_in">translate_expr</span>(expr[i]);</span><br><span class="line">        <span class="built_in">sort</span>(matched_usr.<span class="built_in">begin</span>(), matched_usr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> usr_dn : matched_usr)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, usr_dn);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">match_expr</span><span class="params">(<span class="type">int</span> usr_id, <span class="type">int</span> label, <span class="type">int</span> value, <span class="type">bool</span> positive)</span> <span class="comment">// 这里的usr_id和dn不同</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = usr[usr_id].attr_num - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (usr[usr_id].attr[i].label == label) <span class="comment">// 找到正确的attr了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (usr[usr_id].attr[i].label &gt; label)</span><br><span class="line">            right = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="comment">// 该用户没有该属性</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        i = (left + right) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (positive)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (usr[usr_id].attr[i].value == value)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (usr[usr_id].attr[i].value == value)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">translate_base_expr</span><span class="params">(string expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; selected_usr;</span><br><span class="line">    selected_usr.<span class="built_in">reserve</span>(<span class="number">2500</span>);</span><br><span class="line">    <span class="type">bool</span> positive, overturn = <span class="literal">false</span>; <span class="comment">// overturn决定现在在读取label还是value</span></span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>, label = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; expr.<span class="built_in">length</span>(); ++i) <span class="comment">// 处理base_expr，读取label和value</span></span><br><span class="line">        <span class="keyword">if</span> (expr[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; expr[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (overturn)</span><br><span class="line">                value = value * <span class="number">10</span> + (expr[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                label = label * <span class="number">10</span> + (expr[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            overturn = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (expr[i] == <span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">                positive = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (expr[i] == <span class="string">&#x27;~&#x27;</span>)</span><br><span class="line">                positive = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;DEBUG: something go wrong in operater!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">match_expr</span>(i, label, value, positive))</span><br><span class="line">            selected_usr.<span class="built_in">push_back</span>(usr[i].dn);</span><br><span class="line">    <span class="keyword">return</span> selected_usr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">translate_expr</span><span class="params">(string expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; selected_usr;</span><br><span class="line">    selected_usr.<span class="built_in">reserve</span>(<span class="number">2500</span>);</span><br><span class="line">    <span class="type">bool</span> vec_union; <span class="comment">// 如果是|，则就是union；如果是&amp;，则为intersection</span></span><br><span class="line">    <span class="type">int</span> left_brac_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> second_expr_start, second_expr_len, first_expr_len, first_expr_start = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expr[<span class="number">0</span>] != <span class="string">&#x27;&amp;&#x27;</span> &amp;&amp; expr[<span class="number">0</span>] != <span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">translate_base_expr</span>(expr);</span><br><span class="line">    <span class="keyword">if</span> (expr[<span class="number">0</span>] == <span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">        vec_union = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (expr[<span class="number">0</span>] == <span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">        vec_union = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; expr.<span class="built_in">length</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span> (expr[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            left_brac_cnt++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (expr[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> (left_brac_cnt &gt; <span class="number">0</span>)</span><br><span class="line">                left_brac_cnt--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left_brac_cnt == <span class="number">0</span> &amp;&amp; expr[i + <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                second_expr_start = i + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;DEBUG: something went wrong in bracket paring!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    first_expr_len = (second_expr_start - <span class="number">2</span>) - first_expr_start;</span><br><span class="line">    second_expr_len = (expr.<span class="built_in">length</span>() - <span class="number">1</span>) - second_expr_start;</span><br><span class="line"></span><br><span class="line">    string sub_expr1 = expr.<span class="built_in">substr</span>(first_expr_start, first_expr_len);</span><br><span class="line">    string sub_expr2 = expr.<span class="built_in">substr</span>(second_expr_start, second_expr_len);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; selected_usr1 = <span class="built_in">translate_expr</span>(sub_expr1);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; selected_usr2 = <span class="built_in">translate_expr</span>(sub_expr2);</span><br><span class="line">    <span class="keyword">if</span> (vec_union)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_union</span>(selected_usr1, selected_usr2);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_intersection</span>(selected_usr1, selected_usr2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_union</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;vec1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;vec2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    result.<span class="built_in">reserve</span>(vec1.<span class="built_in">size</span>() + vec2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    result.<span class="built_in">insert</span>(result.<span class="built_in">end</span>(), vec1.<span class="built_in">begin</span>(), vec1.<span class="built_in">end</span>());</span><br><span class="line">    result.<span class="built_in">insert</span>(result.<span class="built_in">end</span>(), vec2.<span class="built_in">begin</span>(), vec2.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">    result.<span class="built_in">erase</span>(<span class="built_in">unique</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()), result.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vec1, vector&lt;<span class="type">int</span>&gt; vec2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    result.<span class="built_in">reserve</span>(<span class="built_in">min</span>(vec1.<span class="built_in">size</span>(), vec2.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="built_in">sort</span>(vec1.<span class="built_in">begin</span>(), vec1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(vec2.<span class="built_in">begin</span>(), vec2.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pointer1 = <span class="number">0</span>, pointer2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pointer1 &lt; vec1.<span class="built_in">size</span>() &amp;&amp; pointer2 &lt; vec2.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vec1[pointer1] == vec2[pointer2])</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec1[pointer1]);</span><br><span class="line">            pointer1++;</span><br><span class="line">            pointer2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vec1[pointer1] &gt; vec2[pointer2])</span><br><span class="line">            pointer2++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pointer1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ccf-csp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第30次ccf csp认证试题解答</title>
      <link href="/posts/7608075b.html"/>
      <url>/posts/7608075b.html</url>
      
        <content type="html"><![CDATA[<h3 id="问题1：重复局面"><a href="#问题1：重复局面" class="headerlink" title="问题1：重复局面"></a><a href="http://118.190.20.162/view.page?gpid=T170">问题1：重复局面</a></h3><p>本题只需读取数据然后直接比较即可。读取 <code>string</code> 类型可以直接使用 <code>cin&gt;&gt;</code>，或者使用 <code>getline(cin, ___)</code>，在使用后者时需要注意，<code>getline</code> 会读取缓存区中的 <code>\n</code>，因此读取之前可能需要先用一个 <code>cin.get()</code> 读取一下换行符。</p><p>如果是读取 <code>char[]</code> 类型的字符串，使用 <code>scanf</code> 即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string chess[<span class="number">100</span>][<span class="number">8</span>];</span><br><span class="line">    <span class="type">int</span> count[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        count[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">            <span class="built_in">getline</span>(cin, chess[i][j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) <span class="comment">// 检查之前的所有棋盘</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) <span class="comment">// 检查每个棋盘的某一行是否相同</span></span><br><span class="line">                <span class="keyword">if</span> (chess[i][j] != chess[k][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">            &#123;</span><br><span class="line">                count[i] = count[k] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码中的 <code>getline(cin, chess[i][j]);</code> 换成 <code>cin&gt;&gt;chess[i][j]</code>，并且删除 <code>cin.get()</code>，效果相同。</li><li>如果想要使用 <code>scanf</code>，则需将 <code>string chess[100][8]</code> 改为 <code>char chess[100][8][10]</code>(最后一个维度的大小只要比8大就行，如果正好等于8会出现字符串输出问题)，同时将 <code>chess[i][j] != chess[k][j]</code> 改为 <code>strcmp(chess[i][j], chess[k][j]) != 0</code>。</li></ul><h3 id="问题2：矩阵运算"><a href="#问题2：矩阵运算" class="headerlink" title="问题2：矩阵运算"></a><a href="http://118.190.20.162/view.page?gpid=T169">问题2：矩阵运算</a></h3><p>本题需要注意矩阵乘法可以进行交换，可以通过这种方法降低计算复杂度。比如有三个矩阵，形状分别为 $m\times n, n\times l, l\times p$，那么乘法运行的次数共为 $m\times n\times l+n\times l\times p$。</p><p>在本题中，假如按照题目给定的 $(W\cdot (Q\times K^{\mathrm{T}})\times V)$ 进行矩阵相乘，计算的复杂度为 $O(n^{2}d)$，考虑到 $n\le 10^{4}, d\le 20$，计算复杂度太大。因此可以利用结合律，将运算顺序改为 $(W\cdot Q)\times (K^{\mathrm{T}}\times V)$，计算复杂度降为 $O(d^{2}n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;d);</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">Q</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(d));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">K</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(d));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">V</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(d));</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">W</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; d; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Q[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; d; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;K[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; d; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;V[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;W[i]);</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(d));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">tmp_small</span>(d, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(d));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Q = W · Q</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; d; j++)</span><br><span class="line">            Q[i][j] *= W[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KT × V</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; d; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                tmp_small[i][j] += K[k][i] * V[k][j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Q × (KT × V)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; d; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; d; k++)</span><br><span class="line">                res[i][j] += Q[i][k] * tmp_small[k][j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; d; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld%c&quot;</span>, res[i][j], j == d - <span class="number">1</span> ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处因为 <code>n</code> 和 <code>d</code> 都是在输入之后才知道的量，因此使用 <code>vector</code> 进行数据的存储。<code>vector&lt;vector&lt;int&gt;&gt; Q(n, vector&lt;int&gt;(d));</code> 是 <code>vector</code> 初始化的一种方式，表示创建了一个大小为 <code>n</code> 的 <code>vector</code>，其中每个元素都是一个大小为 <code>d</code> 的 <code>vector&lt;int&gt;</code>。</p><h3 id="问题3：解压缩"><a href="#问题3：解压缩" class="headerlink" title="问题3：解压缩"></a><a href="http://118.190.20.162/view.page?gpid=T168">问题3：解压缩</a></h3><p>按照题目的要求做就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num_unzip = <span class="number">0</span>; <span class="comment">// 表示已经解压缩的字节数</span></span><br><span class="line"><span class="type">char</span> unzip_data[<span class="number">1</span> &lt;&lt; <span class="number">22</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_character</span><span class="params">(<span class="type">char</span> &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_byte</span><span class="params">(<span class="type">char</span> &amp;c1, <span class="type">char</span> &amp;c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">get_character</span>(c1);</span><br><span class="line">    <span class="built_in">get_character</span>(c2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_byte</span><span class="params">(<span class="type">char</span> c1, <span class="type">char</span> c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unzip_data[num_unzip * <span class="number">2</span>] = c1;</span><br><span class="line">    unzip_data[num_unzip * <span class="number">2</span> + <span class="number">1</span>] = c2;</span><br><span class="line">    num_unzip++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">byte_to_int</span><span class="params">(<span class="type">char</span> &amp;c1, <span class="type">char</span> &amp;c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n1, n2;</span><br><span class="line">    n1 = c1 &lt;= <span class="string">&#x27;9&#x27;</span> ? c1 - <span class="string">&#x27;0&#x27;</span> : c1 - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    n2 = c2 &lt;= <span class="string">&#x27;9&#x27;</span> ? c2 - <span class="string">&#x27;0&#x27;</span> : c2 - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> n1 * <span class="number">16</span> + n2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read_boot_domain</span><span class="params">(<span class="type">int</span> &amp;length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> char1, char2;</span><br><span class="line">    <span class="type">int</span> base = <span class="number">1</span>, num_byte = <span class="number">0</span>; <span class="comment">// base为基，num_byte为现在已经读取的字节数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)                <span class="comment">// 读取引导区</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">get_byte</span>(char1, char2);</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">byte_to_int</span>(char1, char2);</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">128</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            length += num * base;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        length += (num - <span class="number">128</span>) * base;</span><br><span class="line">        base *= <span class="number">128</span>;</span><br><span class="line">        num_byte += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num_byte + <span class="number">1</span>; <span class="comment">// 在break的地方还要加1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read_literal</span><span class="params">(<span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, extend_type = <span class="number">0</span>; <span class="comment">// l是字面量的长度，extend_type是表示后面有几个字节用来存储字面量长度</span></span><br><span class="line">    <span class="type">char</span> c1, c2;</span><br><span class="line">    <span class="comment">// 获得字面量长度</span></span><br><span class="line">    <span class="keyword">if</span> (type / <span class="number">4</span> &lt;= <span class="number">59</span>)</span><br><span class="line">        l = type / <span class="number">4</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        extend_type = type / <span class="number">4</span> - <span class="number">59</span>;</span><br><span class="line">        <span class="type">int</span> base = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; extend_type; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">get_byte</span>(c1, c2);</span><br><span class="line">            l += <span class="built_in">byte_to_int</span>(c1, c2) * base;</span><br><span class="line">            base *= <span class="number">256</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取字面量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">get_byte</span>(c1, c2);</span><br><span class="line">        <span class="built_in">print_byte</span>(c1, c2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l + extend_type + <span class="number">1</span>; <span class="comment">// 返回的数表示这个元素占用的字节数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_trace_helper</span><span class="params">(<span class="type">int</span> o, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> start_point = num_unzip - o;</span><br><span class="line">    <span class="keyword">if</span> (o &gt;= l)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">            <span class="built_in">print_byte</span>(unzip_data[(start_point + i) * <span class="number">2</span>], unzip_data[(start_point + i) * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">            <span class="built_in">print_byte</span>(unzip_data[(start_point + i % o) * <span class="number">2</span>], unzip_data[(start_point + i % o) * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read_trace1</span><span class="params">(<span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c1, c2;</span><br><span class="line">    <span class="type">int</span> l = (type / <span class="number">4</span>) % <span class="number">8</span> + <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> o = type / <span class="number">32</span>;</span><br><span class="line">    <span class="built_in">get_byte</span>(c1, c2);</span><br><span class="line">    o = o * <span class="number">256</span> + <span class="built_in">byte_to_int</span>(c1, c2);</span><br><span class="line">    <span class="built_in">read_trace_helper</span>(o, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 返回的数表示这个元素占用的字节数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read_trace2</span><span class="params">(<span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c1, c2;</span><br><span class="line">    <span class="type">int</span> l = type / <span class="number">4</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">get_byte</span>(c1, c2);</span><br><span class="line">    <span class="type">int</span> o = <span class="built_in">byte_to_int</span>(c1, c2);</span><br><span class="line">    <span class="built_in">get_byte</span>(c1, c2);</span><br><span class="line">    o = o + <span class="built_in">byte_to_int</span>(c1, c2) * <span class="number">256</span>;</span><br><span class="line">    <span class="built_in">read_trace_helper</span>(o, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">// 返回的数表示这个元素占用的字节数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> char1, char2;                 <span class="comment">// 一个字节的两个字符</span></span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;                    <span class="comment">// length为原始数据的长度</span></span><br><span class="line">    <span class="type">int</span> input;                         <span class="comment">// 输入的字节数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);               <span class="comment">// 读取接下来要输入的字节数</span></span><br><span class="line">    input -= <span class="built_in">read_boot_domain</span>(length); <span class="comment">// 读取引导域，获得原始数据长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (input &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">get_byte</span>(char1, char2);</span><br><span class="line">        <span class="type">int</span> type = <span class="built_in">byte_to_int</span>(char1, char2); <span class="comment">// 读取每个元素的第一个字节</span></span><br><span class="line">        <span class="keyword">switch</span> (type % <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:                          <span class="comment">// 假如末两位为00</span></span><br><span class="line">            input -= <span class="built_in">read_literal</span>(type); <span class="comment">// 元素为字面量，函数返回输入字节的个数</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 假如末两位为01</span></span><br><span class="line">            input -= <span class="built_in">read_trace1</span>(type);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            input -= <span class="built_in">read_trace2</span>(type);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;DEBUG: something went wrong!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_unzip; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c%c&quot;</span>, unzip_data[i * <span class="number">2</span>], unzip_data[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">7</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ccf-csp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Multilayer perceptrons</title>
      <link href="/posts/abee6984.html"/>
      <url>/posts/abee6984.html</url>
      
        <content type="html"><![CDATA[<h1 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h1><h2 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h2><p>人工智能最早的模型。给定输入 $\bm{x}$，权重 $\bm{w}$，和偏移 $b$，感知机输出</p><script type="math/tex; mode=display">o = \sigma(<\bm{w},\bm{x}>+b) \quad \sigma(x) = \begin{cases}    1, \text{if } x>0 \\ -1, \text{otherwise}\end{cases}</script><p>感知机在这里就相当于是一个二分类的问题。</p><h3 id="训练感知机"><a href="#训练感知机" class="headerlink" title="训练感知机"></a>训练感知机</h3><p>如果 $y_i[<w, x_i>+b]\le 0$，那么 $w \leftarrow w+y_i x_i, b \leftarrow b+y_i$，知道所有类都分类正确。</p><p>这种算法等价于使用批量大小为 $1$ 的梯度下降，并且使用的损失函数为 $l(y, \bm{x}, \bm{w})=\max (0, -y&lt;\bm{w}, \bm{x}&gt;)$。</p><h3 id="收敛定理"><a href="#收敛定理" class="headerlink" title="收敛定理"></a>收敛定理</h3><p>因为感知机是一个很简单的模型，因此它有一个很好的收敛定理。</p><p>假设数据在半径 $r$ 内，$\exists \rho&gt;0$，使得对于 $\left| \bm{w} \right|_{}^{2}b^{2}\le 1$，有 $y(\bm{x}^{\mathrm{T}}\bm{w}+b)\ge \rho$。那么感知机保证能在 $\displaystyle \frac{r^{2}+1}{\rho^{2}}$ 步后收敛。</p><h3 id="XOR问题"><a href="#XOR问题" class="headerlink" title="XOR问题"></a>XOR问题</h3><p>感知机不能拟合XOR问题，因为它只能产生线性的分割面。<br><img src='../../figure/动手学深度学习/4-Multilayer-perceptrons/XOR_problem.png' width=250 style="display: block; margin-left: auto; margin-right: auto;"></p><p>比如上图所示的分类问题就无法用感知机直接解决。</p><h2 id="多层感知机-1"><a href="#多层感知机-1" class="headerlink" title="多层感知机"></a>多层感知机</h2><p>从对感知机的讨论中，我们可以看出简单的线性模型无法解决XOR问题。因此我们考虑先学习蓝色的线，再学习黄色的线，将两个进行组合，从而得到正确的结果。</p><p><img src='../../figure/动手学深度学习/4-Multilayer-perceptrons/XOR_problem_solver.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="单隐藏层——单分类"><a href="#单隐藏层——单分类" class="headerlink" title="单隐藏层——单分类"></a>单隐藏层——单分类</h3><ul><li>输入层 $\bm{x}\in \mathbb{R}^{n}$</li><li>隐藏层 $\bm{W_1} \in \mathbb{R}^{m\times n}, \bm{b_1}\in \mathbb{R}^{m}$</li><li>输出层 $\bm{w_2}\in \mathbb{R}^{m}, b_2\in \mathbb{R}$</li></ul><script type="math/tex; mode=display">\begin{aligned}\bm{h} &= \sigma (\bm{W_1}\bm{x}+\bm{b_1})\\o&=\bm{w_2}^{\mathrm{T}}\bm{h}+b_2\end{aligned}</script><p>$\sigma$ 是一个按元素的非线性激活函数。激活函数不能是线性的，否则会导致输出 $o$ 依然是一个相对 $\bm{x}$ 的线性函数，那么没有隐藏层的感知机就没有区别了。</p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><h4 id="Sigmoid-激活函数"><a href="#Sigmoid-激活函数" class="headerlink" title="Sigmoid 激活函数"></a>Sigmoid 激活函数</h4><script type="math/tex; mode=display">\operatorname{sigmoid}(x) = \frac{1}{1+\exp (-x)}</script><h4 id="Tanh函数"><a href="#Tanh函数" class="headerlink" title="Tanh函数"></a>Tanh函数</h4><script type="math/tex; mode=display">\tanh(x)=\frac{1-\exp (-2x)}{1+\exp (2x)}</script><h4 id="ReLU激活函数"><a href="#ReLU激活函数" class="headerlink" title="ReLU激活函数"></a>ReLU激活函数</h4><script type="math/tex; mode=display">\operatorname{ReLU}(x) = \max (x, 0)</script><p>ReLU的优势在于比较简单，计算足够快。</p><h3 id="多类分类"><a href="#多类分类" class="headerlink" title="多类分类"></a>多类分类</h3><p>和 Softmax 基本一致，只是多了个隐藏层。</p><ul><li>输入层 $\bm{x}\in \mathbb{R}^{n}$</li><li>隐藏层 $\bm{W_1} \in \mathbb{R}^{m\times n}, \bm{b_1}\in \mathbb{R}^{m}$</li><li>输出层 $\bm{W_2}\in \mathbb{R}^{m\times k}, b_2\in \mathbb{R}^{k}$</li></ul><script type="math/tex; mode=display">\begin{aligned}\bm{h} &= \sigma (\bm{W_1}\bm{x}+\bm{b_1})\\\bm{o}&=\bm{W_2}^{\mathrm{T}}\bm{h}+\bm{b_2} \\\bm{y}&=\operatorname{softmax}(\bm{o})\end{aligned}</script><h3 id="多隐藏层"><a href="#多隐藏层" class="headerlink" title="多隐藏层"></a>多隐藏层</h3><p>在中间多加几层就行。</p><p>多隐藏层的每一层的大小一般慢慢减小，不断地提取信息。同时最下面的隐藏层也可以相对输入稍微大一些。<br><img src='../../figure/动手学深度学习/4-Multilayer-perceptrons/multi_hidden_layers.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><ul><li>为什么神经网络倾向于增加网络的层数而不是某一层神经元的个数？<ul><li>在相同计算量的情况下，更深的网络更好训练一些。浅层但是很胖的网络理论效果应该和计算量相同的深度网络一样，但是这需要一次学习大量数据特征，不好训练，容易导致过拟合；而深层的网络可以理解为一步步地学习数据特征。</li></ul></li><li>relu为什么管用？<ul><li>激活函数的本质就是引入非线性性，因此对激活函数的复杂性没有太多要求。</li></ul></li><li>如何设置模型的深度和宽度？<ul><li>遇到一个问题，可以先直接使用线性模型算一次，然后在加一层，并且试出一个比较好的结果，再不断向上增加隐藏层，继续尝试。</li></ul></li></ul><h1 id="模型选择-过拟合和欠拟合"><a href="#模型选择-过拟合和欠拟合" class="headerlink" title="模型选择+过拟合和欠拟合"></a>模型选择+过拟合和欠拟合</h1><h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><h3 id="训练误差和泛化误差"><a href="#训练误差和泛化误差" class="headerlink" title="训练误差和泛化误差"></a>训练误差和泛化误差</h3><ul><li>训练误差：模型在训练数据上的误差</li><li>泛化误差：模型在新数据上的误差</li></ul><h3 id="验证数据集和测试数据集"><a href="#验证数据集和测试数据集" class="headerlink" title="验证数据集和测试数据集"></a>验证数据集和测试数据集</h3><ul><li>验证数据集：一个用来评估模型好坏的数据集<ul><li>帮助调整超参数</li></ul></li><li>测试数据集：只用一次的数据集</li></ul><h3 id="K-则交叉验证"><a href="#K-则交叉验证" class="headerlink" title="K-则交叉验证"></a>K-则交叉验证</h3><p>在没有足够多的数据时使用</p><ul><li>将数据分成 $K$ 块<ul><li>使用第 $i$ 块作为验证数据集，其余的作为训练数据集</li></ul></li><li>报告 $K$ 个验证集误差的平均</li></ul><p>常用：$K=5$ 或 $10$</p><h2 id="过拟合和欠拟合"><a href="#过拟合和欠拟合" class="headerlink" title="过拟合和欠拟合"></a>过拟合和欠拟合</h2><p><img src='../../figure/动手学深度学习/4-Multilayer-perceptrons/overfitting_and_underfitting.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="模型容量"><a href="#模型容量" class="headerlink" title="模型容量"></a>模型容量</h3><ul><li>低容量的模型难以拟合训练数据</li><li>高容量的模型可以记住所有的训练数据</li></ul><p>在学习模型的时候我们希望得到一个最小的泛化误差<br><img src='../../figure/动手学深度学习/4-Multilayer-perceptrons/influence_of_model_capacity.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h4 id="估计模型容量"><a href="#估计模型容量" class="headerlink" title="估计模型容量"></a>估计模型容量</h4><ul><li>难以在不同的种类算法之间比较<ul><li>例如树模型和神经网络</li></ul></li><li>给定一个模型种类，将有两个因素<ul><li>参数的个数</li><li>参数值的选择范围</li></ul></li></ul><h4 id="VC维"><a href="#VC维" class="headerlink" title="VC维"></a>VC维</h4><p>VC维是统计学习理论的核心思想</p><p>对于一个分类模型，VC等于一个最大的数据集的大小，不管如何给定标号，都存在一个模型来对它进行完美分类（相当于记住所有数据）。</p><ul><li>二维输入的感知机，VC维 $=3$（即假如数据集只有 $3$ 个样本，那么感知机总是能进行划分；但是如果有 $4$ 个样本，那对于比如说XOR的情形就无法处理）</li><li>支持 $N$ 维输入的感知机的VC维是 $N+1$</li><li>一些多层感知机的VC维为 $O(N\log_2 N)$</li></ul><h3 id="数据复杂度"><a href="#数据复杂度" class="headerlink" title="数据复杂度"></a>数据复杂度</h3><ul><li>样本个数</li><li>每个样本的元素个数</li><li>时间、空间结构</li><li>多样性</li></ul><h2 id="QA-1"><a href="#QA-1" class="headerlink" title="QA"></a>QA</h2><ul><li>验证数据集和训练数据集的数据清洗（如异常值处理）和特征构建（如标准化）是否需要放到一起处理？<ul><li>如果能拿到验证数据集，那么可以统一做处理；如果拿不到，那就单独处理训练集的数据。</li></ul></li><li>如何有效地设计超参数？<ul><li>自己多次调试，或者随机。</li></ul></li><li>假设做一个二分类问题，实际情况是1/9的比例，训练集两种类型的比例应该是1/1还是1/9?<ul><li>验证集的数据比例最好是比较均衡，或者也可以调整权重</li></ul></li></ul><h1 id="权重衰退"><a href="#权重衰退" class="headerlink" title="权重衰退"></a>权重衰退</h1><h2 id="权重衰退-1"><a href="#权重衰退-1" class="headerlink" title="权重衰退"></a>权重衰退</h2><p>一种处理过拟合的方法。权重衰退是通过限制参数值的选择范围来控制模型容量。<br><img src='../../figure/动手学深度学习/4-Multilayer-perceptrons/weight_decay_parameter_restriction.png' width=200 style="display: block; margin-left: auto; margin-right: auto;"></p><p>限制参数的范围之所以能防止过拟合，是因为较小的范围能够防止神经网络学习出一些过于复杂的模型，从而使学习的结果趋于平滑。就如上图所示。</p><h3 id="使用均方范数作为硬性限制"><a href="#使用均方范数作为硬性限制" class="headerlink" title="使用均方范数作为硬性限制"></a>使用均方范数作为硬性限制</h3><script type="math/tex; mode=display">\min_{}l(\bm{w},b) \text{ subject to } \left\| \bm{w} \right\|_{}^{2}\le \theta</script><ul><li>通常不限制 $b$</li><li>小的 $\theta$ 意味着更强的正则项</li></ul><h3 id="使用均方范数作为柔性限制"><a href="#使用均方范数作为柔性限制" class="headerlink" title="使用均方范数作为柔性限制"></a>使用均方范数作为柔性限制</h3><p>对于每个 $\theta$，都可以找到 $\lambda$ 使得之前的目标函数等价于（可以通过拉格朗日乘子法证明）</p><script type="math/tex; mode=display">\min l(\bm{w},b)+\frac{\lambda}{2}\left\| \bm{w} \right\|_{}^{2}</script><p><img src='../../figure/动手学深度学习/4-Multilayer-perceptrons/weight_decay_illustration.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="参数更新法则"><a href="#参数更新法则" class="headerlink" title="参数更新法则"></a>参数更新法则</h3><ul><li>计算梯度<script type="math/tex; mode=display">\frac{\partial }{\partial \bm{w}} \left(l(\bm{w},b)+\frac{\lambda}{2}\left\| \bm{w} \right\|_{}^{2}\right) = \frac{\partial l(\bm{w},b)}{\partial \bm{w}} + \lambda \bm{w}</script></li><li>时间 $t$ 的更新<script type="math/tex; mode=display">\bm{w_{t+1}}=(1-\eta \lambda)\bm{w_t}-\eta \frac{\partial l(\bm{w_t},b)}{\partial \bm{w_t}}</script></li></ul><p>从式子中可以看出在更新 $\bm{w}$ 的时候总是先将 $\bm{w}$ 变小再减去梯度，所以叫做权重衰退。</p><h2 id="QA-2"><a href="#QA-2" class="headerlink" title="QA"></a>QA</h2><ul><li>实践中权重衰退的值一般取多少比较合适？<ul><li>一般取 $10^{-2}, 10^{-3}, 10^{-4}$。效果不好可以取其他方法。</li></ul></li></ul><h1 id="丢弃法"><a href="#丢弃法" class="headerlink" title="丢弃法"></a>丢弃法</h1><h2 id="丢弃法-1"><a href="#丢弃法-1" class="headerlink" title="丢弃法"></a>丢弃法</h2><p>一个好的模型需要对输入数据的扰动鲁棒</p><ul><li>使用有噪音的数据等价于Tikhonov正则（这里的噪音和数据集的噪音不同，数据集的噪音是固定的，因此可能被学习到；而这里正则加入的噪音是随机的）</li><li>丢弃法就相当于在层之间加噪音</li></ul><h3 id="无偏差的加入噪音"><a href="#无偏差的加入噪音" class="headerlink" title="无偏差的加入噪音"></a>无偏差的加入噪音</h3><p>对某一层 $\bm{x}$ 加入噪音得到 $\bm{x’}$，但我们希望期望值不变 $E(\bm{x’})=E(\bm{x})$，于是丢弃法对每个元素进行如下扰动：</p><script type="math/tex; mode=display">x_i'=\begin{cases}    0, \text{with probablity } p \\    \frac{x_i}{1-p}, \text{oterwise}\end{cases}</script><h3 id="使用丢弃法"><a href="#使用丢弃法" class="headerlink" title="使用丢弃法"></a>使用丢弃法</h3><p>通常将丢弃法作用在隐藏全连接层的输出上</p><script type="math/tex; mode=display">\begin{aligned}\bm{h}&=\sigma(\bm{W_1}\bm{x}+\bm{b_1}) \\\bm{h'}&=\operatorname{dropout}(\bm{h}) \\\bm{o}&=\bm{W_2}\bm{h'}+\bm{b_2}\\\bm{y}&=\operatorname{softmax}(\bm{o})\end{aligned}</script><p><img src='../../figure/动手学深度学习/4-Multilayer-perceptrons/using_dropout.png' width=500 style="display: block; margin-left: auto; margin-right: auto;"></p><p>需要注意的是每次dropout丢弃的神经元都是随机的。</p><p>同时dropout只在训练时使用，用来影响模型的更新；而在推理时不需要drop。</p><h2 id="QA-3"><a href="#QA-3" class="headerlink" title="QA"></a>QA</h2><ul><li>为什么预测的时候不用drop？<ul><li>为了防止推理时出现随机性</li></ul></li><li>dropout为什么比权重衰退更好用更常用？<ul><li>dropout更加直观，方便调参</li></ul></li></ul><h1 id="数值稳定性-模型初始化和激活函数"><a href="#数值稳定性-模型初始化和激活函数" class="headerlink" title="数值稳定性+模型初始化和激活函数"></a>数值稳定性+模型初始化和激活函数</h1><h2 id="数值稳定性"><a href="#数值稳定性" class="headerlink" title="数值稳定性"></a>数值稳定性</h2><h3 id="神经网络的梯度"><a href="#神经网络的梯度" class="headerlink" title="神经网络的梯度"></a>神经网络的梯度</h3><p>损失函数 $l$ 关于参数 $\bm{W_t}$ 的梯度</p><script type="math/tex; mode=display">\frac{\partial l}{\partial \bm{W_t}} = \frac{\partial l}{\partial \bm{h^{d}}} \frac{\partial \bm{h^{d}}}{\partial \bm{h^{d-1}}}\cdots \frac{\partial \bm{h^{t+1}}}{\partial \bm{h^{t}}} \frac{\partial \bm{h^{t}}}{\partial \bm{W^{t}}}</script><p>假如神经网络非常深，那么可能带来梯度爆炸或者梯度消失。</p><h3 id="梯度爆炸的问题"><a href="#梯度爆炸的问题" class="headerlink" title="梯度爆炸的问题"></a>梯度爆炸的问题</h3><ul><li>值超出值域</li><li>对学习率敏感<ul><li>如果学习率太大 $\rightarrow$ 大的参数值 $\rightarrow$ 更大的梯度</li><li>学习率太小 $\rightarrow$ 训练无法进展</li><li>我们可能需要在训练过程中不断调整学习率</li></ul></li></ul><h3 id="梯度消失的问题"><a href="#梯度消失的问题" class="headerlink" title="梯度消失的问题"></a>梯度消失的问题</h3><ul><li>梯度值变成 $0$<ul><li>训练没有进展</li></ul></li><li>对底部层尤为严重<ul><li>仅仅顶部训练的较好</li><li>无法让神经网络更深</li></ul></li></ul><h2 id="模型初始化和激活函数"><a href="#模型初始化和激活函数" class="headerlink" title="模型初始化和激活函数"></a>模型初始化和激活函数</h2><p>目标：让训练更加稳定，即让梯度值在合理的范围内</p><ul><li>将乘法变为加法<ul><li>ResNet，LSTM</li></ul></li><li>归一化<ul><li>梯度归一化，梯度剪裁（即假如梯度超过了某个范围，就强行把梯度剪裁回去）</li></ul></li></ul><h3 id="让每层的方差是一个常数"><a href="#让每层的方差是一个常数" class="headerlink" title="让每层的方差是一个常数"></a>让每层的方差是一个常数</h3><p>我们把每层的输出和梯度都看成是一个随机变量，那么我们希望每层的方差和均值都保持一致，那么神经网络不论多深，都不容易出问题。</p><p>令正向</p><script type="math/tex; mode=display">\mathbb{E}[h_i^{t}] = 0 \quad \operatorname{Var}[h_i^{t}]=a</script><p>反向</p><script type="math/tex; mode=display">\mathbb{E}\left[\frac{\partial l}{\partial h_i^{t}}\right] = 0 \quad \operatorname{Var}\left[ \frac{\partial l}{\partial h_i^{t}} \right]=b</script><h3 id="权重初始化"><a href="#权重初始化" class="headerlink" title="权重初始化"></a>权重初始化</h3><p>即在合理值区间里随机初始参数。一般而言，远离最优解的地方损失函数表面会比较复杂，而最优解附近表面会比较平。之前随机初始化 $N(0, 0.01)$ 对于小网络是可行的，但是不一定适用于深度神经网络。</p><p>以MLP为例。假设</p><ul><li>$w<em>{i,j}^{t}$ i.i.d，那么 $\mathbb{E}[w</em>{i,j}^{t}]=0, \operatorname{Var}[w_{i,j}^{t}]=\gamma_t$</li><li>$h<em>i^{t-1}$ 独立于 $w</em>{i,j}^{t}$</li></ul><p>同时先不考虑激活函数，那么 $\bm{h}^{t}=\bm{W}^{t}\bm{h}^{t-1}$</p><script type="math/tex; mode=display">\mathbb{E}[h_i^{t}]=\mathbb{E}\left[ \sum_{j}w_{i,j}^{t}h_j^{t-1} \right] = \sum_{j}\mathbb{E}[w_{i,j}^{t}]\mathbb{E}[h_j^{t-1}]=0</script><script type="math/tex; mode=display">\begin{aligned}\operatorname{Var}\left[h_{i}^{t}\right] & =\mathbb{E}\left[\left(h_{i}^{t}\right)^{2}\right]-\mathbb{E}\left[h_{i}^{t}\right]^{2}=\mathbb{E}\left[\left(\sum_{j} w_{i, j}^{t} h_{j}^{t-1}\right)^{2}\right] \\& =\mathbb{E}\left[\sum_{j}\left(w_{i, j}^{t}\right)^{2}\left(h_{j}^{t-1}\right)^{2}+\sum_{j \neq k} w_{i, j}^{t} w_{i, k}^{t} h_{j}^{t-1} h_{k}^{t-1}\right] \\& =\sum_{j} \mathbb{E}\left[\left(w_{i, j}^{t}\right)^{2}\right] \mathbb{E}\left[\left(h_{j}^{t-1}\right)^{2}\right] \\& =\sum_{j} \operatorname{Var}\left[w_{i, j}^{t}\right] \operatorname{Var}\left[h_{j}^{t-1}\right]=n_{t-1} \gamma_{t} \operatorname{Var}\left[h_{j}^{t-1}\right]\end{aligned} \Rightarrow n_{t-1}\gamma_t=1</script><p>再考虑反向</p><script type="math/tex; mode=display">\frac{\partial \ell}{\partial \mathbf{h}^{t-1}}=\frac{\partial \ell}{\partial \mathbf{h}^{t}} \mathbf{W}^{t} \Rightarrow \left(\frac{\partial \ell}{\partial \mathbf{h}^{t-1}}\right)^{T}=\left(W^{t}\right)^{T}\left(\frac{\partial \ell}{\partial \mathbf{h}^{t}}\right)^{T} \\ \quad \\\mathbb{E}\left[\frac{\partial \ell}{\partial h_{i}^{t-1}}\right]=0 \\ \quad \\\operatorname{Var}\left[\frac{\partial \ell}{\partial h_{i}^{t-1}}\right]=n_{t} \gamma_{t} \operatorname{Var}\left[\frac{\partial \ell}{\partial h_{j}^{t}}\right] \Rightarrow n_{t} \gamma_{t}=1</script><h3 id="Xavier初始"><a href="#Xavier初始" class="headerlink" title="Xavier初始"></a>Xavier初始</h3><p>难以同时满足 $n_{t-1}\gamma_t=1$ 和 $n_t\gamma_t=1$，于是取个折中的方案</p><ul><li>Xavier使得 $\gamma<em>t(n</em>{t-1}+n<em>t)/2=1\rightarrow \gamma_t=2/(n</em>{t-1}+n_t)$<ul><li>均匀分布 $\mathscr{U}(- \sqrt{6 /(n<em>{t-1}+n_t)}, \sqrt{6 /(n</em>{t-1}+n_t)})$</li><li>正态分布 $\mathscr{N}(0, \sqrt{2 /(n_{t-1}+n_t)})$</li></ul></li></ul><h3 id="假设线性的激活函数"><a href="#假设线性的激活函数" class="headerlink" title="假设线性的激活函数"></a>假设线性的激活函数</h3><p>假设 $\sigma(x)=\alpha x+\beta$</p><script type="math/tex; mode=display">\begin{aligned}&\mathbf{h}'=\mathbf{W}^t\mathbf{h}^{t-1}\quad\text{and}\quad\mathbf{h}^t=\sigma(\mathbf{h}') \\\mathbb{E}[h_i^t]& =\mathbb{E}\left[\alpha h_i^{\prime}+\beta\right]=\beta \Rightarrow \beta=0 \\\mathbf{Var}[h_i^t]& =\mathbb{E}[(h_i^t)^2]-\mathbb{E}[h_i^t]^2  \\&=\mathbb{E}[(\alpha h_i^{\prime}+\beta)^2]-\beta^2 \\&=\mathbb{E}[\alpha^2(h_i^{\prime})^2+2\alpha\beta h_i^{\prime}+\beta^2]-\beta^2 \\&=\alpha^2\mathrm{Var}[h_i^{\prime}] \Rightarrow \alpha=1\end{aligned}</script><p>在反向的情况下</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial\ell}{\partial\mathbf{h}^{\prime}}&=\frac{\partial\ell}{\partial\mathbf{h}^{\prime}}(W^t)^T\quad\mathrm{and}\quad\frac{\partial\ell}{\partial\mathbf{h}^{t-1}}=\alpha\frac{\partial\ell}{\partial\mathbf{h}^{\prime}}\\\\&\mathbb{E}\left[\frac{\partial\ell}{\partial h_i^{t-1}}\right]=0\quad \Rightarrow \quad\beta=0\\\\\mathrm{Var}\left[\frac{\partial\ell}{\partial h_i^{t-1}}\right]&=\alpha^2\mathrm{Var}\left[\frac{\partial\ell}{\partial h_j^{\prime}}\right]\quad \Rightarrow \quad\alpha=1\end{aligned}</script><h3 id="检查常用激活函数"><a href="#检查常用激活函数" class="headerlink" title="检查常用激活函数"></a>检查常用激活函数</h3><p>通过上面的讨论我们发现激活函数最好是 $f(x)=x$，单这对非线性的激活函数来说是不可能的，因此我们讨论泰勒展开的情况。</p><script type="math/tex; mode=display">\begin{gathered}\text{sigmoid(x)} =\frac12+\frac x4-\frac{x^3}{48}+O(x^5) \\\text{tanh(x)} =0+x-\frac{x^3}3+O(x^5) \\\text{relu(x)} =0+x\quad\mathrm{~for~}x\geq0 \end{gathered}</script><p>发现sigmoid不太符合，因此可以调整为</p><script type="math/tex; mode=display">4\times \operatorname{sigmoid} - 2</script><h2 id="QA-4"><a href="#QA-4" class="headerlink" title="QA"></a>QA</h2><ul><li>孪生网络两路输入不一样，是不是很可能引起数值不稳定？<ul><li>如果有两种输入，一种是文字，一种是图片，确实很可能输出的范围不一样。这个时候可以使用权重调整或者使用batchnorm。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 动手学深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linear network</title>
      <link href="/posts/379ff448.html"/>
      <url>/posts/379ff448.html</url>
      
        <content type="html"><![CDATA[<h1 id="线性回归-基础优化算法"><a href="#线性回归-基础优化算法" class="headerlink" title="线性回归+基础优化算法"></a>线性回归+基础优化算法</h1><h2 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h2><ul><li>输入 $\bm{x}=[x_1, x_2, \ldots , x_n]^{\mathrm{T}}$</li><li>线性模型有一个 $n$ 维权重和一个标量偏差 $b$</li><li>输出 $y=w_1x_1+w_2x_2+ \cdots +w_n x_n + b$<br>向量版本：$y=&lt;\bm{w},\bm{x}&gt;+b$</li></ul><p>线性模型可以看成是单层的神经网络。</p><h3 id="衡量预测质量"><a href="#衡量预测质量" class="headerlink" title="衡量预测质量"></a>衡量预测质量</h3><p>比较真实值和估计值的差距，通常使用平方损失。假设 $y$ 是估计值，$\hat{y}$ 是估计值</p><script type="math/tex; mode=display">l(y, \hat{y}) = \frac{1}{2} (y-\hat{y})^{2}</script><p>式子中有 $1 /2$ 是为了求导时便于消去。</p><h3 id="训练数据"><a href="#训练数据" class="headerlink" title="训练数据"></a>训练数据</h3><p>假设我们有 $n$ 个样本，记</p><script type="math/tex; mode=display">\bm{X}=[\bm{x_1},\bm{x_2}, \ldots ,\bm{x_n}]^{\mathrm{T}} \quad \bm{y}=[y_1,y_2, \ldots ,y_n]^{\mathrm{T}}</script><h3 id="参数学习"><a href="#参数学习" class="headerlink" title="参数学习"></a>参数学习</h3><ul><li>训练损失<script type="math/tex; mode=display">l(\bm{X}, \bm{y},\bm{w},b) = \frac{1}{2n}\sum_{i=1}^{n}(y_i- <\bm{x_i},\bm{w}>-b)^{2}=\frac{1}{2n}\left\| \bm{y}-\bm{X}\bm{w}-b \right\|_{}^{2}</script></li><li>最小化损失来学习参数<script type="math/tex; mode=display">\bm{w}^{*},\bm{b}^{*} = arg \min_{\bm{w},b}l(\bm{X}, \bm{y}, \bm{w}, b)</script></li></ul><h3 id="显式解"><a href="#显式解" class="headerlink" title="显式解"></a>显式解</h3><p>由于是一个简单的线性模型，损失是一个凸函数，因此有显式解</p><script type="math/tex; mode=display">\bm{w}^{*} = (\bm{X}^{\mathrm{T}}\bm{X})^{-1}\bm{X}\bm{y}</script><h2 id="基础优化算法"><a href="#基础优化算法" class="headerlink" title="基础优化算法"></a>基础优化算法</h2><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><script type="math/tex; mode=display">\bm{w}_{t}=\bm{w}_{t-1}-\eta \frac{\partial l}{\partial \bm{w}_{t-1}}</script><p>$l$ 在这里称为学习率。</p><p><img src='../../figure/动手学深度学习/3-Linear-network/gradient-descent.png' width=400 style="display: block; margin-left: auto; margin-right: auto;"></p><h3 id="小批量随机梯度下降"><a href="#小批量随机梯度下降" class="headerlink" title="小批量随机梯度下降"></a>小批量随机梯度下降</h3><p>在实际应用中我们很少直接使用梯度下降，因为每次计算梯度时要对整个损失函数求导，而损失函数是对所有样本的平均，因此每次求梯度都要把整个样本算一次，计算量很大。因此我们可以随机采样 $b$ 个样本来近似损失</p><script type="math/tex; mode=display">\frac{1}{b} \sum_{i\in I_{b}}l(\bm{x}_i,y_i,\bm{w})</script><p>在 $b$ 很大时估计较为精确，很小时没那么精确，但是计算更快。</p><p>小批量随机梯度是深度学习默认的求解算法，虽然有更好的算法，但是这种算法稳定而且简单，因此应用广泛。</p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><ul><li>Q：为什么用平方损失而不是绝对差值？<ul><li>A：使用绝对差值在原点处不容易求导，但是实际上差别不大。</li></ul></li><li>Q：线性回归损失函数是不是通常都是mse？<ul><li>A：是的</li></ul></li><li>梯度下降和随机梯度下降如何找到合适的学习率？<ul><li>A：首先可以选择Adam之类对学习率不太敏感的算法，以及合理的参数初始化，学习率取个差不多0.1。   </li></ul></li><li>Q：batchsize对最终结果的影响？<ul><li>A：batchsize小结果可能会更好，因为小批量随机梯度下降理论上带来了噪音，而噪音对很深的神经网络来说是件好事，这能防止神经网络走偏，得到更强的鲁棒性以及泛化性。</li></ul></li><li>Q：训练过程中，过拟合和欠拟合情况下学习率和批次应当如何调整？<ul><li>A：在正常的范围内学习率和批量大小对拟合情况影响不大，只要学习次数足够最终都会拟合。</li></ul></li></ul><h1 id="Softmax回归-损失函数-图片分类数据集"><a href="#Softmax回归-损失函数-图片分类数据集" class="headerlink" title="Softmax回归+损失函数+图片分类数据集"></a>Softmax回归+损失函数+图片分类数据集</h1><h2 id="Softmax回归"><a href="#Softmax回归" class="headerlink" title="Softmax回归"></a>Softmax回归</h2><ul><li>回归估计一个连续值</li><li>分类预测一个离散类别</li></ul><p>分类通常有多个输出，输出 $i$ 是第 $i$ 类的置信度。</p><h3 id="从回归到多类分类——均方损失"><a href="#从回归到多类分类——均方损失" class="headerlink" title="从回归到多类分类——均方损失"></a>从回归到多类分类——均方损失</h3><ul><li>首先对每一位进行有效编码。比如有一个label为 $y$，那么编码之后 $y$ 变为 $\bm{y}$<script type="math/tex; mode=display">\bm{y}=[y_1,y_2, \ldots y_n]^{\mathrm{T}} \\y_i = \begin{cases}  1 , \text{if } i=y\\   0, \text{otherwise}\end{cases}</script></li><li>使用均方损失训练</li><li>最大值为预测结果 $\hat{y}=\argmax_{i}o_i$</li></ul><h3 id="从回归到多类分类——无校验比例"><a href="#从回归到多类分类——无校验比例" class="headerlink" title="从回归到多类分类——无校验比例"></a>从回归到多类分类——无校验比例</h3><p>在计算损失的时候，可以只考虑正确类的误差，而不考虑非正确类的情况。即我们希望正确类的置信度远远大于非正确类。$o_y-o_i\ge \Delta(y,i)$</p><p>同时我们希望输出的结果是一个概率，因此可以把输出向量 $\bm{o}$ 做一个softmax操作，即</p><script type="math/tex; mode=display">\bm{\hat{y}} = \operatorname{softmax} (\bm{o}) \\ \hat{y}_i=\frac{\exp (o_i)}{\sum_{k}\exp (o_k)}</script><p>这里使用指数是希望输出都为正数。</p><h3 id="Softmax和交叉熵损失"><a href="#Softmax和交叉熵损失" class="headerlink" title="Softmax和交叉熵损失"></a>Softmax和交叉熵损失</h3><p>交叉熵常用来衡量两个概率的区别 $H(\bm{p},\bm{q})=\sum<em>{i}-p</em>{i}\log(q_i)$，如果将其作为损失，则为 </p><script type="math/tex; mode=display">l(\bm{y},\bm{\hat{y}})=-\sum_{i}y_i \log \hat{y}_i = -\log \hat{y}_y</script><p>可以看出这里只考虑了正确类的预测情况。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><h3 id="L2-Loss"><a href="#L2-Loss" class="headerlink" title="L2 Loss"></a>L2 Loss</h3><script type="math/tex; mode=display">l(y, y')=\frac{1}{2}(y-y')^{2}</script><p>导数是一条过原点的直线，因此当损失函数逐渐减小的时候收敛地会越来越慢。但是我们有时并不希望在比较远的时候梯度过大。</p><h3 id="L1-Loss"><a href="#L1-Loss" class="headerlink" title="L1 Loss"></a>L1 Loss</h3><script type="math/tex; mode=display">l(y,y')=\left\vert y-y' \right\vert</script><p>梯度永远是常数，对稳定性比较好。但是在原点处不可导，因此在优化末期可能不太稳定。</p><h3 id="Huber’s-Robust-Loss"><a href="#Huber’s-Robust-Loss" class="headerlink" title="Huber’s Robust Loss"></a>Huber’s Robust Loss</h3><script type="math/tex; mode=display">l(y, y')=\begin{cases}    \left\vert y-y' \right\vert -\frac{1}{2}&, \text{if } \left\vert y-y' \right\vert >1  \\    \frac{1}{2}(y-y')^{2} &,\text{otherwise}\end{cases}</script><h2 id="QA-1"><a href="#QA-1" class="headerlink" title="QA"></a>QA</h2><ul><li>softlabel训练策略为什么有效？<ul><li>一般的标号是将label变成一个长为 $n$ 的向量，其中只有正确的那一项为 $1$，但是这回导致不太好完全逼近，因为预测的正确项的指数要趋近于无穷大。因此softlabel将正确的类记录为 $0.9$，其他项平分 $0.1$，这样就更好逼近。这也是图片分类中常用的技巧。</li></ul></li><li>为什么使用交叉熵而不是相对熵、互信息等其他基于信息量的度量？<ul><li>相互熵相比交叉熵而言是对称的，这一点更好。但是计算起来更麻烦一下，而且用这两个效果差不多。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 动手学深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> demo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Materials and Appearances</title>
      <link href="/posts/661d14ee.html"/>
      <url>/posts/661d14ee.html</url>
      
        <content type="html"><![CDATA[<h2 id="Material-BRDF"><a href="#Material-BRDF" class="headerlink" title="Material == BRDF"></a>Material == BRDF</h2><p>我们研究材质，实际上是在研究光线如何与材质作用，因此在图形学中研究材质，就是在研究BRDF。</p><h3 id="Diffuse-Lambertian-Material"><a href="#Diffuse-Lambertian-Material" class="headerlink" title="Diffuse / Lambertian Material"></a>Diffuse / Lambertian Material</h3><p>漫反射材料效果如图</p><div align=center><img src='../../figure/计算机图形学笔记/Materials-and-Appearances/diffuse_brdf.png' width=500></div>现在计算漫反射材质的BRDF。<div align=center><img src='../../figure/计算机图形学笔记/Materials-and-Appearances/diffuse_material.png' width=200></div><p>现在我们假设射入的光线是均匀的，而由于表面是漫反射，反射光线也是均匀的。这里首先假设材料反射率为 $\rho$，那么由对称性，入射光和出射光radiance的关系应当为 $L_o=\rho L_i$，而如果使用BRDF计算：</p><script type="math/tex; mode=display">\begin{aligned}L_o(\omega_o)&=\int_{H^{2}}f_r L_i(\omega_i)\cos \theta_i \mathrm{d}\omega_i \\&=f_r L_i \int_{H^{2}}\cos \theta_i \mathrm{d}\omega_i \\&= \pi f_r L_i\end{aligned}</script><p>因此可以得到 </p><script type="math/tex; mode=display">f_r=\frac{\rho}{\pi}</script><p>同时应当注意，这里的反射率 $\rho$ 可以只是一个数，也可以是对应三个光通道的一个向量。</p><h3 id="Glossy-material"><a href="#Glossy-material" class="headerlink" title="Glossy material"></a>Glossy material</h3><p>磨砂的材质效果如图</p><div align=center><img src='../../figure/计算机图形学笔记/Materials-and-Appearances/glossy_material.png' width=500></div><p>其光线反射的情况则如图所示。因此该种材料虽然有一定的镜面效果(比如古人使用铜镜)，但比较模糊</p><div align=center><img src='../../figure/计算机图形学笔记/Materials-and-Appearances/glossy_brdf.png' width=250></div><h3 id="Ideal-reflective-refractive-material"><a href="#Ideal-reflective-refractive-material" class="headerlink" title="Ideal reflective / refractive material"></a>Ideal reflective / refractive material</h3><p>这种材质一般是玻璃或者水。对于第二幅图，我们可以发现光线在玻璃中会有部分吸收，因此才会显现出玻璃的颜色。</p><div align=center><img src='../../figure/计算机图形学笔记/Materials-and-Appearances/ideal_relfective_refractive_material.png' width=500></div><p>光线在界面会发生理想的反射与折射</p><div align=center><img src='../../figure/计算机图形学笔记/Materials-and-Appearances/ideal_reflective_refractive_brdf.png' width=250></div><h2 id="Perfect-Specular"><a href="#Perfect-Specular" class="headerlink" title="Perfect Specular"></a>Perfect Specular</h2><h3 id="Perfect-Specular-Refraction"><a href="#Perfect-Specular-Refraction" class="headerlink" title="Perfect Specular Refraction"></a>Perfect Specular Refraction</h3><div align=center><img src='../../figure/计算机图形学笔记/Materials-and-Appearances/perfect_specular_reflection.png' width=500></div><p>求出反射光方向的一种方式为：</p><script type="math/tex; mode=display">\omega_o+\omega_i=2\cos \theta \vec{n}=2(\omega_i\cdot \vec{n})\vec{n} \\\Rightarrow \omega_o=-\omega_i+2(\omega_i\cdot \vec{n})\vec{n}</script><p>我们可以看出想要计算发射光线方向需要计算一个点乘，因此在Blinn-Phong反射模型中我们没有计算反射光线以减小计算量。</p><p>还有一种方法就是将空间中的角度拆分成 $\theta$ 和 $\phi$，然后入射和反射光线的角度关系就由上图中的公式描述。</p><p>镜面反射的BRDF比较复杂，需要使用 $\delta$ 函数，这里不提及。</p><h3 id="Specular-Refraction"><a href="#Specular-Refraction" class="headerlink" title="Specular Refraction"></a>Specular Refraction</h3><p>折射用斯涅尔定理描述即可，同时从公式中我们还可以注意到全反射的存在。</p><div align=center><img src='../../figure/计算机图形学笔记/Materials-and-Appearances/snell_law.png' width=600></div><h3 id="Fresnel-Reflection-Term"><a href="#Fresnel-Reflection-Term" class="headerlink" title="Fresnel Reflection / Term"></a>Fresnel Reflection / Term</h3><p>从图中可以看出，光的反射情况与角度有关，入射角度越大，反射的能量占比就越大。</p><div align=center><img src='../../figure/计算机图形学笔记/Materials-and-Appearances/fresnel_reflection.png' width=500></div><p>从图中可以看出，导体和绝缘体的菲涅尔系数不相同，导体在入射角度较小时反射系数远大于绝缘体，因此镜子多用铜、银等金属。</p><div align=center><div style="display: flex; max-width:600px;">  <div style="flex: 1; margin-right: 10px">    <img src='../../figure/计算机图形学笔记/Materials-and-Appearances/fresnel_term_dielectric.png'>  </div>  <div style="flex: 1;">    <img src='../../figure/计算机图形学笔记/Materials-and-Appearances/fresnel_term_conductor.png'>  </div></div></div><h4 id="Fresnel-Term-—-Formulae"><a href="#Fresnel-Term-—-Formulae" class="headerlink" title="Fresnel Term — Formulae"></a>Fresnel Term — Formulae</h4><script type="math/tex; mode=display">\begin{array}{l}R_{\mathrm{s}}=\left|\frac{n_{1} \cos \theta_{\mathrm{i}}-n_{2} \cos \theta_{\mathrm{t}}}{n_{1} \cos \theta_{\mathrm{i}}+n_{2} \cos \theta_{\mathrm{t}}}\right|^{2}=\left|\frac{n_{1} \cos \theta_{\mathrm{i}}-n_{2} \sqrt{1-\left(\frac{n_{1}}{n_{2}} \sin \theta_{\mathrm{i}}\right)^{2}}}{n_{1} \cos \theta_{\mathrm{i}}+n_{2} \sqrt{1-\left(\frac{n_{1}}{n_{2}} \sin \theta_{\mathrm{i}}\right)^{2}}}\right|^{2} \\R_{\mathrm{p}}=\left|\frac{n_{1} \cos \theta_{\mathrm{t}}-n_{2} \cos \theta_{\mathrm{i}}}{n_{1} \cos \theta_{\mathrm{t}}+n_{2} \cos \theta_{\mathrm{i}}}\right|^{2}=\left|\frac{n_{1} \sqrt{1-\left(\frac{n_{1}}{n_{2}} \sin \theta_{\mathrm{i}}\right)^{2}}-n_{2} \cos \theta_{\mathrm{i}}}{n_{1} \sqrt{1-\left(\frac{n_{1}}{n_{2}} \sin \theta_{\mathrm{i}}\right)^{2}}+n_{2} \cos \theta_{\mathrm{i}}}\right|^{2}\\R_{eff}=\displaystyle \frac{1}{2}(R_s+R_p)\end{array}</script><p>但是这个计算公式过于复杂，因此一般采用Schlick’s approximation来估算菲涅尔项</p><script type="math/tex; mode=display">\begin{aligned}R(\theta)&=R_0+(1-R_0)(1-\cos \theta)^{5}\\R_0&= \left( \frac{n_1-n_2}{n_1+n_2} \right)^{2}\end{aligned}</script><h2 id="Microfacet-Material"><a href="#Microfacet-Material" class="headerlink" title="Microfacet Material"></a>Microfacet Material</h2><p>上面讨论菲涅尔项是为了这里引入一个真正基于实际情况的表面模型：微表面模型。</p><div align=center><img src='../../figure/计算机图形学笔记/Materials-and-Appearances/micorfacet_material_motivation.png' width=400></div><p>提出微表面模型就是因为从远处看物体，其间的起伏细节都看不间，即表面基本是平的，而起伏反映到眼睛中就是表面的粗糙程度。就如同上图从宇宙中拍地球，地面上的各种建筑、植物都看不清，看到的只有一个反射的效果。</p><h3 id="Microfacet-Theory"><a href="#Microfacet-Theory" class="headerlink" title="Microfacet Theory"></a>Microfacet Theory</h3><p>在微表面模型中，对于一个粗糙的表面</p><ul><li>从远处看(Macroscale):平坦且粗糙。看到的是材质或外观</li><li>从近处看(Microscale):起伏且光滑。看到的是几何<div align=center><img src='../../figure/计算机图形学笔记/Materials-and-Appearances/microfacet_theory.png' width=600></div></li></ul><h3 id="Microfacet-BRDF"><a href="#Microfacet-BRDF" class="headerlink" title="Microfacet BRDF"></a>Microfacet BRDF</h3><p>从微表面模型可以来看不同材质的BRDF：如果微表面的法线分布较为集中，那么体现出的效果就是glossy；如果微表面的法线分布较为分散，那么体现出的效果就是diffuse。</p><div align=center><img src='../../figure/计算机图形学笔记/Materials-and-Appearances/microfacet_brdf.png' width=500></div><p>想要写出微表面的BRDF，则需如下考虑</p><script type="math/tex; mode=display">f(i,o)=\frac{F(i,h)G(i,o,h)D(h)}{4(n,i)(n,o)}</script><div align=center><img src='../../figure/计算机图形学笔记/Materials-and-Appearances/microfacet_brdf_formula.png' width=300></div><p>其中 $F(i,h)$ 为菲涅尔项(Fresnel term)，$D(h)$ 表示微表面中有多少表面的法线方向和half vector一致(distribution of normals)，$G(i,o,h)$ 考虑了微表面之间对光线相互遮挡的情况，称为几何项(shawing-masking term)。</p><p>当光线和发现夹角接近 $90 \degree$ 时，$F(i,h)$ 会较大，而 $G(i,o,h)$ 会较小，从而让边界不会那么亮。</p><p>微表面相当强大，能够很好的描述各种材质，现代的图形学基本在使用的就是这种模型。</p><h3 id="Isotropic-Anisotropic-Materials"><a href="#Isotropic-Anisotropic-Materials" class="headerlink" title="Isotropic / Anisotropic Materials"></a>Isotropic / Anisotropic Materials</h3><p>材质的各向同性和各向异性和微表面的方向性有关，其反映在BRDF上即：</p><script type="math/tex; mode=display">f_r(\theta_i,\phi_i;\theta_r,\phi_r)\neq f_r(\theta_i,\theta_r,\phi_r-\phi_i)</script><p>图中左侧的球是各向同性的，而右边的球则是各向异性的。</p><div align=center><img src='../../figure/计算机图形学笔记/Materials-and-Appearances/anisotropic_example.png' width=300></div><h3 id="Properties-of-BRDFs"><a href="#Properties-of-BRDFs" class="headerlink" title="Properties of BRDFs"></a>Properties of BRDFs</h3><ul><li>非负性(能量不能是负的)<script type="math/tex; mode=display">f_r(\omega_i \rightarrow \omega_r)\ge 0</script></li><li>线性性(各个光线的效果能相互叠加，Blinn-Phong模型就利用了此性质) <script type="math/tex; mode=display">L_r(p,\omega_r)=\int_{H^{2}}f_r(p,\omega_i \rightarrow \omega_r)L_i(p,\omega_i)\cos \theta_i \mathrm{d} \omega_i</script></li><li>可逆性(交换出射和入射放行，BRDF相同)<script type="math/tex; mode=display">f_r(\omega_r \rightarrow \omega_i)=f_r(\omega_i \rightarrow \omega_r)</script></li><li>能量守恒<script type="math/tex; mode=display">\forall \omega_r \int_{H^{2}}f_r(\omega_i \rightarrow \omega_r) \cos \theta_i \mathrm{d}\omega_i \le 1</script></li><li><p>各向同性和各向异性</p><ul><li><p>如果是各项同性，可以四维降三维</p><script type="math/tex; mode=display">f_r(\theta_i,\phi_i;\theta_r,\phi_r)= f_r(\theta_i,\theta_r,\phi_r-\phi_i)</script><p>再考虑可逆性的话</p><script type="math/tex; mode=display">f_r(\theta_i,\theta_r,\phi_r-\phi_i)=f_r(\theta_r,\theta_i,\phi_i-\phi_r)=f_r(\theta,\theta_r,\left\vert \phi_r-\phi_i \right\vert )</script></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> computer graphics notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ray Tracing 2</title>
      <link href="/posts/221d0ac0.html"/>
      <url>/posts/221d0ac0.html</url>
      
        <content type="html"><![CDATA[<h2 id="Basic-Radiometry"><a href="#Basic-Radiometry" class="headerlink" title="Basic Radiometry"></a>Basic Radiometry</h2><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>Blinn-Phong模型中，有一个量为光照强度 $I$，我们需要探究这个光照强度的物理意义。同时Whitted-Style渲染出来的场景因为做了非常多的简化，比如实际物体反射的光强有分布，折射时还要考虑折射光线和反射光线能量比。这些问题导致这种方法渲染出来的场景不够真实。</p><p>而辐射度量学有助于精确的描述光与物体表面的作用，能够得到更加正确的结果。</p><h3 id="Radiometry"><a href="#Radiometry" class="headerlink" title="Radiometry"></a>Radiometry</h3><p>关于如何在物理上准确描述光照，同时仍然基于几何光学，不考虑光的波动性。</p><p>给了光一系列空间中的属性(Radiant flux, intensity, irradiance, radiance)</p><h3 id="Radiant-Energy-and-Flux-Power"><a href="#Radiant-Energy-and-Flux-Power" class="headerlink" title="Radiant Energy and Flux (Power)"></a>Radiant Energy and Flux (Power)</h3><p>Radiant energy：电磁辐射的能量，单位为 $J$，记为 $Q$。<br>Radient flux(power)：单位时间发射、反射或接收的能量，单位为 $W$，记为 $\Phi$。在光学中，我们通常用 $lm$ (流明)描述光源亮度，流明数与功率相关。</p><h3 id="Radiant-Intensity"><a href="#Radiant-Intensity" class="headerlink" title="Radiant Intensity"></a>Radiant Intensity</h3><p>radiant (luminous) intensity：指的是点光源发出的单位时间通过单位立体角(solid angle)的功率。<br>(这里相当于在描述辐射能量在各个方向上的分布。)</p><script type="math/tex; mode=display">I(\omega)\equiv \frac{\mathrm{d}\Phi}{\mathrm{d}\omega}</script><p>单位为 </p><script type="math/tex; mode=display">\left[ \frac{W}{sr} \right] \quad \left[ \frac{lm}{sr}=cd \right]</script><p>$\omega$ 在这里表示三维空间中的方向</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/omega_diraction_vector.png' width=400></div><h3 id="Irradiance"><a href="#Irradiance" class="headerlink" title="Irradiance"></a>Irradiance</h3><p>Irradiance：物体表面上单位面积接收的功率</p><script type="math/tex; mode=display">E(x)\equiv \frac{\mathrm{d}\Phi(x)}{\mathrm{d}A}</script><p>单位为</p><script type="math/tex; mode=display">\left[ \frac{W}{m^{2}} \right] \quad \left[ \frac{lm}{m^{2}}=lux \right]</script><h4 id="Lambert’s-Cosine-Law"><a href="#Lambert’s-Cosine-Law" class="headerlink" title="Lambert’s Cosine Law"></a>Lambert’s Cosine Law</h4><p>考虑irradiance的时候需要注意接收光线的面和光线的夹角之间的关系。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/lambert&apos;s_cosine_law.png' width=600></div><h3 id="Radiance"><a href="#Radiance" class="headerlink" title="Radiance"></a>Radiance</h3><p>是为了描述光线的属性，这个概念与图形学中光线追踪紧密相关。<br>Radiance：指的是一个表面单位立体角单位投影面积发射、反射或接收的功率。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/radiance_definition.png' width=300></div><script type="math/tex; mode=display">L(p,\omega)\equiv \frac{\mathrm{d}^{2}\Phi(p,\omega)}{\mathrm{d}\omega \mathrm{d}A \cos \theta}</script><p>单位为</p><script type="math/tex; mode=display">\left[ \frac{W}{sr\cdot m^{2}} \right] \quad \left[\frac{cd}{m^{2}}= \frac{lm}{sr\cdot m^{2}} = nit \right]</script><p>比较radiance和irradiance和intensity的定义，可以认为radiance是单位立体角的irradiance或者单位投影面积的intensity。</p><h4 id="Incident-Radiance"><a href="#Incident-Radiance" class="headerlink" title="Incident Radiance"></a>Incident Radiance</h4><p>Incident radiance可以认为是到达物体表面的单位立体角的irradiance。</p><script type="math/tex; mode=display">L(p,\omega)=\frac{\mathrm{d}E(p)}{\mathrm{d}\omega \cos \theta}</script><h4 id="Exiting-Radiance"><a href="#Exiting-Radiance" class="headerlink" title="Exiting Radiance"></a>Exiting Radiance</h4><p>Exiting radiance 可以认为是从表面发射的单位投影面积的intensity</p><script type="math/tex; mode=display">L(p,\omega)=\frac{\mathrm{d}I(p,\omega)}{\mathrm{d}A \cos \theta}</script><h4 id="Irradiance-vs-Radiance"><a href="#Irradiance-vs-Radiance" class="headerlink" title="Irradiance vs. Radiance"></a>Irradiance vs. Radiance</h4><p>irradiance和radiance都是图形学中非常重要的概念。irradiance可以认为是一个小的范围 $\mathrm{d}A$ 接收到的总功率，而radiance是这个小范围从方向 $\mathrm{d}\omega$ 接收到的功率。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/radiance_and_irradiance.png' width=400></div><script type="math/tex; mode=display">\begin{aligned}\mathrm{d}E(p,\omega) &= L_i(p,\omega)\cos \theta \mathrm{d}\omega \\E(p) &= \int_{H^{2}}L_i(p,\omega)\cos \theta \mathrm{d}\omega\end{aligned}</script><h2 id="Bidirectional-Reflectance-Distribution-Function-BRDF"><a href="#Bidirectional-Reflectance-Distribution-Function-BRDF" class="headerlink" title="Bidirectional Reflectance Distribution Function (BRDF)"></a>Bidirectional Reflectance Distribution Function (BRDF)</h2><h3 id="Reflection-at-a-Point"><a href="#Reflection-at-a-Point" class="headerlink" title="Reflection at a Point"></a>Reflection at a Point</h3><p>对于反射模型，我们可以认为是某个小的面积 $\mathrm{d}A$ 接收了能量，然后再发出能量。因此在考虑反射时，我们考虑光从某个方向 $\omega<em>{i}$ 入射，然后从某个方向 $\omega</em>{j}$ 出射</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/reflection_at_a_point.png' width=350></div><p>对于入射，我们考虑某个小的面积在某个方向接收到的irradiance</p><script type="math/tex; mode=display">\mathrm{d}E(\omega_i)=L(\omega_i)\cos \theta_i \mathrm{d}\omega_i</script><p>然后我们想知道出射的radiance $\mathrm{d}L_r(\omega_r)$ 和上面的irradiance有什么关系。这时就需要一个函数来描述，这个函数就是BRDF。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/brdf.png' width=350></div><p>该函数记作</p><script type="math/tex; mode=display">f_r(\omega_i\rightarrow \omega_r)=\frac{\mathrm{d}L_r(\omega_r)}{\mathrm{d}E_i(\omega_i)}=\frac{\mathrm{d}L_r(\omega_r)}{L_i(\omega_i)\cos \theta_i \mathrm{d}\omega_i}</script><p>因此想要知道某个出射方向的irradiance，只需要将入射光线方向对立体角积分</p><script type="math/tex; mode=display">L_r(p,\omega_r)=\int_{H^{2}}f_r(p,\omega_i\rightarrow \omega_r)L_i(p,\omega_i)\cos \theta_i \mathrm{d}\omega_i</script><p>BRDF既然描述了出射光线和入射光线的关系，那么物体的材质其实也就是由它来描述。</p><h3 id="The-Rendering-Equation"><a href="#The-Rendering-Equation" class="headerlink" title="The Rendering Equation"></a>The Rendering Equation</h3><p>在之前使用BRDF得到的反射方程的基础上加上那个点的发光情况，就能得到渲染方程</p><script type="math/tex; mode=display">L_o(p,\omega_o)=L_e(p,\omega_o)+\int_{\Omega^{+}}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n\cdot \omega_i)\mathrm{d}\omega_i</script><p>这里用 $o$ 表示出射方向，同时所有向量默认方向朝外(所以可以用 $n\cdot \omega_i$ 代替 $\cos \theta_i$)</p><h3 id="Challenge-Recursive-Equation"><a href="#Challenge-Recursive-Equation" class="headerlink" title="Challenge: Recursive Equation"></a>Challenge: Recursive Equation</h3><p>考虑到光是会多次反射的，因此在某个点的出射radiance也会成为其他点的irradiance，这就导致了一个递归计算的问题</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/recursive_rendering_equation.png' width=450></div><p>这里我们考虑各个反射光线相互作用的关系</p><script type="math/tex; mode=display">L_r(x,\omega_r)=L_e(x,\omega_r)+\int_{\Omega}L_r(x',-\omega_i)f(x,\omega_i,\omega_r)\cos \theta_i \mathrm{d}\omega_i</script><p>然后在数学上简化上式，将式子的最后面视为kernel $K(u,v)$</p><script type="math/tex; mode=display">l(u)=e(u)+\int l(v) K(u,v)\mathrm{d}V</script><p>然后再将后面的积分写成算子 $\mathcal{K}$</p><script type="math/tex; mode=display">L=E+\mathcal{K}L</script><p>其中 $L$ 是我们想算的反射能量。我们如果将 $L$ 想象成，则 $\mathcal{K}$ 的作用方式就类似于一个矩阵</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{I}L-\mathcal{K}L&=E \\(\mathcal{I}-\mathcal{K})L&=E \\\Rightarrow L&=(\mathcal{I}-\mathcal{K})^{-1}E\end{aligned}</script><p>再利用泰勒展开</p><script type="math/tex; mode=display">\begin{aligned}L&=(\mathcal{I}+\mathcal{K}+\mathcal{K^{2}}+ \cdots )E \\&=E+\mathcal{K}E+\mathcal{K^{2}}E+ \cdots \end{aligned}</script><p>就得到了 $L$ 的表达式。对于该表达式的理解，$E$ 可以看作是如果只考虑光源，不考虑反射，我们看到的；而 $\mathcal{K}E$ 是直接反射的效果；$\mathcal{K^{2}}E$ 是间接反射的效果；$\mathcal{K^{3}}E$ 则是考虑三次反射再到达眼睛的结果……</p><p>如果考虑光源直接光照加上所有反射，就是我们所说的全局光照。回忆之前的光栅化，着色所做的就是直接反射项 $\mathcal{K}E$，后面的那些多次反射的项对于光栅化来说并不好处理。</p><h2 id="Monte-Carlo-Integration"><a href="#Monte-Carlo-Integration" class="headerlink" title="Monte Carlo Integration"></a>Monte Carlo Integration</h2><p>引入蒙特卡洛积分的原因：函数 $f(x)$ 比较复杂，算出定积分 $\displaystyle \int_{a}^{b}f(x)\mathrm{d}x$ 的解析解很困难。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/monte_carlo_integration.png' width=400></div><p>不同于黎曼积分，蒙特卡洛积分使用的是一种随机采样的方法。在 $a$ 和 $b$ 之间随机采样，设采样的概率密度函数(PDF)为 $p(x)$，即随机变量 $X\sim p(x)$，那么随机变量 $Y=f(X)\sim p(x)$，</p><script type="math/tex; mode=display">\int_{a}^{b}f(x)\mathrm{d}x=\int f(x) \frac{\mathrm{d}p}{p(x)} \thickapprox \sum_{i}f(x_i) \frac{p_{i}}{p(x_i)} = \frac{1}{N} \sum_{i=1}^{N} \frac{f(x_i)}{p(x_i)}</script><p>那么如果我们将 $p(x)$ 取均匀分布，则有</p><script type="math/tex; mode=display">\int_{a}^{b}f(x)\mathrm{d}x\thickapprox \frac{b-a}{N}\sum_{i=1}^{N}f(x_i)</script><p>可以预见，采样次数越多，对定积分的估计越准确。</p><h2 id="Path-Tracing"><a href="#Path-Tracing" class="headerlink" title="Path Tracing"></a>Path Tracing</h2><h3 id="Motivation-Whitted-Style-Ray-Tracing-rightarrow-Rendering-Equation"><a href="#Motivation-Whitted-Style-Ray-Tracing-rightarrow-Rendering-Equation" class="headerlink" title="Motivation: Whitted-Style Ray Tracing $\rightarrow$ Rendering Equation"></a>Motivation: Whitted-Style Ray Tracing $\rightarrow$ Rendering Equation</h3><p>之前提到的Whitted-Style Ray Tracing执行的总是镜面反射和折射，同时在漫反射的面光线会停止传播。</p><p>但这些简化显然是不太合理的，因此需要引入Path Tracing。Path Tracing使用的就是渲染方程(Rendering Equation)</p><script type="math/tex; mode=display">L_o(p,\omega_o)=L_e(p,\omega_o)+\int_{\Omega^{+}}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n\cdot \omega_i)\mathrm{d}\omega_i</script><p>那么此时我们需要解决两个问题</p><ul><li>求出上述对半球面的积分</li><li>考虑光线多次反射导致的递归计算</li></ul><h4 id="A-Simple-Monte-Carlo-Solution"><a href="#A-Simple-Monte-Carlo-Solution" class="headerlink" title="A Simple Monte Carlo Solution"></a>A Simple Monte Carlo Solution</h4><p>首先只考虑光源直接光照的情形，那么现在要解决的问题就是对半球面积分，这里我们使用蒙特卡洛积分。</p><p>类似于介绍蒙特卡洛积分时我们在 $ab$ 区间采样，这里我们在半球面上采样。最简单的就是均匀采样，则此时 $\operatorname{Pr}(\omega_i)=1/2\pi$</p><script type="math/tex; mode=display">\therefore L_o(p,\omega_o) \thickapprox \frac{1}{N} \sum_{i=1}^{N} \frac{L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n\cdot \omega_i)}{\operatorname{Pr}(\omega_i)}</script><p>然后就可以给出算法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    Randomly choose N directions wi~pdf</span><br><span class="line">    Lo = 0.0</span><br><span class="line">    For each wi</span><br><span class="line">        Trace a ray r(p, wi)</span><br><span class="line">        If ray r hit the light</span><br><span class="line">            Lo += (1 / N) * L_i * f_r * cosine / pdf(wi)</span><br><span class="line">Return Lo</span><br></pre></td></tr></table></figure></p><p>伪代码中 <code>If ray r hit the light</code> 说明在这里我们只考虑直接光照。</p><h4 id="Introducing-Global-Illumination"><a href="#Introducing-Global-Illumination" class="headerlink" title="Introducing Global Illumination"></a>Introducing Global Illumination</h4><p>接下来考虑全局光照。这里我们将别的物体反射出的光线加上光源光线即可。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/introducing_global_illumination.png' width=500></div><p>于是我们在代码中加入其他物体反射光的项<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    Randomly choose N directions wi~pdf</span><br><span class="line">    Lo = 0.0</span><br><span class="line">    For each wi</span><br><span class="line">        Trace a ray r(p, wi)</span><br><span class="line">        If ray r hit the light</span><br><span class="line">            Lo += (1 / N) * L_i * f_r * cosine / pdf(wi)</span><br><span class="line">        Else If ray r hit an object at q</span><br><span class="line">            Lo += (1 / N) * shade(q, -wi) * f_r * cosine / pdf(wi)</span><br><span class="line">Return Lo</span><br></pre></td></tr></table></figure></p><h3 id="Path-Tracing-1"><a href="#Path-Tracing-1" class="headerlink" title="Path Tracing"></a>Path Tracing</h3><h4 id="Problem-1：Explosion-of-rays-Path-Tracing"><a href="#Problem-1：Explosion-of-rays-Path-Tracing" class="headerlink" title="Problem 1：Explosion of #rays - Path Tracing"></a>Problem 1：Explosion of #rays - Path Tracing</h4><p>但是如果直接使用上面的方法会遇到一个问题，就是如果考虑多次反射，光线的数量会爆炸性地增长</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/explosion_of_rays.png' width=500></div><p>为了防止指数爆炸性地增长，我们将考虑的反射光线数量设置为 $N=1$，即在做蒙特卡洛积分的时候只采样一次。这固然会导致比较大的噪声，但如果我们在计算一个像素着色的时候设置的光线路径(path)足够多，最后的结果依然使可以接受的。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/ray_generation.png' width=450></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    Randomly choose ONE direction wi~pdf(w)</span><br><span class="line">    Trace a ray r(p, wi)</span><br><span class="line">    If ray r hit the light</span><br><span class="line">        Return L_i * f_r * cosine / pdf(wi)</span><br><span class="line">    Else If ray r hit an object at q</span><br><span class="line">        Return shade(q, -wi) * f_r * cosine / pdf(wi)</span><br></pre></td></tr></table></figure><p>这时得到的算法就可以被称为路径追踪(Path Tracing)，这就是因为我们对一个像素要计算很多路径。</p><h4 id="Ray-Generation"><a href="#Ray-Generation" class="headerlink" title="Ray Generation"></a>Ray Generation</h4><p>然后我们需要考虑如何生成这些光线路径。我们对一个像素进行均匀的采样，使之引出 $N$ 条光线，假如说光线能够打到物体，那么就计算一次着色。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ray_generation(camPos, pixel)</span><br><span class="line">    Uniformly choose N sample positions within the pixel</span><br><span class="line">    pixel_radiance = 0.0</span><br><span class="line">    For each sample in the pixel</span><br><span class="line">        Shoot a ray r(camPos, cam_to_sample)</span><br><span class="line">        If ray r hit the scene at p</span><br><span class="line">            pixel_radiance += 1 / N * shade(p, sample_to_cam)</span><br><span class="line">    Return pixel_radiance</span><br></pre></td></tr></table></figure></p><h4 id="Problem-2-The-recursive-algorithm-Russian-Roulette-RR"><a href="#Problem-2-The-recursive-algorithm-Russian-Roulette-RR" class="headerlink" title="Problem 2: The recursive algorithm - Russian Roulette (RR)"></a>Problem 2: The recursive algorithm - Russian Roulette (RR)</h4><p>在解决了光线数量爆炸的问题之后，我们还需要面对递归无法停止的问题。这个时候就可以引入一种概率算法——俄罗斯轮盘赌(Russian Roulette)。</p><p>首先我们手动设置一个概率 $P(0&lt;P&lt;1)$，然后对于任意一条出射光线，我们都设它有 $P$ 的概率返回光线强度 $L_o / P$；同时有 $1-P$ 的概率直接返回 $0$。然后我们考虑相机接收到能量的期望值</p><script type="math/tex; mode=display">E=P\cdot (L_o /P)+(1-P)\cdot 0=L_{o}</script><p>与预期结果相符。这时算法改为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    Manually specify a probability P_RR</span><br><span class="line">    Randomly select ksi in a uniform dist. in [0, 1]</span><br><span class="line">    If (ksi &gt; P_RR) return 0.0;</span><br><span class="line"></span><br><span class="line">    Randomly choose ONE direction wi~pdf(w)</span><br><span class="line">    Trace a ray r(p, wi)</span><br><span class="line">    If ray r hit the light</span><br><span class="line">        Return L_i * f_r * cosine / pdf(wi) / P_RR</span><br><span class="line">    Else If ray r hit an object at q</span><br><span class="line">        Return shade(q, -wi) * f_r * cosine / pdf(wi) / P_RR</span><br></pre></td></tr></table></figure></p><p>到此为止，这就已经是个正确的Path Tracing算法了。</p><h4 id="Sampling-the-Light"><a href="#Sampling-the-Light" class="headerlink" title="Sampling the Light"></a>Sampling the Light</h4><p>上述的算法虽然是正确的，但是并不高效。如果我们单位像素取的光线数量(即采样次数)不够多，那么效果会如左图所示，有很大的噪声。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/different_spp.png' width=500></div><p>这是因为如果我们在计算半球面定积分时均匀采样，那么可能需要很多的光线才能打到光源，大多数光线都是被浪费的</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/reasion_of_being_inefficient.png' width=500></div><p>因此可以考虑根据场景具体情况控制蒙特卡洛积分采样时的概率密度函数。如果希望不浪费光线，我们可以从对半球面采样转为对光源采样</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/sampling_the_light.png' width=250></div><p>如果在光源上采样，假设光源面积为 $A$，我们让采样的概率密度函数为 $1 /A$，然后将对立体角的积分改写为对光源面积的积分。从图上不难看出</p><script type="math/tex; mode=display">\mathrm{d}\omega= \frac{\mathrm{d}A\cos \theta'}{\left\| x'-x \right\|_{}^{2}}</script><p>则此时渲染方程变为</p><script type="math/tex; mode=display">L_o(p,\omega_o)=L_e(p,\omega_o)+\int_{A}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o) \frac{\cos \theta \cos \theta'}{\left\| x'-x \right\|_{}^{2}}\mathrm{d} A</script><p>同样使用蒙特卡洛积分就能解决大量光线浪费的问题。</p><p>最后考虑改进的算法：</p><ul><li>对于直接反射，我们采用上述对光源积分的方法，同时不需要使用RR</li><li>对于间接反射，我们还是采用原来的方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Contribution from the light source.</span><br><span class="line">L_dir = 0.0</span><br><span class="line">Uniformly sample the light at x&#x27; (pdf_light = 1 / A)</span><br><span class="line">Shoot a ray from p to x&#x27;</span><br><span class="line">If the ray is not blocked in the middle</span><br><span class="line">    L_dir = L_i * f_r * cos θ * cos θ’ / |x’ - p|^2 / pdf_light</span><br><span class="line"></span><br><span class="line"># Contribution from other reflectors.</span><br><span class="line">L_indir = 0.0</span><br><span class="line">Test Russian Roulette with probability P_RR</span><br><span class="line">Uniformly sample the hemisphere toward wi (pdf_hemi = 1 / 2pi)</span><br><span class="line">Trace a ray r(p, wi)</span><br><span class="line">If ray r hit a non-emitting object at q</span><br><span class="line">    L_indir = shade(q, -wi) * f_r * cos θ / pdf_hemi / P_RR</span><br><span class="line"></span><br><span class="line">Return L_dir + L_indir</span><br></pre></td></tr></table></figure></li></ul><p>伪代码中的 <code>If the ray is not blocked in the middle</code> 是为了检测物体是否被光源直接照射到。</p>]]></content>
      
      
      <categories>
          
          <category> computer graphics notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ray Tracing 1</title>
      <link href="/posts/a319889c.html"/>
      <url>/posts/a319889c.html</url>
      
        <content type="html"><![CDATA[<h2 id="Why-Ray-Tracing"><a href="#Why-Ray-Tracing" class="headerlink" title="Why Ray Tracing?"></a>Why Ray Tracing?</h2><p>光栅化不能很好的展现某些会受到全局影响的性质。比如说图像的阴影，物体的模糊反射，间接光照。尤其是对于光线多次弹射的情形，光栅化效果并不好。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/global_effects.png' width=500></div><p>通常而言，我们认为光栅化是一种比较快，但是效果并不是很好(比较近似)的算法。而光线追踪则比较精确，渲染质量高，但是生成过程会比较慢。所以光栅化通常是实时的，而光线追踪很多时候是离线的。</p><h2 id="Basic-Ray-Tracing-Algorithm-Whitted-Style-Ray-Tracing"><a href="#Basic-Ray-Tracing-Algorithm-Whitted-Style-Ray-Tracing" class="headerlink" title="Basic Ray-Tracing Algorithm(Whitted-Style Ray Tracing)"></a>Basic Ray-Tracing Algorithm(Whitted-Style Ray Tracing)</h2><h3 id="Light-Rays"><a href="#Light-Rays" class="headerlink" title="Light Rays"></a>Light Rays</h3><p>图形学中对光线的假设：</p><ul><li>光线沿直线传播</li><li>光线之间不会相互影响</li><li>光线从光源传播到眼睛，光线可逆(所以可以等价的认为眼睛可以发出光，一直对应到光源)</li></ul><h3 id="Ray-Casting"><a href="#Ray-Casting" class="headerlink" title="Ray Casting"></a>Ray Casting</h3><p>光线投射就是对每个像素，从相机引出一条光线射到物体上，然后判断物体上的点是否被光源照到。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/ray_casting.png' width=300></div><p>提到光线追踪时，我们默认眼睛是一个针孔摄像机(不考虑镜头的大小)，光源则认为是点光源，光源照射到物体上是认为发生完美的反射或折射。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/pinhole_camera_model.png' width=500></div><h3 id="Recursive-Whitted-Style-Ray-Tracing"><a href="#Recursive-Whitted-Style-Ray-Tracing" class="headerlink" title="Recursive (Whitted-Style) Ray Tracing"></a>Recursive (Whitted-Style) Ray Tracing</h3><p>我们在上面讨论的还是光线只反射一次的情形，而要考虑光线多次反射折射，则需使用Whitted-Style光线追踪。</p><p>这是最早通过光线追踪得到的一个例子。从图中看出光线追踪对阴影的表示还是较好的。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/whitted-style_ray_tracing_example.png' width=300></div><p>我们依然假设光从眼睛中发出，通过一个像素。当光与第一个物体相交时，我们考虑反射光线与折射光线，而这些反射和折射光线会和其他物体再相交。同时在考虑着色时，我们对每一个与场景中物体的交点(就是下图中的那几个黑点)都要考虑其着色情况，这些着色值最终都将对像素产生影响。当然在实际的计算中需要考虑光线传播时光强的衰减情况。</p><p>我们在这里对不同类型的光线做一个简单的归类：从眼睛射出的光线称为primary ray，而经过弹射的光线都成为secondary ray，从光源连出以确定可见性的称为shadow ray。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/recursive_ray_tracing.png' width=500></div><h2 id="Ray-Surface-Intersection"><a href="#Ray-Surface-Intersection" class="headerlink" title="Ray-Surface Intersection"></a>Ray-Surface Intersection</h2><h3 id="Ray-Equation"><a href="#Ray-Equation" class="headerlink" title="Ray Equation"></a>Ray Equation</h3><p>在图形学中，我们用光线的发出点 $\bm{o}$ 和方向 $\bm{d}$ 来定义光线，而光线的方程则写成</p><script type="math/tex; mode=display">\bm{r}(t)=\bm{o}+t \bm{d} \quad 0\le t<\infty</script><h3 id="Ray-Intersection-With-Implicit-Surface"><a href="#Ray-Intersection-With-Implicit-Surface" class="headerlink" title="Ray Intersection With Implicit Surface"></a>Ray Intersection With Implicit Surface</h3><p>在求光线与一个曲面的交点时，如果曲面用隐式表示法表示，那么直接代入即可。比如对于一个球体的方程：</p><script type="math/tex; mode=display">\bm{p}:(\bm{p}-\bm{c})^{2}-R^{2}=0</script><p>其中 $\bm{c}$ 为球心。则联立光线与球体的方程，得到</p><script type="math/tex; mode=display">(\bm{o}+t\bm{d}-\bm{c})^{2}-R^{2}=0</script><p>即可求出 $t$，从而得到交点。</p><p>对于一种一般的情况：</p><script type="math/tex; mode=display">\bm{p}:f(\bm{p})=0</script><p>同样代入得到</p><script type="math/tex; mode=display">f(\bm{o}+t \bm{d})=0</script><p>进行数值求解即可。</p><h3 id="Ray-Intersection-With-Triangle-Mesh"><a href="#Ray-Intersection-With-Triangle-Mesh" class="headerlink" title="Ray Intersection With Triangle Mesh"></a>Ray Intersection With Triangle Mesh</h3><p>图形学中的许多物体实际上使用三角形表示的，因此计算光线和三角形网格求交非常重要。</p><p>一种最简单的判断光线和物体交点的方法就是遍历组成物体的所有三角形，考虑它们是有交点，然后取最近的交点即可。这种方法虽然思路简单，但是计算量非常大。</p><h4 id="Ray-Intersection-With-Triangle"><a href="#Ray-Intersection-With-Triangle" class="headerlink" title="Ray Intersection With Triangle"></a>Ray Intersection With Triangle</h4><p>但是我们还是先来考虑如何求光线与三角形的交点。</p><p>我们将光线和三角形求交分解为两个问题：</p><ul><li>光线和平面求交</li><li>交点是否在三角形内(我们在之前已经考虑过了如何判断一个点是否在三角形内的方法)</li></ul><h4 id="Ray-Intersection-With-Plane"><a href="#Ray-Intersection-With-Plane" class="headerlink" title="Ray Intersection With Plane"></a>Ray Intersection With Plane</h4><p>而定义一个平面需要一个平面上的点和一条法向量。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/ray_intersection_with_plane.png' width=250></div><p>平面的方程为</p><script type="math/tex; mode=display">\bm{p}:(\bm{p}-\bm{p'})\cdot \bm{N}=0 \quad \Rightarrow ax+by+cz+d=0</script><p>代入光线的方程，有</p><script type="math/tex; mode=display">(\bm{o}+t \bm{d}-\bm{p'})\cdot \bm{N}=0 \Rightarrow t=\frac{(\bm{p'}-\bm{o})\cdot \bm{N}}{\bm{d}\cdot \bm{N}}</script><p>然后检查是否有 $0\le t&lt;\infty$ 即可。最后就能得到光线和平面的交点。</p><h4 id="Moller-Trumbore-Algorithm"><a href="#Moller-Trumbore-Algorithm" class="headerlink" title="Möller Trumbore Algorithm"></a>Möller Trumbore Algorithm</h4><p>除了先计算交点再判断交点是否在三角形内，还有算法能一次直接解出光线和三角形的交点。这就是Möller Trumbore算法。</p><p>该算法利用了三角形的重心坐标</p><script type="math/tex; mode=display">\bm{O}+t \bm{D}=(1-b_1-b_2)\bm{P_0}+b_1 \bm{P_1}+b_2 \bm{P_2}</script><p>如果解得 $0&lt;b_1,b_2,(1-b_1-b_2)&lt;1$，那么光线就和三角形有交点。而为了解出 $t,b_1,b_2$，我们看出上述式子恰好给出了三个方程，因此可以解得：</p><script type="math/tex; mode=display">\begin{pmatrix}     t \\ b_1 \\b_2 \end{pmatrix} =\frac{1}{\bm{S_1}\cdot \bm{E_1}}\begin{pmatrix}     \bm{S_2}\cdot \bm{E_2} \\ \bm{S_1}\cdot \bm{S} \\ \bm{S_2}\cdot \bm{D} \end{pmatrix}</script><p>其中</p><script type="math/tex; mode=display">\bm{E_1}=\bm{P_1}-\bm{P_0} \quad \bm{E_2}=\bm{P_2}-\bm{P_0} \\\bm{S}=\bm{O}-\bm{P_0} \quad \bm{S_1}=\bm{D}\times \bm{E_2}\quad \bm{S_2}=\bm{S}\times \bm{E_1}</script><h3 id="Accelerating-Ray-Surface-Intersection"><a href="#Accelerating-Ray-Surface-Intersection" class="headerlink" title="Accelerating Ray-Surface Intersection"></a>Accelerating Ray-Surface Intersection</h3><p>用上面提到的方法固然可以求出光线和物体相交情况，但是对于比较复杂的物体而言，这种操作计算量太大，是不现实的，因此需要能加速的方法。</p><h4 id="Bounding-Volumes"><a href="#Bounding-Volumes" class="headerlink" title="Bounding Volumes"></a>Bounding Volumes</h4><p>使用包围盒(Bounding Box)将物体包围起来，如果光线不和这个包围盒相交，那么必然不会和物体相交。使用这种方法能够减小不少计算量。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/bounding_volumes.png' width=500></div><p>Bounding Volumes可能是各种简单形状，而在三维空间中我们最常用的就是轴对齐(Axis-Aligned)的长方体，即各条棱都与坐标轴平行。这里的长方体，我们将其视作三对平面为成的空间。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/bouding_box.png' width=200></div><p>这里使用轴对齐的长方体是为了减小计算量。对于一个一般的平面，计算交点的公式为 $t=\frac{(\bm{p’}-\bm{o})\cdot \bm{N}}{\bm{d}\cdot \bm{N}}$，而如果这个平面的法线和 $x$ 轴平行，则公式为 $t=\frac{\bm{p<em>{x}’}-\bm{o</em>{x}}}{\bm{d_{x}}}$</p><h4 id="Ray-Intersection-with-Axis-Aligned-Box"><a href="#Ray-Intersection-with-Axis-Aligned-Box" class="headerlink" title="Ray Intersection with Axis-Aligned Box"></a>Ray Intersection with Axis-Aligned Box</h4><p>然后需要考虑光线如何与包围盒求交。首先我们做一个简化，考虑二维的情形。</p><p>我们首先考虑 $x<em>0$ 和 $x_1$ 形成的对面，这两个面和光线的交点对应的 $t$ 为 $t</em>{\min}$ 和 $t<em>{\max}$，而对 $y_0$ 与 $y_1$ 形成的对面同样以这种方式考虑。然后取 $\max \left{ t</em>{\min} \right}$ 和 $\min\left{ t_{\max} \right}$，就能得到光线进入和离开包围盒的时间。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/ray_intersection_with_axis-aligned_box.png' width=600></div><p>那么类推到三维情形，对于三对平面，我们能算出三对 $t<em>{\min}$ 和 $t</em>{\max}$，取</p><script type="math/tex; mode=display">t_{enter}=\max\left\{ t_{\min} \right\}, t_{exit}=\min\left\{ t_{\max} \right\}</script><ul><li>若 $t<em>{enter}&lt;t</em>{exit}$ 且 $t_{exit}&gt;0$，则光线和包围盒有交点。</li><li>若 $t<em>{enter}&lt;0$ 且 $t</em>{exit}\ge 0$，则光源在盒子内。</li></ul><h3 id="Accelerating-Uniform-Spatial-Partitions-Grids"><a href="#Accelerating-Uniform-Spatial-Partitions-Grids" class="headerlink" title="Accelerating:Uniform Spatial Partitions (Grids)"></a>Accelerating:Uniform Spatial Partitions (Grids)</h3><h4 id="Preprocess-–-Build-Acceleration-Grid"><a href="#Preprocess-–-Build-Acceleration-Grid" class="headerlink" title="Preprocess – Build Acceleration Grid"></a>Preprocess – Build Acceleration Grid</h4><p>我们认为光线和包围盒求交计算的速度非常快，而与物体求交计算速度则比较慢。</p><p>首先我们找到一个包围盒之后，想要求出光线和包围盒中的物体的相交情况，因为直接求光线和物体相交是比较慢的，所以我们先对场景做预处理。我们将包围盒分成很多均匀的格子(grid)，并找出哪些格子会包含物体，然后考虑光线射入，先看光线会通过哪些格子，假如通过的某个格子恰好包含了物体，那么就计算光线是否会和这个物体相交。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/ray_scene_intersection.png' width=300></div><h4 id="Grid-Resolution"><a href="#Grid-Resolution" class="headerlink" title="Grid Resolution?"></a>Grid Resolution?</h4><p>如果不做划分，那么相当于没有加速；但是如果做了太多的划分，会导致需要计算非常多次光线与盒子求交，同样会影响速度。因此需要找到一个比较合适的划分大小。</p><p>根据经验公式，应该有</p><script type="math/tex; mode=display">\#cells = C * \# objs</script><p>其中在三维情况下， $C\thickapprox 27$。#cell是格子的数量，而#objs是包围盒中物体的数量。</p><h4 id="When-Uniform-Grids-Work-and-When-Fail"><a href="#When-Uniform-Grids-Work-and-When-Fail" class="headerlink" title="When Uniform Grids Work and When Fail"></a>When Uniform Grids Work and When Fail</h4><p>如果物体在场景中分布比较均匀，效果就比较好。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/uniform_grid_work.png' width=600></div>但是如果场景中空的部分比较多，物体分布不均匀，就会出现"teapot in stadium" problem，那光线就必须经过非常多的格子才能和物体相交。<div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/uniform_gird_fail.png' width=500></div><h3 id="Accelerating-Spatial-Partitions"><a href="#Accelerating-Spatial-Partitions" class="headerlink" title="Accelerating:Spatial Partitions"></a>Accelerating:Spatial Partitions</h3><p>由teapot in stadium problem，我们知道直接将空间划分成等大小的格子是不合适的，因此需要引入空间划分，在比较空旷的地方用较大的格子，物体密集的地方则用较小的。</p><h4 id="Spatial-Pratitioning-Example"><a href="#Spatial-Pratitioning-Example" class="headerlink" title="Spatial Pratitioning Example"></a>Spatial Pratitioning Example</h4><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/spatial_partitioning_example.png' width=500></div><p>Oct-Tree指的是八叉树，即将每个立方体都均匀划分成8个立方体(这里是二维图形，所以切成4块)，划分终止的依据为划分到的格子为空或者其中物体数量足够少。但是这种方法并不常用，因为当维度较高时划分的数量会指数级增加。</p><p>KD-Tree与八叉树相似，但是每次只将一个格子分成两部分，划分的顺序为水平-竖直-水平-竖直，保证划分较为均匀。</p><p>BSP-Tree是将空间二分，划分的方法是每次选一个方向，但可以是斜着的。BSP-Tree的问题主要在于划分的平面不与坐标轴垂直，因此不好计算。</p><h4 id="KD-Tree-Pre-Processing"><a href="#KD-Tree-Pre-Processing" class="headerlink" title="KD-Tree Pre-Processing"></a>KD-Tree Pre-Processing</h4><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/kd_tree_pre_processing.png' width=500></div><p>将空间划分成kd-tree的加速结构，信息用树来存储</p><p>叶子节点存储：几何形体的信息<br>中间节点存储：</p><ul><li>划分的方向 x-,y-,或者z-</li><li>划分的位置(不一定是在正中间)</li><li>两个子节点指向划分开的两半</li></ul><h4 id="Travering-a-KD-Tree"><a href="#Travering-a-KD-Tree" class="headerlink" title="Travering a KD-Tree"></a>Travering a KD-Tree</h4><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/Traversing_a_kd_tree.png' width=500></div><p>想要利用KD-Tree的结构加速图形求交，首先考虑中间节点，比如先判断光线与包围盒A是否有交点：如果有的话，那么光线和A的子节点1和B都有可能有交点；如果没有则无需继续考虑。对于树上的叶子节点且该包围盒与光线相交，比如1，我们就直接考虑光线与1中所有物体求交。</p><p>但是KD-Tree存在一些问题，比如不方便判定一个AABB的盒子与物体是否有交集；以及一个物体可能在很多包围盒内，需要被存储和计算多次。</p><h3 id="Accelerating-Object-Partitions-amp-Bounding-Volume-Hierarchy-BVH"><a href="#Accelerating-Object-Partitions-amp-Bounding-Volume-Hierarchy-BVH" class="headerlink" title="Accelerating:Object Partitions &amp; Bounding Volume Hierarchy (BVH)"></a>Accelerating:Object Partitions &amp; Bounding Volume Hierarchy (BVH)</h3><p>通过划分物体得到的加速结构，这种结构如今在图形学中得到了非常广泛的应用。</p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/bounding_volume_hierarchy.png' width=500></div><p>该方法可以省去三角形和包围盒求交的过程，同时一个物体也不会在多个包围盒中。而产生的新的问题就是划分的空间会有重叠。</p><h4 id="Building-BVHs"><a href="#Building-BVHs" class="headerlink" title="Building BVHs"></a>Building BVHs</h4><p>划分的步骤为：</p><ul><li>找到一个包围盒</li><li>将包围盒中的物体分为两个部分<ul><li>找最长的轴做划分</li><li>划分时取中间的三角形(用重心表示三角形位置)</li></ul></li><li>重新计算这两个部分的包围盒</li><li>当包围盒中的物体足够少时停止划分</li></ul><p>最后物体的信息同样存在叶子节点中。</p><h4 id="BVH-Traversal"><a href="#BVH-Traversal" class="headerlink" title="BVH Traversal"></a>BVH Traversal</h4><p>和KD-Tree相似<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Intersect(Ray ray, BVH node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ray misses node.bbox) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node is a leaf node)</span><br><span class="line">        test intersection with all objs;</span><br><span class="line">        <span class="keyword">return</span> closest intersection;</span><br><span class="line"></span><br><span class="line">    hit1 = Intersect(ray, node.child1);</span><br><span class="line">    hit2 = Intersect(ray, node.child2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> the closer of hit1, hit2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div align=center><img src='../../figure/计算机图形学笔记/Ray-Tracing/bvh_traversal.png' width=300></div>]]></content>
      
      
      <categories>
          
          <category> computer graphics notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub项目部署与git使用</title>
      <link href="/posts/1bd3f9e5.html"/>
      <url>/posts/1bd3f9e5.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>参考了<a href="https://www.bilibili.com/video/BV1r3411F7kn/?spm_id_from=333.999.0.0&amp;vd_source=4818ed7eb881f1eba75c12df1d2bd43c">该视频</a></p></div><h2 id="GitHub项目部署"><a href="#GitHub项目部署" class="headerlink" title="GitHub项目部署"></a>GitHub项目部署</h2><p>创建一个新的GitHub仓库：登录到您的GitHub账号后，在页面右上角点击加号（+）按钮，然后选择“New repository”创建一个新的仓库。</p><p>命名仓库：为仓库取一个名称，并添加可选的描述。<br>选择公开或私有：选择是将仓库设为公开（Public）还是私有（Private），这将决定谁可以访问您的代码。</p><div align=center><img src='../../figure/GitHub项目部署与git使用/create_new_repo.png' width=600></div><p>然后在本地文件执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment"># 初始化本地仓库</span></span><br><span class="line">git add . <span class="comment"># 添加所有文件到暂存区</span></span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span> <span class="comment"># 提交更改</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin &lt;GitHub仓库URL&gt; <span class="comment"># 将本地仓库与远程GitHub仓库关联</span></span><br><span class="line">git push -u origin main <span class="comment"># 将代码推送到GitHub</span></span><br></pre></td></tr></table></figure></p><h2 id="git核心原理"><a href="#git核心原理" class="headerlink" title="git核心原理"></a>git核心原理</h2><div align=center><img src='../../figure/GitHub项目部署与git使用/git核心原理.png' width=700></div><h2 id="git实操"><a href="#git实操" class="headerlink" title="git实操"></a>git实操</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>首先进入文件夹，设置用户名称与邮箱<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global usr.name &lt;your_name&gt;</span><br><span class="line">git config --global usr.email &lt;your_email&gt;</span><br></pre></td></tr></table></figure></p><p>告诉git这个文件夹需要版本控制，所以需要git初始化<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></p><p>初始化之后默认处于主分支main中。</p><h3 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h3><p>对文件进行修改之后，可以通过<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file_name&gt;</span><br></pre></td></tr></table></figure></p><p>进行暂存，也就是放入暂存区。如果想要暂存所有修改，则可以使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></p><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure></p><p>可以进行提交。此时界面会进入到vim(也有可能是nano)编辑器中，输入修改信息。如果修改信息比较简短，可以直接输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &lt;commit_message&gt;</span><br></pre></td></tr></table></figure></p><p>同时暂存和提交操作也可以同时尽进行，这样就可以不用先 <code>add</code> 了。(以下两种操作都可以)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m &lt;commit_message&gt;</span><br><span class="line">git commit -am &lt;commit_message&gt;</span><br></pre></td></tr></table></figure></p><h3 id="显示状态"><a href="#显示状态" class="headerlink" title="显示状态"></a>显示状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>可以显示当前状态。即未暂存的工作区更改，以及未提交的暂存区更改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>则可以显示之前的提交信息。</p><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><p>创建新的分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch_name&gt;</span><br></pre></td></tr></table></figure></p><p>显示所有分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></p><p>切换分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch_name&gt;</span><br></pre></td></tr></table></figure></p><p>删除分支，但是如果该分支未和其它分支合并，git会提醒<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch_name&gt;</span><br></pre></td></tr></table></figure></p><p>如果不想提醒，可以强制删除分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D &lt;branch_name&gt;</span><br></pre></td></tr></table></figure></p><p>创建分支并进入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch_name&gt;</span><br></pre></td></tr></table></figure></p><p>合并分支。此处是将某一分支与当前分支合并<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch_name&gt;</span><br></pre></td></tr></table></figure></p><h2 id="本地git与GitHub"><a href="#本地git与GitHub" class="headerlink" title="本地git与GitHub"></a>本地git与GitHub</h2><p>查看本地仓库和哪些远程仓库有联系<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></p><p>比如会返回<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin  https://github.com/xfhelen/MMBench.git (fetch)</span><br><span class="line">origin  https://github.com/xfhelen/MMBench.git (push)</span><br></pre></td></tr></table></figure></p><p>这里的 <code>origin</code> 表示远程仓库的名字。远程仓库名字通常默认为 <code>origin</code>。这时我们 <code>push</code> 的情况就可以用 <code>origin</code> 代替URL了。</p><p>如果要将本地内容传到远程仓库，则使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></p><p>如果想将远程仓库内容传到本地仓库，则使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode格式化控制</title>
      <link href="/posts/327b67b2.html"/>
      <url>/posts/327b67b2.html</url>
      
        <content type="html"><![CDATA[<p>在vscode中一般使用 <code>alt+shift+F</code> 对代码进行格式化。但是如果在代码开头加上形如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clang-format off</span></span><br></pre></td></tr></table></figure></p><p>的注释，就能让代码无法格式化。</p><p>而如果在代码中加上注释<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clang-format on</span></span><br></pre></td></tr></table></figure></p><p>那么又可以再让后面的代码能正常格式化。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> format </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Geometry</title>
      <link href="/posts/349c2a1b.html"/>
      <url>/posts/349c2a1b.html</url>
      
        <content type="html"><![CDATA[<h2 id="Many-Ways-to-Represent-Geometry"><a href="#Many-Ways-to-Represent-Geometry" class="headerlink" title="Many Ways to Represent Geometry"></a>Many Ways to Represent Geometry</h2><p>表示几何有隐式和显式的方法</p><h3 id="“Implicit”-Representations-of-Geometry"><a href="#“Implicit”-Representations-of-Geometry" class="headerlink" title="“Implicit” Representations of Geometry"></a>“Implicit” Representations of Geometry</h3><p>隐式指的是不会告诉空间中的点具体在哪，而是会说这些点满足的关系。比如说对于一个球，隐式的表示可以是 $x^{2}+y^{2}+z^{2}=1$。普遍而言，就是 $f(x,y,z)=0$。</p><p>隐式表示的缺点：不直观。比如对于 $f(x,y,z)=(2-\sqrt{x^{2}+y^{2}})^{2}+z^{2}-1$，我们并不能直观的看出哪些点在 $f(x,y,z)=0$ 上。但如果将其画出来，形状还是比较简单的</p><div align=center><img src='../../figure/计算机图形学笔记/10-Geometry-Introduction/smapling_hard.png' width=400></div><p>优点：判断某个点和几何形体的关系比较简答。比如想判断点 $(\frac{3}{4},\frac{1}{2},\frac{1}{4})$ 是否在 $f(x,y,z)=x^{2}+y^{2}+z^{2}-1=0$ 内，可以直接将该点代入，有 $f(x,y,z)=-\frac{1}{8}&lt;0$，因此在里面。</p><h3 id="“Explicit”-Representations-of-Geometry"><a href="#“Explicit”-Representations-of-Geometry" class="headerlink" title="“Explicit” Representations of Geometry"></a>“Explicit” Representations of Geometry</h3><p>最直观的显示表达方法就是之前提到的用三角形的表示方法。同时还有一种不那么直观，但同样是显示的方法，就是通过参数映射来定义表面。普遍而言，就是 $f:\mathbb{R}^{2}\rightarrow \mathbb{R}^{3};(u,v)\rightarrow (x,y,z)$。</p><p>比如说，给定 $f(u,v)=((2+\cos u)\cos v,(2+\cos u)\sin v,\sin u)$，就是一种显示的表示，表示的同样是上面那张圆环图片。只要遍历 $u$ 和 $v$，就能遍历几何形体上的所有点。</p><p>但是显式的就不容易判断一个点是否在几何图形内。</p><h2 id="More-Implicit-Representations-in-Computer-Graphics"><a href="#More-Implicit-Representations-in-Computer-Graphics" class="headerlink" title="More Implicit Representations in Computer Graphics"></a>More Implicit Representations in Computer Graphics</h2><h3 id="Algebraic-Surfaces-Implicit"><a href="#Algebraic-Surfaces-Implicit" class="headerlink" title="Algebraic Surfaces (Implicit)"></a>Algebraic Surfaces (Implicit)</h3><p>直接用数学公式表示(就是之前举的隐式的例子)。对于稍微复杂一些的图形会很难表示。</p><h3 id="Constructive-Solid-Geometry-Implicit"><a href="#Constructive-Solid-Geometry-Implicit" class="headerlink" title="Constructive Solid Geometry (Implicit)"></a>Constructive Solid Geometry (Implicit)</h3><p>用基本几何的布尔运算来表示更复杂一点的几何形体</p><div align=center><img src='../../figure/计算机图形学笔记/10-Geometry-Introduction/csg.png' width=600></div><h3 id="Distance-Functions-Implicit"><a href="#Distance-Functions-Implicit" class="headerlink" title="Distance Functions (Implicit)"></a>Distance Functions (Implicit)</h3><p>可以使用距离函数对两个表面进行blend操作。</p><div align=center><img src='../../figure/计算机图形学笔记/10-Geometry-Introduction/distance_function.png' width=600></div><p>像第一行那样，假如直接对两幅图做blend，那么会得到左边黑，中间灰，右边白的结果，而不是一个运动的中间结果。因此我们先求出一个有向的距离函数(这里是一个点到边界的最短距离，外侧为正，内测为负)，然后对这两个距离函数做blend，然后就会得到一个中间状态的距离函数，将该距离函数恢复成形状，就是我们想要的中间状态。</p><h4 id="Level-Set-Methods-Also-implicit"><a href="#Level-Set-Methods-Also-implicit" class="headerlink" title="Level Set Methods (Also implicit)"></a>Level Set Methods (Also implicit)</h4><p>那么如何从距离函数中重新恢复形状，得到物体表面？假如是有一个解析的函数，令 $f(x)=0$ 即可。但如果解析的形式不太好得到，可以使用水平集(类似于等高线)。就是将距离函数在各个格子中的值写出来，最后就能画出距离为 $0$ 的一条曲线，就是表面</p><div align=center><img src='../../figure/计算机图形学笔记/10-Geometry-Introduction/level_set_methods.png' width=300></div><h3 id="Fractals-Implicit"><a href="#Fractals-Implicit" class="headerlink" title="Fractals (Implicit)"></a>Fractals (Implicit)</h3><p>分形(自相似)。类似于算法中的递归。</p><div align=center><img src='../../figure/计算机图形学笔记/10-Geometry-Introduction/fractals.png' width=700></div><h3 id="Implicit-Representations-Pros-amp-Cons"><a href="#Implicit-Representations-Pros-amp-Cons" class="headerlink" title="Implicit Representations - Pros &amp; Cons"></a>Implicit Representations - Pros &amp; Cons</h3><p>优点</p><ul><li>表示简短，方便存储</li><li>方便判断一个点是否在图形内</li><li>方便计算和光线相交关系</li><li>对于简单的模型，能够很简单的描述</li><li>比较容易变换拓扑结构</li></ul><p>缺点：</p><ul><li>不方便表示特别复杂的图形</li></ul><h2 id="Explicit-Representations-in-Computer-Graphics"><a href="#Explicit-Representations-in-Computer-Graphics" class="headerlink" title="Explicit Representations in Computer Graphics"></a>Explicit Representations in Computer Graphics</h2><h3 id="Point-Cloud-Explicit"><a href="#Point-Cloud-Explicit" class="headerlink" title="Point Cloud (Explicit)"></a>Point Cloud (Explicit)</h3><p>最简单的表示方法：表示出一堆点来，只要点和点之间足够密，就能得到想要的几何图形。因此理论上点云可以表示任意的几何形体。</p><p>在三维空间做扫面，输出一般就是点云。而将点云转化为三角形则需要一定的算法。</p><h3 id="Polygon-Mesh-Explicit"><a href="#Polygon-Mesh-Explicit" class="headerlink" title="Polygon Mesh (Explicit)"></a>Polygon Mesh (Explicit)</h3><p>在图形学中运用的最为广泛。</p><div align=center><img src='../../figure/计算机图形学笔记/10-Geometry-Introduction/polygen_mesh.png' width=500></div><h4 id="The-Wavefront-Object-File-obj-Format"><a href="#The-Wavefront-Object-File-obj-Format" class="headerlink" title="The Wavefront Object File (.obj) Format"></a>The Wavefront Object File (.obj) Format</h4><p>如何用多边形来表示图形。通常将数据放在文本文件.obj中，一个文件存储一个物体。</p><div align=center><img src='../../figure/计算机图形学笔记/10-Geometry-Introduction/obj.png' width=700></div><p>这个文件存储的是一个立方体。图中的v存储点，vn定义的是法线，vt定义的是纹理坐标，最后的f(face)则表示由哪三个点构成一个三角形。其中第一个数字选取一个点，第二个数字表示选择第几个纹理坐标，第三个数字表示选取第几个法线。</p><p>比如说 <code>f 5/1/1 1/2/1 4/3/1</code> 就表示需要连接5，1，4这三个点，使用第1，2，3个纹理，以及三个点都是用第1个法线。</p><h2 id="Curves"><a href="#Curves" class="headerlink" title="Curves"></a>Curves</h2><h3 id="Bezier-Curves"><a href="#Bezier-Curves" class="headerlink" title="Bézier Curves"></a>Bézier Curves</h3><p>贝塞尔曲线是需要用一系列控制点来定义一条曲线。曲线需要满足性质：起点和终点分别在 $p_0$ 和 $p_3$ 上，同时切线也需要分别为 $p_0p_1$ 和 $p_2p_3$。</p><div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/defining_bezier_curves.png' width=400></div><h4 id="Evaluating-Bezier-Curves-de-Casteljau-Algorithm"><a href="#Evaluating-Bezier-Curves-de-Casteljau-Algorithm" class="headerlink" title="Evaluating Bézier Curves (de Casteljau Algorithm)"></a>Evaluating Bézier Curves (de Casteljau Algorithm)</h4><p>现在考虑给定一系列任意多个(大于等于三个)控制点，如何画出贝塞尔曲线。</p><p>首先考虑三个控制点的情况(此时做出的曲线叫二次贝塞尔曲线 quadratic Bezier)。给定参数 $t\in [0,1]$，对于任意的 $t$，在图像上我们令 $b_0b_0^{1}=t\cdot b_0b_1$，$b_1b_1^{1}=t\cdot b_1b_2$，$b_0^{1}b_0^{2}=t\cdot b_0^{1}b_1^{1}$，最终如图所示得到的 $b_0^{2}$ 点就是贝塞尔曲线的轨迹。</p><div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/de_casteljau_algo.png' width=350></div><p>对于四个控制点的情形也是类似的</p><div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/de_casteljau_algo_4input.png' width=400></div><p>对于更多个控制点，递归操纵即可。</p><h4 id="Evaluating-Bezier-Curves-Algebraic-Formula"><a href="#Evaluating-Bezier-Curves-Algebraic-Formula" class="headerlink" title="Evaluating Bézier Curves Algebraic Formula"></a>Evaluating Bézier Curves Algebraic Formula</h4><p>首先还是考虑三个控制点的情形</p><script type="math/tex; mode=display">\begin{aligned}b_0^{1}(t)&=(1-t)b_0+tb_1 \\b_1^{1}(t)&=(1-t)b_1+tb_2 \\b_0^{2}(t)&=(1-t)b_0^{1}+tb_1^{1} \\\Rightarrow b_0^{2}(t)&=(1-t)^{2}b_0+2t(1-t)b_1+t^{2}b_2\end{aligned}</script><p>通过观察以及数学归纳法不难得出</p><script type="math/tex; mode=display">b^{n}(t)=b_0^{n}(t)=\sum_{j=0}^{n}b_j B_j^{n}(t)</script><p>其中 $B_j^{n}(t)$ 为伯恩斯坦分布(Bernstein polynomial)</p><script type="math/tex; mode=display">B_i^{n}(t)= {n \choose i}t ^{i}(1-t)^{n-i}</script><p>控制点不仅可以是二维的，也可以是三维的。</p><h4 id="Properties-of-Bezier-Curves"><a href="#Properties-of-Bezier-Curves" class="headerlink" title="Properties of Bézier Curves"></a>Properties of Bézier Curves</h4><ul><li>对于插值的端点，有<script type="math/tex; mode=display">b(0)=b_0\quad b(1)=b_n</script></li><li>对于两端的切线，有<script type="math/tex; mode=display">b'(0)=n(b_1-b_0) \quad b'(1)=n(b_{n}-b_{n-1})</script></li><li>仿射变换(Affine transformation)性质：<br>直接对贝塞尔曲线做仿射变换 $=$ 对曲线的控制点做仿射变换再插值得到贝塞尔曲线</li><li>凸包(Convex hull)性质<ul><li>凸包指的是能够包围一系列给定的几何形体的最小凸多边形<div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/convex_hull.png' width=200></div></li><li>贝塞尔曲线在控制点形成的凸包内</li></ul></li></ul><h3 id="Piecewise-Bezier-Curves"><a href="#Piecewise-Bezier-Curves" class="headerlink" title="Piecewise Bézier Curves"></a>Piecewise Bézier Curves</h3><p>如果控制点太多，贝塞尔曲线会趋于平滑，就难以用控制点直观地控制曲线</p><div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/higher_order_bezier_curves.png' width=250></div><p>因此可以引入逐段控制的贝塞尔曲线。通常让每4个控制点定义一段贝塞尔曲线。</p><div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/piecewise_bezier_curves.png' width=400></div><h4 id="Continuity"><a href="#Continuity" class="headerlink" title="Continuity"></a>Continuity</h4><ul><li>$C^{0}$ 连续(线段连续)：$a_n=b_0$</li><li>$C^{1}$ 连续(切线连续)：$a<em>n=b_0=1 /2(a</em>{n-1}+b_1)$<div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/continuity.png' width=400></div></li></ul><h3 id="Other-types-of-splines"><a href="#Other-types-of-splines" class="headerlink" title="Other types of splines"></a>Other types of splines</h3><p>样条(splines)指的是一段能够经过若干指定点并且具有一定阶数连续导数的曲线。</p><p>B样条(B-splines)是一种比较常用的样条</p><ul><li>是基样条的缩写(basis splines)</li><li>和贝塞尔曲线相比需要更多信息，相当于贝塞尔曲线的扩展</li><li>满足贝塞尔曲线的所有重要性质</li></ul><h2 id="Surfaces"><a href="#Surfaces" class="headerlink" title="Surfaces"></a>Surfaces</h2><h3 id="Bezier-Surfaces"><a href="#Bezier-Surfaces" class="headerlink" title="Bézier Surfaces"></a>Bézier Surfaces</h3><p>以有4×4个控制点的贝塞尔曲面为例</p><div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/bicubic_bezier_surface.png' width=300></div><p>16个控制点会分成4组，每组4个控制点先成贝塞尔曲线；然后再考虑这4条贝塞尔曲线上的点，用来形成另一个方向的曲线，遍历所有点就能形成曲面(就是控制坐标 $u$ 从 $0$ 到 $1$，得到 $v$ 方向的无数条贝塞尔曲线)</p><div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/visualizing_bicubic_bezier_surface.png' width=500></div><h3 id="Mesh-Operations"><a href="#Mesh-Operations" class="headerlink" title="Mesh Operations"></a>Mesh Operations</h3><p>• Mesh subdivision(upsampling)<br>• Mesh simplification(downsampling)<br>• Mesh regularization(same #triangles)</p><h3 id="Subdivision"><a href="#Subdivision" class="headerlink" title="Subdivision"></a>Subdivision</h3><h4 id="Loop-Subdivision"><a href="#Loop-Subdivision" class="headerlink" title="Loop Subdivision"></a>Loop Subdivision</h4><p>将原来的一个三角形划分成4个</p><div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/split_triangle.png' width=300></div><ul><li>对于新产生的点：<div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/new_vertex.png' width=150></div></li></ul><p>将该点的坐标设置为 $3/8\cdot (A+B)+1 /8\cdot (C+D)$</p><ul><li>而对于原来就有的点，同样要修正一下位置：<div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/old_vertex.png' width=250></div></li></ul><p>新的点的位置变为</p><script type="math/tex; mode=display">(1-n\cdot u)\cdot original\_position+u\cdot neighbor\_position\_sum</script><p>其中 $n$ 为顶点的度，而</p><script type="math/tex; mode=display">u=\begin{cases}  \frac{3}{16} \quad n=3\\   \frac{3}{8n} \quad o.w.\end{cases}</script><h4 id="Catmull-Clark-Subdivision-General-Mesh"><a href="#Catmull-Clark-Subdivision-General-Mesh" class="headerlink" title="Catmull-Clark Subdivision (General Mesh)"></a>Catmull-Clark Subdivision (General Mesh)</h4><p>之前的loop细分只能处理所有网格(mesh)都是三角形的情况，如果网格可以是任意形状，那么就需要用到Catmull-Clark细分。</p><div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/catmull_clark_subdivision.png' width=500></div><p>在Catmull-Clark细分中，我们将网格分为四边形(quad face)和非四边形(non-quad face)；同时将顶点(vertex)分为奇异点(extraordinary vertex)和非奇异点，其中奇异点指的是度不为4的顶点。</p><p>然后我们找到原来网格的中心和边的中点来做细分</p><div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/catmull_clark_subdivision_step.png' width=400></div><p>经过一次细分后我们发现所有非四边形现在都变成了四边形；同时原来非四边形的数量就是奇异点增加的数量。</p><p>各个顶点的调整方式如下：</p><ul><li><p>一个面中心的点(face point)</p><div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/face_point.png' width=150></div><script type="math/tex; mode=display">f=\frac{v_1+v_2+v_3+v_4}{4}</script></li><li><p>一条边中心的点(edge point)</p><div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/edge_point.png' width=200></div><script type="math/tex; mode=display">e=\frac{v_1+v_2+f_1+f_2}{4}</script></li><li><p>原来的点(vertex point)</p><div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/vertex_point.png' width=200></div></li></ul><script type="math/tex; mode=display">v=\frac{f_1+f_2+f_3+f_4+2(m_1+m_2+m_3+m_4)+4p}{16}</script><h3 id="Mesh-Simplification"><a href="#Mesh-Simplification" class="headerlink" title="Mesh Simplification"></a>Mesh Simplification</h3><p>目标是减小三角形的数量，同时保持基本的形状。这里我们通过坍缩边(edge collapsing)的方式进行简化。</p><div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/edge_collapsing.png' width=500></div><h4 id="Quadric-Error-Metrics"><a href="#Quadric-Error-Metrics" class="headerlink" title="Quadric Error Metrics"></a>Quadric Error Metrics</h4><p>这里需要引入二次误差度量。比如在下图中，我们就需要控制新产生的点的位置让和原来图形的二次误差最小</p><div align=center><img src='../../figure/计算机图形学笔记/11-Geometry-Curves-and-Surfaces/quadric_error_metrics.png' width=500></div><h4 id="Quadric-Error-of-Edge-Collapse"><a href="#Quadric-Error-of-Edge-Collapse" class="headerlink" title="Quadric Error of Edge Collapse"></a>Quadric Error of Edge Collapse</h4><p>在简化网格的过程中，我们通过坍缩边得到新的点，那么就需要让新的点的位置使得面的二次误差最小。对于整个模型而言，我们可以先计算坍缩了某条边之后得到的最小误差，然后取所有边中最小误差最小的，然后进行坍缩。</p><p>这里需要注意，坍缩了一条边之后，有些边会跟着变化，即坍缩了一条边之后会影响其他边的最小二次误差。这时就需要一个最小堆作为数据结构存储，不仅能方便地取到最小值，同时也能动态更新变化的边。</p><p>这种算法是一个贪心算法，虽然不能保证全局最优解，但是能保证大多数情况下都比较实用。</p>]]></content>
      
      
      <categories>
          
          <category> computer graphics notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自行车拆卸与安装</title>
      <link href="/posts/b487d6c.html"/>
      <url>/posts/b487d6c.html</url>
      
        <content type="html"><![CDATA[<h2 id="轮组系统"><a href="#轮组系统" class="headerlink" title="轮组系统"></a>轮组系统</h2><p>轮组拆装<br><a href="https://www.youtube.com/watch?v=AZXP6rwkSqk">youtube</a>：包含快拆和桶轴，以及非快拆的情况。<br><a href="https://www.bilibili.com/video/BV1YV4y1W7mz/?spm_id_from=333.999.0.0&amp;vd_source=4818ed7eb881f1eba75c12df1d2bd43c">b站</a>：包含快拆和桶轴，同时考虑了V形夹器。</p><p>内外胎更换<br><a href="https://www.youtube.com/watch?v=sGdu4fkrQ9M">youtube</a>：正常的换胎流程<br><a href="https://www.bilibili.com/video/BV13e4y1Z7Pm/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4818ed7eb881f1eba75c12df1d2bd43c">b站</a>：碳轮，没用翘胎棒</p><p>花鼓<br><a href="https://www.bilibili.com/video/BV1dF411B7J7/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4818ed7eb881f1eba75c12df1d2bd43c">b站</a>：培林花鼓更换培林<br><a href="https://www.youtube.com/watch?v=Jw25tqAcn_4">youtube</a>：用花鼓编轮组<br><a href="https://www.youtube.com/watch?v=syG-5gun1Dw">youtube</a>：具体讲解花鼓原理</p><h2 id="变速系统"><a href="#变速系统" class="headerlink" title="变速系统"></a>变速系统</h2><p>飞轮拆装<br><a href="https://www.bilibili.com/video/BV1FD4y167fe/?spm_id_from=333.788&amp;vd_source=4818ed7eb881f1eba75c12df1d2bd43c">b站</a>：旋飞、卡飞，骑行台飞轮<br><a href="https://www.youtube.com/watch?v=iTJ3taJHOn8">youtube</a>：分辨卡飞(cassette)和旋飞(freewheel)<br><a href="https://www.youtube.com/watch?v=9KAaP7pbFV0">youtube</a>：各种卡飞的拆卸和安装<br><a href="https://www.youtube.com/watch?v=rdQE8-ea1uw">youtube</a>：各种旋飞</p><p>后拨<br>后拨安装<br><a href="https://www.bilibili.com/video/BV1Yq4y1f7Vc/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4818ed7eb881f1eba75c12df1d2bd43c">b站</a>：从没有后拨与链条开始，有关于后拨的调整<br><a href="https://www.youtube.com/watch?v=meUQ-BiFL28">youtube</a>：关于各种后拨拆卸与安装的讲解<br><a href="https://www.youtube.com/watch?v=UkZxPIZ1ngY">youtube</a>：后拨调节，包括高低限位螺丝，拉线松紧，B螺丝</p>]]></content>
      
      
      <categories>
          
          <category> 自行车 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自行车轮组几何参数</title>
      <link href="/posts/a25eb973.html"/>
      <url>/posts/a25eb973.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>参考：<a href="https://www.dongchedi.com/article/7041739182246560292">文章1</a></p></div><h2 id="常见轮组尺寸写法"><a href="#常见轮组尺寸写法" class="headerlink" title="常见轮组尺寸写法"></a>常见轮组尺寸写法</h2><ul><li>700×23c是公制单位。指的是轮胎直径700mm，轮框宽度20mm。</li><li>26×1.75是美制单位。指的是轮胎直径26英寸，轮框宽度1.75英寸。(1英寸=2.54公分)</li></ul><p>市场上常见就这两种单位制。</p><ul><li>美国人玩MTB的多，所以MTB常见美制单位。</li><li>欧洲人玩公路车多，所以公路车常见公制单位。</li></ul><h3 id="关于700c"><a href="#关于700c" class="headerlink" title="关于700c"></a>关于700c</h3><h4 id="700"><a href="#700" class="headerlink" title="700"></a>700</h4><p>数字700部分是指轮胎外侧穿过车轮的近似直径，以毫米为单位。轮胎的实际外径会因宽度等因素而异。当安装在具有相同内部宽度的轮圈上时，28 毫米轮胎的外径通常比 23 毫米轮胎的外径大，而轮胎的轮廓也会略微影响整体直径。</p><p>一个更能代表700c的数字622mm，622mm是ISO国际统一标准，指的是车圈的直径，也就是说所有标记700c的轮胎都可以套在直径为622mm的车圈上。</p><p>所以在如今的ISO标准中，700×23c的轮胎的ISO值为20~622，表示适用轮圈宽度为20mm，轮圈轮毂底的直径为622mm。</p><h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><p>C在如今也没有太多意义。</p><p>在过去，也有 700a、700b 和 700d 轮子。骑自行车的人会根据他们的用途在 a、b、c 和 d 轮子之间交换，从a-d车胎由宽变细。700c 和 700d 保留用于比赛，而更宽的 700a 和 700b 轮子用于在 20 世纪初期较粗糙、通常未铺砌的表面上进行训练.</p><p>因为它们最终的轮胎外径大致相同，均为 700 毫米，由于a-d的轮胎的宽度不同，导致轮圈（外径700mm-轮胎的体积宽度）大小不同，700a、700b 和 700d 车轮的胎圈座直径与 700c 不同，因此您需要不同的轮胎来适应每个车轮。</p><p>然而，这对骑手和轮胎制造商来说有点麻烦，因此欧洲车轮和轮胎制造商在当时改善的路面上将700c确定为公路自行车使用的车轮的最佳标准，并停止生产700a、b 和 d 轮辋和轮胎。</p>]]></content>
      
      
      <categories>
          
          <category> 自行车 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 轮组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shading</title>
      <link href="/posts/98456e9e.html"/>
      <url>/posts/98456e9e.html</url>
      
        <content type="html"><![CDATA[<p>definition:The darkening or coloring of an illustration or diagram with parallel lines or a block of color.<br>在绘画上引入颜色和明暗的不同。</p><p>在这门课中，着色(shading)指的是对不同的物体应用不同的材质。</p><h2 id="Shading-is-Local"><a href="#Shading-is-Local" class="headerlink" title="Shading is Local"></a>Shading is Local</h2><p>考虑反射模型时，我们考虑被光照射到的某一个点(shading point)。</p><div align=center><img src='../../figure/计算机图形学笔记/7-Shading-Illumination-Shading-and-Graphics-Pipeline/shading_point.png' width=300></div><p>想要计算这个点在观测的相机眼中的着色情况，需要知道：</p><ul><li>观测方向 $\vec{v}$</li><li>表面法向 $\vec{n}$</li><li>光照方向 $\vec{l}$(这里只考虑了某个光源)</li><li>表面情况，如颜色、材质……</li></ul><p>同时需要注意着色没有考虑阴影，这是因为着色具有局部性，只会考虑光源方向，不会考虑到其他物体的遮挡情况。(shading $\neq$ shadow)</p><h2 id="A-Simple-Shading-Model-Blinn-Phong-Reflectance-Model"><a href="#A-Simple-Shading-Model-Blinn-Phong-Reflectance-Model" class="headerlink" title="A Simple Shading Model (Blinn-Phong Reflectance Model)"></a>A Simple Shading Model (Blinn-Phong Reflectance Model)</h2><p>反射模型</p><h3 id="Perceptual-Observation"><a href="#Perceptual-Observation" class="headerlink" title="Perceptual Observation"></a>Perceptual Observation</h3><div align=center><img src='../../figure/计算机图形学笔记/7-Shading-Illumination-Shading-and-Graphics-Pipeline/perceptual_observations.png' width=600></div><p>图中有高光、漫反射、间接光照</p><h3 id="Diffuse-Reflection-Lambertian-Shading"><a href="#Diffuse-Reflection-Lambertian-Shading" class="headerlink" title="Diffuse Reflection (Lambertian Shading)"></a>Diffuse Reflection (Lambertian Shading)</h3><p>漫反射就是认为当一束光线打到物体上某一个点上时，光线会被均匀地反射到各个方向。<br>同时需要注意，一个漫反射表面的亮度需要考虑物体表面和光线的夹角。假如 $\vec{n}$ 和 $\vec{l}$ 的夹角为 $\theta$，则光照强度与 $\theta$ 成正比。还要再考虑到点光源发出的光强度会随着距离的平方项衰减。</p><script type="math/tex; mode=display">\therefore L_{d}=k_{d}\cdot (I/r^{2})\max_{}(0,\vec{n}\cdot \vec{l})</script><p>式子中 $L<em>{d}$ 为接收到的光强，$k</em>{d}$ 为漫反射的反射率。</p><p>(这只是一个经验模型，与真实的物理情形还是有所不同的)</p><h3 id="Specular-Term"><a href="#Specular-Term" class="headerlink" title="Specular Term"></a>Specular Term</h3><p>高光项，说明表面要光滑，同时观察方向和镜面反射方向要相同或相近。</p><div align=center><img src='../../figure/计算机图形学笔记/7-Shading-Illumination-Shading-and-Graphics-Pipeline/near_mirror_reflection.png' width=300></div><p>但是为了方便计算，我们通常并不直接计算反射光线和观察方向之间的夹角，而是计算平面的法向 $\vec{n}$ 和半程向量(half vector) $\vec{h}$ 的夹角 $\alpha$。当 $\alpha$ 较小时，就能反映出反射方向和观测方向的足够接近。</p><p>半程向量计算较为方便：</p><script type="math/tex; mode=display">\vec{h}=bisector(\vec{v},\vec{l})=\frac{\vec{v}+\vec{l}}{||\vec{v}+\vec{l}||}</script><p>由此可以得到高光项的光强：</p><script type="math/tex; mode=display">L_{s}=k_s(I/r^{2})\max (0,\cos \alpha)^{p}=k_s(I /r^{2})\max (0,\vec{n}\cdot \vec{h})^{p}</script><p>$k_s$ 与颜色有关，而高光一般是白色，因此这里的镜面反射系数我们就认为其是白色。这里没有像漫反射中那样考虑入射角 $\theta$ 大小的情况，这一点严谨来说是要考虑的，但是这个模型将其简化掉了，我们的关注点在于能否看见高光。公式中最后一项有一个指数 $p$，是因为如果直接使用 $\cos \alpha$ 计算的话，对于高光范围的容忍度太高了，这是不合适的，因此需要加一个 $p$ 来减小范围</p><div align=center><img src='../../figure/计算机图形学笔记/7-Shading-Illumination-Shading-and-Graphics-Pipeline/cos_power_plots.png' width=600></div><p>在布林·冯模型(Blinn-Phong Model)中，我们一般将 $p$ 取为 $100\sim 200$ 的值。</p><div align=center><img src='../../figure/计算机图形学笔记/7-Shading-Illumination-Shading-and-Graphics-Pipeline/Ls_Ld.png' width=600></div><p>这里展示了漫反射项和高光项同时作用的情形。可以看出当 $p$ 越大，高光的范围就越小。</p><h3 id="Ambient-Term"><a href="#Ambient-Term" class="headerlink" title="Ambient Term"></a>Ambient Term</h3><p>由于环境光照项过于复杂，这里直接假设任何一个点接收到的来自环境的光是相同的，设为 $I_{a}$。</p><p>因此环境光项的光强为：</p><script type="math/tex; mode=display">L_a=k_a I_a</script><p>是一个常数，也就是说环境光对颜色的影响是均匀的，同时从任何角度看都是如此。</p><h3 id="Blinn-Phong-Reflection-Model"><a href="#Blinn-Phong-Reflection-Model" class="headerlink" title="Blinn-Phong Reflection Model"></a>Blinn-Phong Reflection Model</h3><div align=center><img src='../../figure/计算机图形学笔记/7-Shading-Illumination-Shading-and-Graphics-Pipeline/blinn-phong_reflection.png' width=600></div><script type="math/tex; mode=display">L=L_a+L_{d}+L_s=k_a I_a+k_{d}(I /r^{2})\max (0,\vec{n}\cdot \vec{l})+k_s(I /r^{2})\max (0,\vec{n}\cdot \vec{h})^{p}</script><h2 id="Shading-Frequencies"><a href="#Shading-Frequencies" class="headerlink" title="Shading Frequencies"></a>Shading Frequencies</h2><p>着色的效果与着色频率有关。比如下图第一行，当多边形数量不是很密集的时候，较高的着色频率能带来较好的视觉效果。</p><div align=center><img src='../../figure/计算机图形学笔记/8-Shading-Shading-Pipeline-and-Texture-Mapping/shading_frequency.png' width=500></div><h3 id="Shade-each-triangle-flat-shading"><a href="#Shade-each-triangle-flat-shading" class="headerlink" title="Shade each triangle (flat shading)"></a>Shade each triangle (flat shading)</h3><p>对每个三角形着色。这种着色方式对与较为平滑的面效果不太好。</p><h3 id="Shade-each-vertex-Gouraud-shading"><a href="#Shade-each-vertex-Gouraud-shading" class="headerlink" title="Shade each vertex (Gouraud shading)"></a>Shade each vertex (Gouraud shading)</h3><p>对于三角形的每个顶点着色，而三角形的内部则通过插值的方式补全。</p><h4 id="Defining-Per-Vertex-Normal-Vectors"><a href="#Defining-Per-Vertex-Normal-Vectors" class="headerlink" title="Defining Per-Vertex Normal Vectors"></a>Defining Per-Vertex Normal Vectors</h4><p>那么如何求三角形顶点的法线？</p><p>最好的情形是知道这些三角形需要表示什么样的图形，然后直接求出这个图形的法线即可。但实际上这是不现实的。</p><p>因此常用的方法是对周围三角形的法线求平均。</p><div align=center><img src='../../figure/计算机图形学笔记/8-Shading-Shading-Pipeline-and-Texture-Mapping/average_face_nomals.png' width=250></div><script type="math/tex; mode=display">N_v=\frac{\sum_{i}N_i}{||\sum_{i}N_i||}</script><p>同时还可以对各个三角形的面积进行加权，得到的结果会更加准确。</p><h3 id="Shade-each-pixel-Phong-shading"><a href="#Shade-each-pixel-Phong-shading" class="headerlink" title="Shade each pixel (Phong shading)"></a>Shade each pixel (Phong shading)</h3><p>对于每个像素着色。</p><p>(这里的Phong shading 和 Blinn-Phong Reflectance Model 不同，前者是着色频率，而后者是一个着色模型)</p><h4 id="Defining-Per-Pixel-Normal-Vectors"><a href="#Defining-Per-Pixel-Normal-Vectors" class="headerlink" title="Defining Per-Pixel Normal Vectors"></a>Defining Per-Pixel Normal Vectors</h4><p>如何得到逐像素的法线？这里需要用到重心坐标。</p><h2 id="Graphics-Real-time-Rendering-Pipeline"><a href="#Graphics-Real-time-Rendering-Pipeline" class="headerlink" title="Graphics (Real-time Rendering) Pipeline"></a>Graphics (Real-time Rendering) Pipeline</h2><p>表示从一个场景到最后展现出来的图片中间所经历的过程。</p><div align=center><img src='../../figure/计算机图形学笔记/8-Shading-Shading-Pipeline-and-Texture-Mapping/graphics_pipeline.png' width=700></div><p>这整个操作过程在GPU中已经确定。</p><p>我们之前学习的</p><ul><li>MVP(Model, View, Projection transforms)就发生在Vertex Processing这个过程中；</li><li>MSAA发生在Rasterization过程中；</li><li>Z-Buffer发生在Fragment Processing中</li><li>Shading(具体如何着色可以自己定义)<ul><li>假如是对顶点着色，则发生在Vertex Processing</li><li>假如是对像素着色，则发生在Fragment Processing</li></ul></li></ul><p>Shader是可以自己实现的，是一个可编程的部分，很多语言比如OpenGL就可以实现shader的编写。shader是对每个vertex或者pixel的操作，代码中不用做for循环。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D myTexture; <span class="comment">// program parameter</span></span><br><span class="line">uniform vec3 lightDir;       <span class="comment">// program parameter</span></span><br><span class="line">varying vec2 uv;             <span class="comment">// per fragment value (interp. by rasterizer)</span></span><br><span class="line">varying vec3 norm;           <span class="comment">// per fragment value (interp. by rasterizer)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">diffuseShader</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    vec3 kd;</span><br><span class="line">    kd = texture2d(myTexture, uv);               <span class="comment">// material color from texture</span></span><br><span class="line">    kd *= clamp(dot(–lightDir, norm), <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// Lambertian shading model</span></span><br><span class="line">    gl_FragColor = vec4(kd, <span class="number">1.0</span>);                <span class="comment">// output fragment color</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Texture-Mapping"><a href="#Texture-Mapping" class="headerlink" title="Texture Mapping"></a>Texture Mapping</h2><p>纹理映射：希望定义任意一个点的不同属性。</p><div align=center><img src='../../figure/计算机图形学笔记/8-Shading-Shading-Pipeline-and-Texture-Mapping/texture_mapping.png' width=500></div><p>比如图中的地板纹路，或者是球的不同颜色，这些都会对着色时考虑的系数产生影响。</p><p>纹理映射就是将三维物体的表面映射到一个二维的平面上，这个二维的平面就称为“纹理”(texture)。</p><div align=center><img src='../../figure/计算机图形学笔记/8-Shading-Shading-Pipeline-and-Texture-Mapping/3d_to_2d.png' width=600></div><p>比如说在这张图中，就是将三维的地球的表面投影到二维的地图上。</p><p>纹理如果设计的比较好，那么在经过重复的映射之后不会有明显的边界。</p><h2 id="Interpolation-Across-Triangles-Barycentric-Coordinates"><a href="#Interpolation-Across-Triangles-Barycentric-Coordinates" class="headerlink" title="Interpolation Across Triangles: Barycentric Coordinates"></a>Interpolation Across Triangles: Barycentric Coordinates</h2><p>我们的很多值的计算操作是在三角形的顶点上进行的，而如果我们希望在三角形内部得到平滑的值，就需要插值。而插值需要引入重心坐标。</p><h3 id="Barycentric-Coordinates"><a href="#Barycentric-Coordinates" class="headerlink" title="Barycentric Coordinates"></a>Barycentric Coordinates</h3><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/barycentric_coordinates.png' width=500></div><p>对于三角形所在平面上任意一点，都可以用三角形的三个顶点坐标</p><script type="math/tex; mode=display">(x,y)=\alpha A+\beta B+\gamma C \quad (\alpha+\beta+\gamma=1)</script><p>表示。且如果 $\alpha,\beta,\gamma&gt;0$，可以得出所表示的点在三角形内。</p><p>三角形重心坐标可以用面积来求：</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/geometric_viewpoint.png' width=500></div><p>也可以用公式直接算：</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/formulas.png' width=500></div><p>有了重心坐标，就可以方便地对属性进行插值</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/linear_interpolate.png' width=500></div><p>三角形中间某个点的参数值为</p><script type="math/tex; mode=display">V=\alpha V_{A}+\beta V_{B}+\gamma V_{C}</script><p>其中 $V<em>{A},V</em>{B},V_{C}$ 可以是任意属性。比如说颜色、纹理坐标、深度……但是有一点需要注意，在投影变换下重心坐标可能会改变，因此如果我们想要插值三维空间中的属性，那么我们应该取三维空间中的重心坐标，而不能用投影之后的重心坐标。(比如说对于深度进行插值就应该这么做)</p><h2 id="Applying-Textures"><a href="#Applying-Textures" class="headerlink" title="Applying Textures"></a>Applying Textures</h2><p>如何使用纹理？首先对于空间上一点 $(x,y)$，先将其映射到纹理 $(u,v)$ 上，从纹理上取值(比如说要取漫反射系数 $k_{d}$)，就能得到空间上那一点的漫反射系数。</p><h3 id="Texture-Magnification-Easy-Case"><a href="#Texture-Magnification-Easy-Case" class="headerlink" title="Texture Magnification(Easy Case)"></a>Texture Magnification(Easy Case)</h3><p>解决纹理太小了怎么办的问题。比如说画面中有一堵墙，分辨率应当为4K，但是纹理只有256×256，这就会导致从画面映射到纹理时会出现分数的值。假如采用四舍五入取到某个纹理元素(texel)的方法，则会是最左边那幅图的效果</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/texture_magnification.png' width=600></div><p>这种效果不太好，所以我们希望做出一些处理。这里使用<strong>双线性插值(Bilinear Interpolation)</strong>。</p><p>假如使用四舍五入到整数的方法，那么下面这幅图的红点的纹理将会用离它最近的黑点的纹理表示。这就会导致原图中有好几个相邻像素的纹理值都是一样的。</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/nearest.png' width=500></div><p>如果使用双线性插值</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/bilinear_interpolation.png' width=300></div><p>首先考虑一维的情况：$lerp(x,v_0,v_1)=v_0+x(v_1-v_0)$。那么在本图中，应有：</p><script type="math/tex; mode=display">u_0=lerp(s,u_{00},u_{10})\\u_1=lerp(s,u_{01},u_{11})\\f(x,y)=lerp(t,u_0,u_1)</script><p>最后的 $f(x,y)$ 就是双插值的结果，我们得到了红点处的纹理值。使用双线性插值得到的结果要好不少。而Bicubic使用三次插值，结果会更好。</p><h3 id="Texture-Magnification-Hard-Case"><a href="#Texture-Magnification-Hard-Case" class="headerlink" title="Texture Magnification(Hard Case)"></a>Texture Magnification(Hard Case)</h3><p>解决纹理太大了怎么办的问题。假如纹理的分辨率要比画面高不少，同样会出现问题。比如下面这幅图，近处出现了锯齿，远处出现了摩尔纹。</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/point_sampling_textures.png' width=800></div><p>原因可以从这幅图中看出。在比较近的地方，一个像素覆盖的纹理区域比较小；但是在比较远的地方，一个像素覆盖了很多纹理元素，如果对那个像素仅仅取像素中间点的纹理值，显然是不合理的</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/screen_pixel_foorprint.png' width=600></div><p>回忆之前抗锯齿的方法，可以采用超采样。但是这种方法会耗费更多的计算资源。因此我们希望使用另一种方式——求一个像素点覆盖的纹理区域的平均值(比如上面这幅图右边一个像素点覆盖的纹理区域的平均值)。想要又快又准的查到这些值，就需要使用Mipmap。</p><h3 id="Mipmap-Allowing-fast-approx-square-range-queries"><a href="#Mipmap-Allowing-fast-approx-square-range-queries" class="headerlink" title="Mipmap:Allowing (fast, approx., square) range queries"></a>Mipmap:Allowing (fast, approx., square) range queries</h3><p>Mipmap就是从一张图生成一系列图。图片从第 $0$ 层开始，第 $i$ 层都是第 $i-1$ 层缩小一倍。如下图所示。</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/multum_in_parvo.png' width=600></div><p>也就是说，在拿到纹理之后，我们先生成这么一系列的图片，这里总共需要多占用原图的 $1/3$ 的空间。</p><h4 id="Computing-Mipmap-Level-D"><a href="#Computing-Mipmap-Level-D" class="headerlink" title="Computing Mipmap Level D"></a>Computing Mipmap Level D</h4><p>既然任何一个像素都可以映射到纹理上的一个区域，那么如何知道需要查询的纹理的区域是多大？</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/mipmap_level_d.png' width=600></div><p>这里可以先选择一个像素，然后再考虑这个像素的邻居像素，将它们都映射到纹理上。令</p><script type="math/tex; mode=display">L=\max \left( \sqrt{\left( \frac{\mathrm{d}u}{\mathrm{d}x} \right)^{2}+\left( \frac{\mathrm{d}v}{\mathrm{d}x} \right)^{2}} ,\sqrt{\left( \frac{\mathrm{d}u}{\mathrm{d}y} \right)^{2}+\left( \frac{\mathrm{d}v}{\mathrm{d}y} \right)^{2}}\right) \quad D=\log_2 L</script><p>这里的 $L$ 就可以近似纹理上区域的大小(图中粉色的区域)。也就是说我们现在已经把图片上的一个像素近似成了纹理上的一个正方形。然后为了得到图片上像素的纹理，我们需要再第 $D$ 层查询，此时查询到的纹理也恰好是平均之后得到的一个纹理元素。</p><p>使用上述方法得到的结果如下图，红色代表层数低，蓝色代表层数高</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/visualization_d_rounded.png' width=400></div><p>但是会发现一个问题，就是层数会发生跃变。也就是第 $0$ 层旁边就直接是第 $1$ 层，没有层数的渐变。为了解决这个问题，可以进行插值。</p><h4 id="Trilinear-Interpolation"><a href="#Trilinear-Interpolation" class="headerlink" title="Trilinear Interpolation"></a>Trilinear Interpolation</h4><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/trilinear_interpolation.png' width=500></div><p>这里指的就是，当算出 $D$ 之后，假如 $D$ 不是一个整数值，那么就需要再 $[D]$ 和 $[D]+1$ 层之间进行插值，从而得到 $D$ 层的纹理。这样得到的结果就是渐变的</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/visualization_trilinear_interpolation.png' width=400></div><h3 id="Mipmap-Limitations"><a href="#Mipmap-Limitations" class="headerlink" title="Mipmap Limitations"></a>Mipmap Limitations</h3><p>Mipmap会导致过度模糊化</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/mipmap_limitation.png' width=400></div><h4 id="Irregular-Pixel-Footprint-in-Texture"><a href="#Irregular-Pixel-Footprint-in-Texture" class="headerlink" title="Irregular Pixel Footprint in Texture"></a>Irregular Pixel Footprint in Texture</h4><p>这是因为有些纹理映射在纹理上的形状并不规则，如果只是用正方形进行近似的话会对比较大的空间进行模糊，从而造成不太好的效果。</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/irregular_pixerl_footprint.png' width=600></div><h4 id="Anisotropic-Filtering"><a href="#Anisotropic-Filtering" class="headerlink" title="Anisotropic Filtering"></a>Anisotropic Filtering</h4><p>使用各向异性过滤可以缓解这种问题。</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/anisotropic_filtering.png' width=300></div><p>比如说对于一个卫星的图片，我们不仅对它做等比例压缩，同时还仅在水平和竖直方向做压缩，这样就能在一定程度上解决一个像素映射到纹理上变成一个长方形的问题。但是如果映射过去是一个斜着的形状，同样还是会出问题。</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/ewa_filtering.png' width=300></div><p>如果用EWA来解决，那就会把一个不规则形状拆成很多圆形来处理，然后每次查询一个圆形，这样就能解决这个问题。但是会带来更大的计算量。</p><h2 id="Applications-of-Textures"><a href="#Applications-of-Textures" class="headerlink" title="Applications of Textures"></a>Applications of Textures</h2><p>纹理可以理解为GPU上的一块内存，我们可以对这块内存进行点查询、范围查询、滤波等操作。</p><h3 id="Environment-Map"><a href="#Environment-Map" class="headerlink" title="Environment Map"></a>Environment Map</h3><p>在一个房间里，向四面八方看，在任何一个方向都会有光，如果将这些光都记录下来，就是环境贴图(Environment Map)。</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/environment_map.png' width=600></div><p>比如说左边这幅图中，就是来自各个方向的环境光，而右边的茶壶就会被这些环境光照亮，也就是会反射这些光。 而这些环境光就是用纹理来表示的。同时我们认为环境光来自无穷远处，所以考虑环境光时我们只记录环境光的方向信息就行。</p><h4 id="Spherical-Environment-Map"><a href="#Spherical-Environment-Map" class="headerlink" title="Spherical Environment Map"></a>Spherical Environment Map</h4><p>如何将环境光用纹理表示？一种方法是将环境光记录在球体表面。</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/spherical_environment_map.png' width=600></div><p>但是这回导致一些问题。将球体展开为平面之后会产生扭曲(就像世界地图一样)。</p><h4 id="Cube-Map"><a href="#Cube-Map" class="headerlink" title="Cube Map"></a>Cube Map</h4><p>为了解决这个问题，我们可以将环境光投影在立方体表面上，最后展开之后得到6个没有扭曲的面</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/cube_map.png' width=600></div><h3 id="Bump-Mapping"><a href="#Bump-Mapping" class="headerlink" title="Bump Mapping"></a>Bump Mapping</h3><p>纹理还可以来定义一个物体表面的高度起伏(或是法线方向)，这样就能影响表面的着色结果，让人看起来表面有起伏。做凹凸贴图是因为这样可以用不太复杂的三角形来描述出图形基本轮廓，而复杂的表面则用纹理解决。</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/bump_texture.png' width=600></div><p>假如是有了高度情况求法线，假设表示高度的函数为 $h(u,v)$</p><script type="math/tex; mode=display">\begin{aligned}\frac{\mathrm{d}p}{\mathrm{d}u}=c_1\cdot [h(u+1)-h(u)] \\\frac{\mathrm{d}p}{\mathrm{d}v}=c_2\cdot [h(v+1)-h(v)]\end{aligned}</script><p>法线为</p><script type="math/tex; mode=display">\vec{n}=\left\| (-\frac{\mathrm{d}p}{\mathrm{d}u},-\frac{\mathrm{d}p}{\mathrm{d}v},1) \right\|_{}</script><p>但由于凹凸贴图没有真正的改变表面的位置，因此效果会比位移贴图(真正将表面位置移动)差一些</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/bump_vs_displacement.png' width=400></div><h3 id="3D-Textures-and-Volume-Rendering"><a href="#3D-Textures-and-Volume-Rendering" class="headerlink" title="3D Textures and Volume Rendering"></a>3D Textures and Volume Rendering</h3><p>纹理不仅仅是贴在表面的二维图形，同时还可以是三维的，用来描述空间中一点的信息</p><div align=center><img src='../../figure/计算机图形学笔记/9-Shading-Texture-Mapping-cont/3d_texture.png' width=500></div>]]></content>
      
      
      <categories>
          
          <category> computer graphics notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>山地车shimano套件</title>
      <link href="/posts/e51f1f85.html"/>
      <url>/posts/e51f1f85.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>参考文章：<a href="https://www.biketo.com/product/45247.html">文章1</a>，<a href="https://www.zhihu.com/tardis/zm/art/507937060?source_id=1003">文章2</a>和<a href="https://bike.shimano.com/zh-CN/home.html">禧玛诺官网</a></p></div><h2 id="山地车零件"><a href="#山地车零件" class="headerlink" title="山地车零件"></a>山地车零件</h2><p>SHIMANO生产的零件主要有：指拨、前拨、后拨、牙盘、中轴、飞轮、链条、刹车、花鼓。下面是各自缩写：</p><ul><li>SL指拨：Shimano Lever</li><li>ST双控：Shimano Total Integration</li><li>FC牙盘：Front Chainwheel</li><li>RD后拨：Rear Derailleur</li><li>FD前拨：Front Derailleur</li><li>CS飞轮：Cassette Sprocket</li><li>HB/FH前后花鼓：Hub/Freewheel</li><li>BR刹车（包括线刹和油碟）：Brake (including cable and hydraulic disc brake)</li><li>BL刹车手柄（包括线刹和油碟）：Brake Lever (including cable and hydraulic disc brake)</li></ul><h2 id="山地车的分类"><a href="#山地车的分类" class="headerlink" title="山地车的分类"></a>山地车的分类</h2><ol><li>普通越野XC(Cross Country)<br>50%上坡、50%下坡：用于普通的山地越野，也是山地车中最轻便最实用的车型，因强度适中，可以追求轻量化。</li><li>双人竞速DS(Dual Slalom)<br>70%上坡、30%下坡：适合竞赛级的高强度越野，但造价过高，都在万元左右。</li><li>自由骑FR (Free Ride)<br>40%上坡、60%下坡：野地丛林里玩，也可以飞台阶，高强度要求，部分装备接近DH。</li><li>飞跃DJ (Dirt Jumping)<br>30%上坡、70%下坡：飞土包的车，腾越空中，需要很重的高强度车架，不便宜。</li><li>速降DH (Down Hill)<br>0%上坡、100%下坡：从山顶以60公里/时的速度冲下，拥有巨长的双肩前，超高强度要求，一般造价在3-5万元左右，重心后移，不适合爬坡；又因重量过重，不适合一般的骑行越野。</li></ol><h2 id="禧玛诺套件种类"><a href="#禧玛诺套件种类" class="headerlink" title="禧玛诺套件种类"></a>禧玛诺套件种类</h2><p>禧玛诺套件级别从高到低排名依次是（按产品定位、性能和价格从高到低排列）：<br>XTR、DEORE XT、SLX、DEORE LX、DEORE、ALIVIO、ACERA、ALTUS、TOURNEY、TourneyTZ、SIS、MF等</p><h3 id="XTR"><a href="#XTR" class="headerlink" title="XTR"></a>XTR</h3><p>是最顶级的竞赛用零件，XTR为了追求极至轻量，使用了较多轻量材质，追求的是极至的轻量和精准，价格同样也是“顶级”的。</p><h4 id="M9100"><a href="#M9100" class="headerlink" title="M9100"></a>M9100</h4><p>禧玛诺的山地顶级套件，分为XC和Enduro</p><ul><li>曲柄：这两款曲柄都采用了HOLLOWTECH II中空曲柄技术，并取消了之前一直沿用的一体盘爪设计，改用了直装盘片设计</li><li>盘片：单盘曲柄的盘片目前有30-38T可供车友选择。Enduro 车手则可选装 XTR 护链装置来搭配 1×12 速的搭配，保证链条稳定工作状态。同样，新款的盘片还提供更宽 Q-Factor 规格的 FC-M9120，兼容各种车架规格。</li><li>飞轮：新款的51T飞轮在齿比上经过了严谨的优化，最后三片飞轮片的齿差都在 6T，爬坡变速更加细腻顺滑。飞轮主体由三种材料制成，后几片飞轮采用了铝合金打造而成，中间几片则为钛合金材质，最后最小的几片飞轮则使用的是钢材料。除51T飞轮外，XTR 同时还有一款12速的10-45T飞轮，适用于较少陡坡或骑行节奏变化不大的路段，和双盘曲柄搭配效果更佳。</li><li>链条：新链条具有 QUICK-LINK快扣并进行了 SIL-TEC 处理，增强了越野耐用性。</li><li>后拨：有三款规格可选，分别是RD-M9100-SGS/GS长腿后拨和短腿后拨，还有另一款针对双盘设计的 RD-M9120-SGS 长腿后拨。为了更好的匹配12速系统，导轮从原来 M9000 的11T变为了现在的13T，再加上成熟的 Shimano 隐藏式技术，能够减少链条的弹跳，带来更好的稳定性。</li><li>直拨：指拨拥有I-SPE EV 整合技术，能够实现指拨与刹把、升降座管器等附件完美整合。超广调节范围是这款指拨的一大优点，拥有14mm 的拨杆横向拨动范围，同时还能让变速手柄在 60°的范围内调整位置。和上一代M9000指拨一样，M9100指拨同样带有即时释放（Rapidfire Plus）、双重释放（2-WAY RELEASE）和多重释放（Multi-Release）功能，如果你选择了双盘版本的XTR套件，左指拨新添的Mono技术能让操作变得更加简单和直接，只需要一个拨杆就可以实现大小盘的切换。</li></ul><h3 id="Deore-XT"><a href="#Deore-XT" class="headerlink" title="Deore XT"></a>Deore XT</h3><p>是次顶级的系列，DEORE XT和XTR一样精准好用，但重量相对XTR稍重。XT中有更多金属材质，相对更耐用。</p><h4 id="M8100"><a href="#M8100" class="headerlink" title="M8100"></a>M8100</h4><p>这款套件可以选择不同的搭配，系列涵盖 12速10-45T和10-51T MICRO SPLINE两款卡式飞轮，两款1x12或2x12 HOLLOWTECH II曲柄组，强劲的双活塞或四活塞碟刹，位置可调的ISPEC-EV变速手柄，12速高精度前后变速器，ICE TECHNOLOGIES FREEZA碟刹盘片与全套越野和耐力赛轮组</p><ul><li>牙盘：这两款单盘和双盘曲柄都采用HOLLOWTECH II中空技术和一体化轴心设计，单盘盘片有28T、30T、32T、34T和36T五种可选，均为Dynamic Chain Engagement+齿形，在防掉链的同时，也能保证链条运行的平稳和安静。双盘曲柄共有两个型号可选，均利用双螺钉系统把左侧曲柄固定在中轴轴芯上。FC-M8100-2曲柄采用142mm O.L.D.链条中心线为48.8mm和Q值172mm；FC-M8120-B2 曲柄以采用148mm O.L.D.搭配51.8mm链条中心线和178mmQ值。</li><li>飞轮：MICRO SPLINE塔基技术从M9100下放到了新款XT套件上，有10-45T紧凑型和10-51T“爬墙型”两款飞轮可供选择。这两款飞轮都具有HYPERGLIDE+功能，能在变速安静的前提下，与直拨完美配合，实现顺畅快速的多段换挡。12块飞轮片中有10片为钢材质，2片为铝材质。</li><li>链条：新款HG链条经过全新设计，拓宽了内侧链片，让链条和飞轮的啮合性大大提高。内链节采用了镀铬设计以提高耐用度。</li><li>后拨：为了适应不同曲柄，这款后拨有单盘（RD-M8100-SGS）和双盘（RD-M8120-SGS）两种型号可选，拥有禧玛诺 SHADOW RD+锁定功能，并配有缓冲垫块和13T导轮，可以在超大齿比范围内实现精准而快速地换挡。</li><li>前拨：目前新款XT的前拨只提供一种规格，能够兼容兼容48.8mm和51.8mm链条中心线，供应D型，E型或M型安装座</li><li>指拨：新款指拨取消了之前XT那标志性的银拨杆，取而代之是一个拥有防滑橡胶垫片的低调黑色拨杆。这款ISPEC-EV 变速手柄拥有横向调节和纵向旋转调节功能，同时能够于禧玛诺的刹车系统完美整合，在观感上更加干净整洁。</li></ul><h3 id="SLX"><a href="#SLX" class="headerlink" title="SLX"></a>SLX</h3><p>SLX介于Deore XT与Deore LX之间。</p><h4 id="M7100"><a href="#M7100" class="headerlink" title="M7100"></a>M7100</h4><p>同XT套件一样，新款的SLX套件也拥有丰富的选项，包括两款MICRO SPLINE塔基飞轮，单盘和双盘曲柄，SLX级12速专用链条、双活塞或四活塞刹车、完全可调的ISPEC-EV变速指拨、优化的前后变速器和12速花鼓。</p><ul><li>曲柄：新款的SLX单盘曲柄照常使用了禧玛诺家“祖传”的Dynamic Chain Engagement+齿形。与XT相比，SLX单盘曲柄在盘片和曲柄长度的选项上就少了一些，盘片有30、32、34T可供选择，当然禧玛诺的盘片都可以互换使用，这个完全不受影响，而曲柄只有165mm、170mm和175mm三个选项。双盘曲柄组共有两个型号可选，均采用双螺钉系统把左侧曲柄固定在中轴轴芯上。FC-M7100-2曲柄与DEORE XT非常相似，链条中心线为48.8mm和Q值172mm；FC-M7120-B2曲柄采用148mm O.L.D.搭配51.8mm的链条中心线和178mmQ值。</li><li>飞轮：SLX飞轮组由11片钢飞轮和1片铝飞轮组成。在其它细节上两款飞轮并无太大区别，都有10-45T和10-51T两款可供选择，拥有HYPERGLIDE+功能，即能实现迅速的双向换挡，又能使传动系统极其安静</li><li>链条：新款SLX的HG链条经过全新设计，拓宽了内侧链片，让链条和飞轮的啮合性大大提高。并配有SIL-TEC内链接，运行更加顺畅，在各种路况下的耐用性更高。</li><li>后拨：SLX后拨有单盘（RD-M7100-SGS）和双盘（RD-M7120-SGS）两款可供选择，即使在12速的超大齿比范围内，也能够实现精确而快速地换挡。这两个拨链器都采用禧玛诺SHADOW RD+（影子后拨），并配有缓冲垫块和13T导轮</li><li>前拨：SLX前拨链器仅有一种规格，兼容48.8mm和51.8mm的链条中心线，供应D型、E型或M型安装座。</li><li>指拨：SLX的塑料的拨杆设计依然是一个不小的槽点，防滑设计上也没有XT那么精致。ISPEC-EV的指拨版本同样拥有拥有横向调节和纵向旋转调节功能，能够与禧玛诺刹车完美整合，虽然调节角度没有XTR那样宽泛，但还是十分够用的。</li></ul><h3 id="Deore"><a href="#Deore" class="headerlink" title="Deore"></a>Deore</h3><p>更为经济的选择，性能较竞赛级XTR、DEORE XT稍逊色，但是仍然在较高水准之上，都是高档整车的常用配件，这两档产品同样亦十分耐用。Deore及以上（XTR、DEORE XT、DEORE）都属于高级别配件，都足以应付真正的山地越野活动。</p><h4 id="M6100"><a href="#M6100" class="headerlink" title="M6100"></a>M6100</h4><ul><li>牙盘：目前M6100套件只提供单盘曲柄版本，没有中空曲柄技术，不过盘片依然拥有DYNAMIC CHAIN ENGAGEMENT+技术，有30T和32T可供选择。曲柄可选择170毫米或175毫米长度，还能选择172mm（搭配142/148mm 车架锁紧螺母间距）、178mm（搭配148mm车架锁紧螺母间距）、及181mm（搭配157mm车架锁紧螺母间距）三种不同Q值版本。</li><li>飞轮：M6100的飞轮也采用新型的MICROSPLINE技术。目前这款飞轮只有10-51T规格可选择，12片飞轮片均采用坚固耐用的钢材制成，拥有HYPERGLIDE+技术，换挡更加迅速流畅。</li><li>链条：DEORE 12速HG链条（CN-M6100）能与DYNAMIC CHAIN ENGAGEMENT+技术完美配合。</li><li>链条：后拨（RD-M6100-SGS）在外观和技术上与其它大哥并无区别，拥有13T导轮和SHADOW RD+技术，链条张力也相较前几代更强，能有效减少链条抖动。</li><li>指拨：禧玛诺在M6100上额外提供了一款视窗指拨版本。指拨采用与XTR、DEORE XT 及 SLX产品相同的I-SPEC EV技术，拥有14毫米横向及纵向10度调整范围</li></ul><h4 id="M5100（11速）及-M4100（10速）"><a href="#M5100（11速）及-M4100（10速）" class="headerlink" title="M5100（11速）及 M4100（10速）"></a>M5100（11速）及 M4100（10速）</h4><ul><li>牙盘：10/11速系列有单盘规格（1x11 或1x10），也有双盘规格（2x11 或 2x10）</li><li>后拨：这款11速后拨（RD-M5100-SGS）与12速后拨外观上并无太大区别。11速后拨拥有SHADOW RD+技术，专为1x11传动及链条设计，能够支持最大51T飞轮。另一款RD-M5120-SGS后拨也拥有相同的SHADOW RD+技术，可兼容2X11/10速11-42T飞轮和1x10速11-46T的飞轮。价格更低廉的M4120-SGS后拨也能用于2x11速或2x 10速传动，但没有链条稳定技术。</li><li>前拨：新款的11速前拨（FD-M5100/M4100）能够支持更大的轮胎间隙。两种型号都具备多种安装位置（D、E或M）以适应不同车架设计。</li><li>指拨：11/10速指拨也都拥有I-SPEC EV技术，能够更方便地与刹车或升降座管。也有夹环版本可以选择。</li></ul><!-- ## 中级适合山地越野的中级配件：XC（越野山地车）的进阶ALTUS、Acera、Alivio --><h3 id="Saint、Zee、Cues"><a href="#Saint、Zee、Cues" class="headerlink" title="Saint、Zee、Cues"></a>Saint、Zee、Cues</h3><h4 id="SAINT-M820"><a href="#SAINT-M820" class="headerlink" title="SAINT M820"></a>SAINT M820</h4><p>适用于DH和FR</p><p>带有 SHIMANO SHADOW RD+（隐藏式后拨）和减震装置始终如一、强大、灵敏的 ICE TECHNOLOGIES（散热技术）刹车带散热片的碟刹盘片</p><h4 id="ZEE-M640"><a href="#ZEE-M640" class="headerlink" title="ZEE M640"></a>ZEE M640</h4><p>适用重型XC和AM</p><p>支持山地路径的高强度骑行。可以应对最不可思议的速降骑行。如果您是重型越野赛的新手，ZEE 是您的最佳选择。</p><p>提供高刚性，高耐久度的曲柄组操作稳定，无噪音，带有短导板的SHIMANO SHADOW RD+（隐藏式后拨）强劲，可轻松配备油压碟刹</p><h4 id="CUES-U6000"><a href="#CUES-U6000" class="headerlink" title="CUES U6000"></a>CUES U6000</h4><p>适合高强度的林道骑行以及日常运动骑行。</p><h3 id="Alivio、Acera"><a href="#Alivio、Acera" class="headerlink" title="Alivio、Acera"></a>Alivio、Acera</h3><p>山地运动入门级配件，可以对应强度不高的山地运动、娱乐。</p><h4 id="ALIVIO-M3100"><a href="#ALIVIO-M3100" class="headerlink" title="ALIVIO M3100"></a>ALIVIO M3100</h4><p>目前ALIVIO套件只提供九速版本，主打耐用性和可靠性，对于休闲代步的车友而言，这款套件也是一个不错的选择。</p><ul><li>牙盘:全新款的ALIVIO套件只提供双盘和三盘曲柄组，暂不支持1X系统。曲柄主体采用阳极电镀喷涂，坚固的SG-X盘片能带来精确可靠的变速体验，双盘曲柄的齿比搭配为36-22T，三盘曲柄则有两种齿比搭配可供选择（44-32-22T和40-30-22T）。两款曲柄都有护盘版本。</li><li>飞轮：九速飞轮拥有银色的防锈处理涂层，齿比搭配非常成熟</li><li>后拨：新款ALIVIO的后拨依旧延续了禧玛诺“细细长长”的风格。这款后拨拥有SHADOW影子技术，能够兼容最大36T的飞轮。</li><li>链条：HG-53 链条专为 9-速传动系统打造，采用超窄 HG 技术和精准的构造。</li><li>前拨：为了适应大轮径和短后叉的山地车设计，新款的前拨采用SHIMANO全新SIDE SWING技术，以提高拉线效率，让变速更为轻松快捷。这款前拨支持D、E或M的安装位置，不过在M型车架上，需要使用特殊的转接座。</li><li>指拨：新款的ALIVIO指拨没有使用整合技术，只提供了最基础的夹环版本。有小视窗。</li></ul><h4 id="ACERA-M3000"><a href="#ACERA-M3000" class="headerlink" title="ACERA M3000"></a>ACERA M3000</h4><h3 id="ALTUS"><a href="#ALTUS" class="headerlink" title="ALTUS"></a>ALTUS</h3><p>入门级别配件，可应对城市通勤娱乐或是轻度山野，但切忌不能挑战过于“刺激”的路况。</p><h4 id="M2000"><a href="#M2000" class="headerlink" title="M2000"></a>M2000</h4>]]></content>
      
      
      <categories>
          
          <category> 自行车 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 套件 </tag>
            
            <tag> Shimano </tag>
            
            <tag> 山地车 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自行车各品牌官网</title>
      <link href="/posts/f192018a.html"/>
      <url>/posts/f192018a.html</url>
      
        <content type="html"><![CDATA[<h2 id="捷安特-Giant"><a href="#捷安特-Giant" class="headerlink" title="捷安特(Giant)"></a>捷安特(Giant)</h2><p><a href="https://www.giant.com.cn/index.php/index/index.html">https://www.giant.com.cn/index.php/index/index.html</a></p><ul><li>官网会给出每种车型的各个配件规格，但是没有给出具体的型号配置。</li><li>会给出车架详细的几何</li><li>会给出价格</li></ul><h2 id="美利达-Merida"><a href="#美利达-Merida" class="headerlink" title="美利达(Merida)"></a>美利达(Merida)</h2><p><a href="https://www.merida-bikes.com/zh-tw">https://www.merida-bikes.com/zh-tw</a></p><ul><li>没有给出价格</li><li>有每个零件的型号</li><li>会给出详细的几何</li></ul><h2 id="迪卡侬-decathlon"><a href="#迪卡侬-decathlon" class="headerlink" title="迪卡侬(decathlon)"></a>迪卡侬(decathlon)</h2><p><a href="https://www.decathlon.com.cn/zh/">https://www.decathlon.com.cn/zh/</a> (网站里除了自行车还会卖很多其他东西)</p><ul><li>会给出价格</li><li>有零件的型号</li><li>没有专门给出几何图，但是有些数据会在零件里提到</li><li>会给出车重</li><li>还会建议你买一大堆其他装备</li><li>有其他用户的评价</li></ul><h2 id="佳能戴尔-cannondale"><a href="#佳能戴尔-cannondale" class="headerlink" title="佳能戴尔(cannondale)"></a>佳能戴尔(cannondale)</h2><p><a href="https://www.cannondale.com/en-us">https://www.cannondale.com/en-us</a></p><ul><li>会给出价格</li><li>有零件的型号</li><li>几何图大部分都有，有些没有</li><li>部分有车重</li><li>有其他用户的评价</li></ul><h2 id="坎普-camp"><a href="#坎普-camp" class="headerlink" title="坎普(camp)"></a>坎普(camp)</h2><p><a href="http://www.campbicycle.com/">http://www.campbicycle.com/</a></p><ul><li>没有给出价格(可以在线询价)</li><li>有零件的型号</li><li>有几何图</li><li>部分有车重</li></ul><h2 id="喜德盛-xds"><a href="#喜德盛-xds" class="headerlink" title="喜德盛(xds)"></a>喜德盛(xds)</h2><p><a href="http://www.xidesheng.com/index.html">http://www.xidesheng.com/index.html</a> </p><p>网站加载好慢。。。</p><h2 id="峰大-mosso"><a href="#峰大-mosso" class="headerlink" title="峰大(mosso)"></a>峰大(mosso)</h2><p><a href="http://www.mosso.com.tw/">http://www.mosso.com.tw/</a> (有卖整车，也单卖车架、前叉、轮组)</p><ul><li>没有价格</li><li>有零件的型号(整车用的基本是CP套件)</li><li>有几何图</li></ul><h2 id="中国龙-ZGL"><a href="#中国龙-ZGL" class="headerlink" title="中国龙(ZGL)"></a>中国龙(ZGL)</h2><p><a href="http://www.zglbike.com/">http://www.zglbike.com/</a> (卖各种碳纤维产品，车架只是其中一部分)</p><ul><li>没有价格</li><li>有几何图</li></ul><h2 id="瑞豹-pardus"><a href="#瑞豹-pardus" class="headerlink" title="瑞豹(pardus)"></a>瑞豹(pardus)</h2><p><a href="https://www.parduscycle.com/">https://www.parduscycle.com/</a></p><ul><li>有价格</li><li>有零件型号</li><li>有几何图</li></ul>]]></content>
      
      
      <categories>
          
          <category> 自行车 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Rasterization</title>
      <link href="/posts/178d1853.html"/>
      <url>/posts/178d1853.html</url>
      
        <content type="html"><![CDATA[<h2 id="Canonical-Cube-to-Screen"><a href="#Canonical-Cube-to-Screen" class="headerlink" title="Canonical Cube to Screen"></a>Canonical Cube to Screen</h2><p>什么是屏幕？</p><ul><li>像素组成的数组</li><li>数组的大小：分辨率</li><li>典型的光栅成像设备</li></ul><p>光栅(Raster)=屏幕(德语)</p><ul><li>光栅化(Rasterize)=把东西画在屏幕上</li></ul><p>像素(Pixel, short for “picture elment”)</p><ul><li>这里暂时认为像素是只有一种颜色的方块</li><li>颜色是RGB的组合</li></ul><p>屏幕的空间如图所示，</p><div align=center><img src='../../figure/计算机图形学笔记/5-Rasterization-Triangles/screen_space.png' width=500></div><ul><li>我们认为左下角为原点，像素的坐标用整数 $(x,y)$ 表示</li><li>像素的范围从 $(0,0)$ 到 $(width-1,height-1)$</li><li>像素的中心位于 $(x+0.5,y+0.5)$</li><li>屏幕覆盖的范围从 $(0,0)$ 到 $(width,height)$</li></ul><p>现在希望把三维的立方体映射到屏幕上。现在暂时先不管 $z$；对于 $xy$ 平面，需要让立方体映射到整个屏幕，即 $[-1,1]^{2}\to [0,width]\times  [0,height]$，则矩阵为</p><script type="math/tex; mode=display">M_{viewpoint}=\begin{pmatrix}     \frac{width}{2} & 0 &0 & \frac{width}{2} \\    0 & \frac{height}{2} & 0 & \frac{height}{2} \\    0 & 0& 1 &0 \\    0 & 0 & 0 & 1\end{pmatrix}</script><p>做完变换之后，现在已经能得到一个二维场景了，那么下一步则是将这个结果打散成像素(光栅化)。</p><h2 id="Different-Raster-Displays"><a href="#Different-Raster-Displays" class="headerlink" title="Different Raster Displays"></a>Different Raster Displays</h2><ul><li>示波器(Oscilloscope)</li><li>阴极射线管(Cathode Ray Tube)，早期电视的原理</li><li>Frame Buffer: Memory for a Raster Display</li><li>Flat Panel Displays</li><li>液晶显示器(LCD: Liquid Crystal Display)</li><li>发光二极管(LED: Light emitting diode array)</li><li>墨水屏</li></ul><h3 id="LCD-Liquid-Crystal-Display-Pixel"><a href="#LCD-Liquid-Crystal-Display-Pixel" class="headerlink" title="LCD (Liquid Crystal Display) Pixel"></a>LCD (Liquid Crystal Display) Pixel</h3><p>液晶显示器</p><p>原理：两个偏振方向相互垂直的偏振片，而液晶改变光的偏振方向。如图</p><div align=center><img src='../../figure/计算机图形学笔记/5-Rasterization-Triangles/lcd.png' width=400></div><h2 id="Drawing-to-Raster-Displays"><a href="#Drawing-to-Raster-Displays" class="headerlink" title="Drawing to Raster Displays"></a>Drawing to Raster Displays</h2><h3 id="Triangles-Fundamental-Shape-Primitives"><a href="#Triangles-Fundamental-Shape-Primitives" class="headerlink" title="Triangles - Fundamental Shape Primitives"></a>Triangles - Fundamental Shape Primitives</h3><p>一般的图形都看成是三角形的组合</p><p>三角形的特殊性质：</p><ul><li>三个点一定在同一平面</li><li>有“内部”</li><li>能较好的用于描述渐变</li></ul><h3 id="What-Pixel-Values-Approximate-a-Triangle"><a href="#What-Pixel-Values-Approximate-a-Triangle" class="headerlink" title="What Pixel Values Approximate a Triangle?"></a>What Pixel Values Approximate a Triangle?</h3><p>如何把三角形变成像素? 可以通过采样的方法</p><h3 id="A-Simple-Approach-Sampling"><a href="#A-Simple-Approach-Sampling" class="headerlink" title="A Simple Approach: Sampling"></a>A Simple Approach: Sampling</h3><p>采样相当于把函数离散化。例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; x_max ; ++x )</span><br><span class="line">    output [x] = f(x)</span><br></pre></td></tr></table></figure></p><p>在图形学中，我们用像素中心采样。</p><div align=center><img src='../../figure/计算机图形学笔记/5-Rasterization-Triangles/2d_sampling.png' width=400></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; xmax; ++x)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; ymax; ++y)</span><br><span class="line">        image[x][y] = inside(tri , x + <span class="number">0.5</span> , y + <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><p>而 <code>inside()</code> 函数(判断点是否在三角形内)可以用叉积实现。如果点正好落在三角形边上，自己处理就行。</p><p>同时光栅化不用扫描整个屏幕，可以使用如图所示包围盒(Bounding Box)考虑</p><div align=center><img src='../../figure/计算机图形学笔记/5-Rasterization-Triangles/bounding_box.png' width=400></div><p>因为白色区域肯定不会在三角形中，因此不考虑。</p><p>或者也可以通过检测旁边像素的方法来加速光栅化。</p><h2 id="Antialiasing"><a href="#Antialiasing" class="headerlink" title="Antialiasing"></a>Antialiasing</h2><p>通过采样获得的图形会有锯齿(Aliasing)，需要想办法解决这个问题。</p><h3 id="Sampling-theory"><a href="#Sampling-theory" class="headerlink" title="Sampling theory"></a>Sampling theory</h3><h4 id="Sampling-is-Ubiquitous-in-Computer-Graphics"><a href="#Sampling-is-Ubiquitous-in-Computer-Graphics" class="headerlink" title="Sampling is Ubiquitous in Computer Graphics"></a>Sampling is Ubiquitous in Computer Graphics</h4><p>采样在图形学中无处不在。</p><ul><li>光栅化是在二维图像上采样</li><li>照相是在感光元件上采样</li><li>视频是对时间的采样</li></ul><h4 id="Sampling-Artifacts-Errors-Mistakes-Inaccuracies-in-Computer-Graphics"><a href="#Sampling-Artifacts-Errors-Mistakes-Inaccuracies-in-Computer-Graphics" class="headerlink" title="Sampling Artifacts(Errors / Mistakes / Inaccuracies) in Computer Graphics"></a>Sampling Artifacts(Errors / Mistakes / Inaccuracies) in Computer Graphics</h4><ul><li>会产生锯齿(Jaggies)——在空间中采样</li><li>可能产生摩尔纹(Moire)——图片采样率不足</li><li>轮子倒转的幻觉(Wagon wheel effect)——时间上的采样</li></ul><p>Sampling Artifacts的原因：信号变化太快但是采样跟不上。</p><h3 id="Antialiasing-in-practice"><a href="#Antialiasing-in-practice" class="headerlink" title="Antialiasing in practice"></a>Antialiasing in practice</h3><h4 id="Antialiasing-Idea-Blurring-Pre-Filtering-Before-Sampling"><a href="#Antialiasing-Idea-Blurring-Pre-Filtering-Before-Sampling" class="headerlink" title="Antialiasing Idea: Blurring (Pre-Filtering) Before Sampling"></a>Antialiasing Idea: Blurring (Pre-Filtering) Before Sampling</h4><p>模糊化(采样前滤波)</p><p>直接采样：</p><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/sample.png' width=600></div><p>先模糊处理后再采样</p><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/pre_filter_sample.png' width=600></div><p>但是先采样再做模糊处理是达不到预想效果的。</p><h2 id="Frequency-Domain"><a href="#Frequency-Domain" class="headerlink" title="Frequency Domain"></a>Frequency Domain</h2><p>傅里叶级数展开：将函数展开为正弦函数之和。</p><p>由傅里叶展开可以引出傅里叶变换</p><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/fourier_transform.png' width=600></div><p>将空间表象中对函数的描述转化为频率表象中对函数的描述。</p><p>用同一频率采样不同频率的函数：</p><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/higher_frequenies_faster_sampling.png' width=600></div><p>可以看出采样频率相同时，如果函数的频率过大，那么采样将会丢失很多信息。同时过低的采样频率可能会导致两个频率截然不同的函数被采样之后得到完全相同的结果：</p><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/undersampling.png' width=600></div><p>这种情况称其为 aliases</p><h3 id="Filtering-Getting-rid-of-certain-frequency-contents"><a href="#Filtering-Getting-rid-of-certain-frequency-contents" class="headerlink" title="Filtering = Getting rid of certain frequency contents"></a>Filtering = Getting rid of certain frequency contents</h3><p>滤波，就是去掉某些特定的频率</p><p>对图像做傅里叶变换，将其从时域转化为频域。对于表示频域的图像，我们认为中心为最低频的区域，外侧为高频区域，亮度表示不同位置处的信息。如下图所示，左边的图片经过傅里叶变换之后变成右边</p><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/frequency_content.png' width=600></div><p>可以发现低频信息较多，高频信息较少(大多数图都这样)。至于图中的横线和竖线，这是原图的边界导致。</p><p>如果对频域图像做高通滤波，过滤低频信号，再做傅里叶逆变换变回原图，则得到如图情形</p><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/high_pass_filter.png' width=600></div><p>可以看出保留的为原图的内部的边界。这是因为边界处图像变化特别剧烈，因此为高频信息。</p><p>如果做低通滤波，过滤高频信号，这就是做模糊化(Blur)</p><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/low_pass_filter.png' width=600></div><p>如果同时过滤最高频和最低频的信号，会得到结果如下</p><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/mid_pass_filter.png' width=600></div><p>那么可以看出得到的是一些没那么明显的边界特征</p><h3 id="Filtering-Convolution-Averaging"><a href="#Filtering-Convolution-Averaging" class="headerlink" title="Filtering = Convolution(= Averaging)"></a>Filtering = Convolution(= Averaging)</h3><p>对时域上对两个信号做卷积，相当于在频域上对两个信号做乘积。反之亦然。</p><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/convolution_theorem.png' width=600></div><p>同时对于卷积操作来说，卷积核在时域上越大，那么在频域中就越小。(可以理解为卷积核如果很大，那么相当于会把整张图片弄得很模糊，也就是去掉了所有高频信息，这说明在频域中应该很小)</p><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/samll_box.png' width=600></div><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/large_box.png' width=600></div><h3 id="Sampling-Repeating-Frequency-Contents"><a href="#Sampling-Repeating-Frequency-Contents" class="headerlink" title="Sampling = Repeating Frequency Contents"></a>Sampling = Repeating Frequency Contents</h3><p>对信号做采样，就相当于让信号乘以一系列的冲激函数。而在频域中，就相当于让函数与一系列冲激函数做卷积，最终得到的结果就是频域中的函数被重复。</p><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/repeating_frequency_content.png' width=600></div><p>如果在时域中采样频率过低，那么在频域中冲激函数的间隔就会比较小，最终就会导致频域中的函数重叠。而如果对图像进行模糊处理，相当于截掉了高频部分，那么就能避免重叠。</p><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/mix_frequency_contents.png' width=600></div><h2 id="Antialiasing-with-frequency-fundamental"><a href="#Antialiasing-with-frequency-fundamental" class="headerlink" title="Antialiasing (with frequency fundamental)"></a>Antialiasing (with frequency fundamental)</h2><p>如何反走样？</p><ul><li>提高分辨率</li><li>先模糊(消除高频信号)，后采样</li></ul><p>如何选择滤波器？最简单的方式就是将一个像素作为滤波的块(1 pixel-width box filter)。如果使用该滤波器，那么各个像素经过滤波之后得到的结果如图：</p><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/pixel_filter.png' width=600></div><h3 id="Antialiasing-By-Supersampling-MSAA"><a href="#Antialiasing-By-Supersampling-MSAA" class="headerlink" title="Antialiasing By Supersampling (MSAA)"></a>Antialiasing By Supersampling (MSAA)</h3><p>事实上准确的算出三角形在每个像素中覆盖的面积并不容易，因此需要引入某些近似操作。</p><h4 id="Supersampling"><a href="#Supersampling" class="headerlink" title="Supersampling"></a>Supersampling</h4><p>将一个像素划分为很多更小的像素，比如在下图中将每个像素划分为4个块。而每个像素的近似覆盖率可以用在三角形中的更小的像素数来表示。</p><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/super_sampling.png' width=600></div><p>最后得到结果如图：</p><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/super_sampling_result.png' width=600></div><h3 id="Antialiasing-Today"><a href="#Antialiasing-Today" class="headerlink" title="Antialiasing Today"></a>Antialiasing Today</h3><p>除了MSAA，还有很多其他的抗锯齿方法。其中比较典型的为：</p><ul><li>FXAA(Fast Approximate AA) 快速近似抗锯齿。先得到一个有锯齿的图，再找到锯齿位置，通过对图像的后期处理，消除锯齿。</li><li>TAA(Temporal AA) 与时间相关。同样是将每个像素分成很多小像素，但对于每一帧来说都只计算一个小像素是否在三角形中。通过复用前面几帧的结果，达到和MSAA同样的效果(但比较适用于静态情形)</li></ul><p>恢复图片分辨率(和抗锯齿过程相似)<br>DLSS(Deep Learning Super Sampling)，通过深度学习的方法，补全缺失的信息</p><h2 id="Visibility-occlusion"><a href="#Visibility-occlusion" class="headerlink" title="Visibility / occlusion"></a>Visibility / occlusion</h2><h3 id="Painter’s-Algorithm"><a href="#Painter’s-Algorithm" class="headerlink" title="Painter’s Algorithm"></a>Painter’s Algorithm</h3><p>从绘画中获得灵感，也就是先画远处的东西，再画近处的东西，近处的东西会覆盖远处的东西。该算法需要 $O(n\log n)$ 的时间，其中 $n$ 为三角形的个数，主要的工作量在排序上。画家算法在一定情况下是适用的，但是如下图情况不适用：</p><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/unresolvable_condition.png' width=300></div><p>因为我们无法简单地得到各个三角形间的深度关系。为了解决这个问题，我们引入深度缓冲(Z-buffer)</p><h3 id="Z-buffer"><a href="#Z-buffer" class="headerlink" title="Z-buffer"></a>Z-buffer</h3><p>既然对于每个三角形无法简单的得到远近关系，那么就直接考虑每个像素，记录在这个像素中最近的图形是哪个。</p><p>同时在这里为了简单起见，我们假设此时的 $z$ 是正的(与我们之前提到的viewing的方向不同)</p><p>在由模型生成图像时，我们要记录两组值：一组是颜色，另一组是深度。</p><h4 id="Z-Buffer-Example"><a href="#Z-Buffer-Example" class="headerlink" title="Z-Buffer Example"></a>Z-Buffer Example</h4><div align=center><img src='../../figure/计算机图形学笔记/6-Rasterization-Antialiasing-and-Z-Buffering/z-buffer_example.png' width=600></div><p>在上面这副图中，左边记录的就是颜色，而右边记录的是深度，颜色越深表示离得越近。</p><h4 id="Z-Buffer-Algorithm"><a href="#Z-Buffer-Algorithm" class="headerlink" title="Z-Buffer Algorithm"></a>Z-Buffer Algorithm</h4><p>把每个像素深度初始化为 $\infty$，在光栅化的过程中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (each triangle T)</span><br><span class="line">    <span class="keyword">for</span> (each sample (x,y,z) in T)</span><br><span class="line">        <span class="keyword">if</span> (z &lt; zbuffer[x,y])       <span class="comment">// closest sample so far</span></span><br><span class="line">        framebuffer[x,y] = rgb;     <span class="comment">// update color</span></span><br><span class="line">        zbuffer[x,y] = z;           <span class="comment">// update depth</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        ;               <span class="comment">// do nothing, this sample is occluded</span></span><br></pre></td></tr></table></figure></p><p>算法复杂度：$O(n)$，这里假设每个三角形遮挡的像素数为 $O(1)$。因为这里没有比较排序，因此更快。</p>]]></content>
      
      
      <categories>
          
          <category> computer graphics notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transformation</title>
      <link href="/posts/3fd6625d.html"/>
      <url>/posts/3fd6625d.html</url>
      
        <content type="html"><![CDATA[<h2 id="Why-study-transformation"><a href="#Why-study-transformation" class="headerlink" title="Why study transformation"></a>Why study transformation</h2><ul><li>modeling(模型变换)<ul><li>translation(如游戏中视野的移动)</li><li>rotation</li><li>scaling</li></ul></li><li>viewing(视图变换，将三维投影到二维)</li></ul><h2 id="2D-transformation"><a href="#2D-transformation" class="headerlink" title="2D transformation"></a>2D transformation</h2><h3 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h3><div align=center><img src='../../figure/计算机图形学笔记/3-Transformation/scale.png' width=500></div><p>Scale Transform: $x’=sx, y’=sy$</p><p>Scale Matrix: </p><script type="math/tex; mode=display">\begin{pmatrix}     x'\\ y' \end{pmatrix} =\begin{pmatrix}     s & 0 \\ 0 & s \end{pmatrix} \begin{pmatrix}     x \\ y \end{pmatrix}</script><p>Scale(Non-Uniform)</p><script type="math/tex; mode=display">\begin{pmatrix}     x'\\ y' \end{pmatrix} =\begin{pmatrix}     s_{x} & 0 \\ 0 & s_y \end{pmatrix} \begin{pmatrix}     x \\ y \end{pmatrix}</script><h3 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h3><div align=center><img src='../../figure/计算机图形学笔记/3-Transformation/reflection.png' width=500></div><script type="math/tex; mode=display">\begin{pmatrix}     x'\\ y' \end{pmatrix} =\begin{pmatrix}     -1 & 0 \\ 0 & 1 \end{pmatrix} \begin{pmatrix}     x \\ y \end{pmatrix}</script><h3 id="Shear"><a href="#Shear" class="headerlink" title="Shear"></a>Shear</h3><div align=center><img src='../../figure/计算机图形学笔记/3-Transformation/shear.png' width=500></div><script type="math/tex; mode=display">\begin{pmatrix}     x'\\ y' \end{pmatrix} =\begin{pmatrix}     1 & a \\ 0 & 1 \end{pmatrix} \begin{pmatrix}     x \\ y \end{pmatrix}</script><h3 id="Rotate"><a href="#Rotate" class="headerlink" title="Rotate"></a>Rotate</h3><div align=center><img src='../../figure/计算机图形学笔记/3-Transformation/rotation.png' width=500></div><script type="math/tex; mode=display">\begin{pmatrix}     x' \\ y' \end{pmatrix}=\begin{pmatrix}     \cos \theta \\ \sin  \theta \end{pmatrix}  x + \begin{pmatrix}     -\sin  \theta \\ \cos \theta \end{pmatrix} y</script><script type="math/tex; mode=display">\Rightarrow \begin{pmatrix}     x'\\ y' \end{pmatrix} =\begin{pmatrix}     \cos \theta & -\sin \theta \\ \sin \theta & \cos \theta \end{pmatrix} \begin{pmatrix}     x \\ y \end{pmatrix}</script><h3 id="Linear-Transforms-Martices"><a href="#Linear-Transforms-Martices" class="headerlink" title="Linear Transforms = Martices"></a>Linear Transforms = Martices</h3><script type="math/tex; mode=display">\begin{pmatrix}     x'\\ y' \end{pmatrix} =\begin{pmatrix}     a & b \\ c & d \end{pmatrix} \begin{pmatrix}     x \\ y \end{pmatrix} \Rightarrow \bm{x'}=\bm{M}\bm{x}</script><h2 id="Homogeneous-coordinates"><a href="#Homogeneous-coordinates" class="headerlink" title="Homogeneous coordinates"></a>Homogeneous coordinates</h2><h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><div align=center><img src='../../figure/计算机图形学笔记/3-Transformation/translation.png' width=500></div><h3 id="Why-Homogeneous-Coordinates"><a href="#Why-Homogeneous-Coordinates" class="headerlink" title="Why Homogeneous Coordinates"></a>Why Homogeneous Coordinates</h3><p>Translation cannot be represented in matrix form, translation is not linear transform.</p><script type="math/tex; mode=display">\begin{pmatrix}     x'\\ y' \end{pmatrix} =\begin{pmatrix}     a & b \\ c & d \end{pmatrix} \begin{pmatrix}     x \\ y \end{pmatrix}+\begin{pmatrix}     t_{x} \\ t_y\end{pmatrix}</script><p>But we don’t want translation to be a special case.</p><h3 id="Solution-Homogenous-Coordinates"><a href="#Solution-Homogenous-Coordinates" class="headerlink" title="Solution: Homogenous Coordinates"></a>Solution: Homogenous Coordinates</h3><p>Add a third coordinate ($w$-coordinate)<br>• 2D <strong>point</strong> = $(x, y, 1)^{\mathrm{T}}$<br>• 2D <strong>vector</strong> = $(x, y, 0)^{\mathrm{T}}$</p><p>根据 <em>No free lunch theorem</em> ，我们为了去除平移变换最后的一项，需要在其他地方增加一些复杂度。这里就是增加了一个维度。</p><p>Matrix representation of translations</p><script type="math/tex; mode=display">\begin{pmatrix}     x' \\ y' \\ w' \end{pmatrix} = \begin{pmatrix}     1 & 0 & t_{x} \\ 0 & 1 & t_y \\ 0 & 0 & 1\end{pmatrix} \cdot \begin{pmatrix}     x \\ y \\ 1 \end{pmatrix} = \begin{pmatrix}     x+t_{x} \\ y+t_y \\ 1\end{pmatrix}</script><p>对于一个点来说，经过平移矩阵变换会变成另一个点；但是对于一个向量来说，经过平移矩阵变换之后还是同一个向量。（保证向量平移不变性）</p><p>Valid operation if w-coordinate of result is 1 or 0<br>• vector + vector = vector<br>• point – point = vector<br>• point + vector = point<br>• point + point = ??</p><p>对于最后一个，扩充定义：<br>In homogeneous coordinates, $\begin{pmatrix} x \ y \ w \end{pmatrix}$ is the 2D point $\begin{pmatrix} x / w \ y / w \ 1 \end{pmatrix} (w\neq 0)$<br>那么最后的 point + point 就可以理解为求两点的中点。</p><h3 id="Affine-Transformations-仿射变换"><a href="#Affine-Transformations-仿射变换" class="headerlink" title="Affine Transformations(仿射变换)"></a>Affine Transformations(仿射变换)</h3><p>Affine map = linear map + translation</p><script type="math/tex; mode=display">\begin{pmatrix}     x'\\ y' \end{pmatrix} =\begin{pmatrix}     a & b \\ c & d \end{pmatrix} \begin{pmatrix}     x \\ y \end{pmatrix}+\begin{pmatrix}     t_{x} \\ t_y\end{pmatrix}</script><p>Using homogenous coordinates:</p><script type="math/tex; mode=display">\begin{pmatrix}     x' \\ y' \\ w' \end{pmatrix} = \begin{pmatrix}     a & b & t_{x} \\ c & d & t_y \\ 0 & 0 & 1\end{pmatrix} \cdot \begin{pmatrix}     x \\ y \\ 1 \end{pmatrix}</script><h3 id="2D-Transformations"><a href="#2D-Transformations" class="headerlink" title="2D Transformations"></a>2D Transformations</h3><p>Scale</p><script type="math/tex; mode=display">S(s_{x},s_y)=\begin{pmatrix}     s_{x} & 0 & 0 \\     0 & s_y & 0 \\     0 & 0 & 1 \end{pmatrix}</script><p>Rotation</p><script type="math/tex; mode=display">R(\alpha)=\begin{pmatrix}     \cos \alpha & -\sin \alpha & 0 \\     \sin \alpha & \cos \alpha & 0 \\     0 & 0 & 1 \end{pmatrix}</script><p>Translation:</p><script type="math/tex; mode=display">S(s_{x},s_y)=\begin{pmatrix}     1 & 0 & t_{x} \\     0 & 1 & t_y \\     0 & 0 & 1 \end{pmatrix}</script><p>可以看出对于二维的仿射变换，矩阵的最后一行都是 $0\ 0\ 1$。如果不是的话，那么将对应其他的变换。</p><h2 id="Composing-Transforms"><a href="#Composing-Transforms" class="headerlink" title="Composing Transforms"></a>Composing Transforms</h2><p>经过多次变换 $\Leftrightarrow$ 左乘多个矩阵</p><p>根据矩阵的结合律，可以知道任意一个复杂的变换都可以用一个矩阵表示。（就是利用结合律将矩阵先乘起来）</p><p>同时由于矩阵之间没有交换律，可知如果将两个变换顺序互换，最终得到的结果一般不同。</p><h2 id="3D-Transformations"><a href="#3D-Transformations" class="headerlink" title="3D Transformations"></a>3D Transformations</h2><p>Use homogeneous coordinates again:<br>• 3D point = $(x, y, z, 1)^{\mathrm{T}}$<br>• 3D vector = $(x, y, z, 0)^{\mathrm{T}}$</p><script type="math/tex; mode=display">\begin{pmatrix}     x' \\ y' \\ z' \\ 1 \end{pmatrix} = \begin{pmatrix}     a & b & c & t_{x} \\ d & e & f & t_{y} \\ g & h & i & t_z \\ 0 & 0 & 0 & 1\end{pmatrix} \cdot \begin{pmatrix}     x \\ y \\ z \\ 1 \end{pmatrix}</script><p>The order: Linear Transform first(和二维中情形一样)</p><p>绕着 $x,y,z$ 轴旋转</p><div align=center><img src='../../figure/计算机图形学笔记/4-Transfomation-Cont/rotation.png' width=300></div><script type="math/tex; mode=display">R_{x}(\alpha)=\begin{pmatrix}     1&0&0&0 \\     0&\cos \alpha&-\sin \alpha&0 \\      0&\sin \alpha&\cos \alpha&0 \\    0&0&0&1\end{pmatrix}</script><script type="math/tex; mode=display">R_{y}(\alpha)=\begin{pmatrix}     \cos \alpha&0&\sin \alpha&0 \\     0&1&0&0 \\      -\sin \alpha&0&\cos \alpha&0 \\    0&0&0&1\end{pmatrix}</script><script type="math/tex; mode=display">R_{z}(\alpha)=\begin{pmatrix}     \cos \alpha&-\sin \alpha&0&0 \\     \sin \alpha&\cos \alpha&0&0 \\      0&0&1&0 \\    0&0&0&1\end{pmatrix}</script><p>可以看出绕 $y$ 轴的旋转的矩阵和绕 $x$ 轴、$z$ 轴的有所不同，这个和右手螺旋定则有关。</p><h3 id="3D-Rotations"><a href="#3D-Rotations" class="headerlink" title="3D Rotations"></a>3D Rotations</h3><p>对于任意的旋转，可以看作是绕 $x,y,z$ 轴旋转的叠加</p><script type="math/tex; mode=display">R_{xyz}(\alpha,\beta,\gamma)=R_{x}(\alpha)R_y(\beta)R_z(\gamma)</script><p>这三个角度称为欧拉角。从直观上想象，如图</p><div align=center><img src='../../figure/计算机图形学笔记/4-Transfomation-Cont/euler_angle.png' width=300></div><p>任意的旋转应该都是能被三个方向的旋转表示的</p><h3 id="Rodrigues’-Rotation-Formula"><a href="#Rodrigues’-Rotation-Formula" class="headerlink" title="Rodrigues’ Rotation Formula"></a>Rodrigues’ Rotation Formula</h3><p>旋转的公式为</p><script type="math/tex; mode=display">R(\bm{n},\alpha)=\cos \alpha\cdot \bm{I}+(1-\cos \alpha)\bm{n}\bm{n}^{\mathrm{T}}+\sin \alpha \begin{pmatrix} 0&-n_z&n_y\\n_z&0&-n_{x} \\-n_y&n_{x}&0\end{pmatrix}</script><p>表示以 $\bm{n}$ 方向为轴旋转 $\alpha$ 的角度。其中默认旋转轴经过原点。</p><h2 id="Viewing-观测-transformation"><a href="#Viewing-观测-transformation" class="headerlink" title="Viewing(观测) transformation"></a>Viewing(观测) transformation</h2><h3 id="View-视图-Camera-Transformation"><a href="#View-视图-Camera-Transformation" class="headerlink" title="View(视图) / Camera Transformation"></a>View(视图) / Camera Transformation</h3><p>把三维空间中的物体变成二维的图，就像拍照片。</p><ul><li>首先找一个好的地方，把模型都放好(<strong>model</strong> transformation)</li><li>然后找一个好的角度、位置去放置相机(<strong>view</strong> transformation)</li><li>拍照，完成投影(<strong>projection</strong> transformation)</li></ul><p>这里主要讲视图变换 (view transformation)</p><p>首先确定相机状态</p><ul><li>位置(position) $\vec{e}$</li><li>相机朝向(look-at / gaze direction) $\hat{g}$</li><li>相机顶部方向(up direction) $\hat{t}$，这是为了防止相机能绕着光轴旋转</li></ul><div align=center><img src='../../figure/计算机图形学笔记/4-Transfomation-Cont/camera_defined.png' width=350></div><p>考虑到一点:<br>如果相机和前景背景的相对位置不变，最后得到的结果是一样的。因此我们可以让相机处于一个标准位置上：为了方便，我们默认相机</p><ul><li>处于原点</li><li>朝向 $-z$ 方向</li><li>以 $y$ 方向作为顶部</li></ul><div align=center><img src='../../figure/计算机图形学笔记/4-Transfomation-Cont/key_obervation.png' width=700></div><p>那么想要拍出合适的图，只要让其他物体跟着移动就行了。</p><p>如何将相机从一个任意位置移动到任意位置：</p><ul><li>将 $\vec{e}$ 平移到原点</li><li>将 $\hat{g}$ 转到 $-z$ 方向</li><li>将 $\hat{t}$ 转到 $y$ 方向</li><li>将 $\hat{g}\times \hat{t}$ 转到 $x$ 方向</li></ul><p>$M<em>{view}=R</em>{view}T<em>{view}$。容易得到 $T</em>{view}=\begin{pmatrix}<br>    1&amp;0&amp;0&amp;-x_e\<br>    0&amp;1&amp;0&amp;-y_e\<br>    0&amp;0&amp;1&amp;-z_e\<br>    0&amp;0&amp;0&amp;1<br>\end{pmatrix}$</p><p>而对于矩阵 $R_{view}$，可以先考虑其逆矩阵，也就是将 $x,y,z$ 分别转到 $\hat{g}\times \hat{t},\hat{t},-\hat{g}$ 的矩阵。</p><script type="math/tex; mode=display">R_{view}^{-1}=\begin{pmatrix}     x_{\hat{g}\times \hat{t}} & x_{\hat{t}} & x_{-\hat{g}} & 0\\    y_{\hat{g}\times \hat{t}} & y_{\hat{t}} & y_{-\hat{g}} & 0\\    z_{\hat{g}\times \hat{t}} & z_{\hat{t}} & z_{-\hat{g}} & 0\\    0 & 0 & 0 & 1\end{pmatrix}</script><p>考虑到旋转矩阵为正交矩阵，因此矩阵的逆等于矩阵转置</p><script type="math/tex; mode=display">R_{view}=(R_{view}^{-1})^{-1}=(R_{view}^{-1})^{\mathrm{T}}= \begin{pmatrix}     x_{\hat{g}\times \hat{t}} & y_{\hat{g}\times \hat{t}} & z_{\hat{g}\times \hat{t}} & 0 \\    x_{\hat{t}} & y_{\hat{t}} & z_{\hat{t}} & 0 \\    x_{-\hat{g}} & y_{-\hat{g}} & z_{-\hat{g}} & 0 \\    0 & 0 & 0 & 1\end{pmatrix}</script><h3 id="Projection-Transformation"><a href="#Projection-Transformation" class="headerlink" title="Projection Transformation"></a>Projection Transformation</h3><ul><li>正交投影(orthographic projection)(常用于工程制图)</li><li>透视投影(perspective projection)(常用于绘画，能展现近大远小的效果)</li></ul><div align=center><img src='../../figure/计算机图形学笔记/4-Transfomation-Cont/projection.png' width=700></div><p>正交投影可以理解为将透视投影的camera的位置移到无穷远</p><div align=center><img src='../../figure/计算机图形学笔记/4-Transfomation-Cont/projection2.png' width=700></div><h4 id="Orthographic-Projection"><a href="#Orthographic-Projection" class="headerlink" title="Orthographic Projection"></a>Orthographic Projection</h4><p>正交投影的一种简单理解是直接扔掉 $z$ 轴坐标</p><p>而在图形学中，正交投影是将空间中的一个立方体 $\left[ l,r \right]\times [b,t] \times [f,n]$ 变换为一个“标准”(canonical)立方体 $[-1,1]^{3}$。变换矩阵为</p><script type="math/tex; mode=display">M_{\text {ortho }}=\begin{pmatrix}\frac{2}{r-l} & 0 & 0 & 0 \\0 & \frac{2}{t-b} & 0 & 0 \\0 & 0 & \frac{2}{n-f} & 0 \\0 & 0 & 0 & 1\end{pmatrix}\begin{pmatrix}1 & 0 & 0 & -\frac{r+l}{2} \\0 & 1 & 0 & -\frac{t+b}{2} \\0 & 0 & 1 & -\frac{n+f}{2} \\0 & 0 & 0 & 1\end{pmatrix}</script><h4 id="Perspective-Projection"><a href="#Perspective-Projection" class="headerlink" title="Perspective Projection"></a>Perspective Projection</h4><p>透视投影是用的最广泛的一种投影，满足近大远小，同时带来的视觉效果为平行线不再平行。</p><p>如何做透视投影？从直观上来说就是将如图所示的台体(Frustum)挤压(squish)成长方体(Cuboid)，然后再照着正交投影的步骤来即可</p><div align=center><img src='../../figure/计算机图形学笔记/4-Transfomation-Cont/squish.png' width=500></div><p>为规范化操作过程，在挤压的过程中，我们规定近平面(n)的4个点不变，而远平面(f)的 $z$ 坐标和中心不会变化。</p><p>对于某一点 $(x,y,z)$，我们假设挤压之后的点位置为 $(x’,y’,z’)$，应当有 </p><script type="math/tex; mode=display">y'=\frac{n}{z}y \quad x'=\frac{n}{z}x</script><p>而 $z’$ 还暂时不知道。</p><div align=center><img src='../../figure/计算机图形学笔记/4-Transfomation-Cont/similar_triangle.png' width=500></div><p>而坐标映射情况为</p><script type="math/tex; mode=display">\begin{pmatrix}     x \\ y \\ z \\1 \end{pmatrix} \Rightarrow\begin{pmatrix}     nx /z \\ ny /z \\ \text{unknown} \\ 1\end{pmatrix} =\begin{pmatrix}     nx \\ ny \\ \text{still unknown} \\ z\end{pmatrix}</script><p>此时可以得到</p><script type="math/tex; mode=display">M_{persp\to ortho}=\begin{pmatrix}     n&0&0&0 \\ 0&n&0&0 \\ ?&?& ?&? \\ 0&0&1&0\end{pmatrix}</script><p>为了解出矩阵中的 $?$，考虑规定的两个性质：</p><ul><li>在近平面上的点不会动</li><li>远平面的中点不会动</li></ul><p>由第一个性质</p><script type="math/tex; mode=display">\begin{pmatrix}     x \\ y \\ n \\1 \end{pmatrix} \Rightarrow\begin{pmatrix}     x \\ y \\ n \\ 1\end{pmatrix} =\begin{pmatrix}     nx \\ ny \\ n^{2} \\ n\end{pmatrix}</script><p>则 $M_{persp\to ortho}$ 的第三行必为 $\begin{pmatrix} 0&amp;0&amp;A&amp;B \end{pmatrix}$ 的形式</p><script type="math/tex; mode=display">\begin{pmatrix}     0&0&A&B \end{pmatrix} \begin{pmatrix}     x \\ y \\ n \\ 1 \end{pmatrix} = n^{2}</script><script type="math/tex; mode=display">\Rightarrow An+B=n^{2}</script><p>再由第二个性质</p><script type="math/tex; mode=display">\begin{pmatrix}     0 \\ 0 \\ f \\ 1\end{pmatrix} \Rightarrow\begin{pmatrix}     0 \\ 0 \\ f \\ 1\end{pmatrix} =\begin{pmatrix}     0 \\ 0 \\ f^{2} \\ f\end{pmatrix}</script><p>同理得到</p><script type="math/tex; mode=display">\Rightarrow Af+B=f^{2}</script><p>从而解得 $A=n+f, B=-nf$</p><script type="math/tex; mode=display">M_{persp\to ortho}=\begin{pmatrix}     n&0&0&0 \\ 0&n&0&0 \\ 0&0&n+f&-nf \\ 0&0&1&0\end{pmatrix}</script><p>$M<em>{persp}=M</em>{ortho}M_{persp \to ortho}$</p><p>如何定义透视投影所需的的视锥？</p><div align=center><img src='../../figure/计算机图形学笔记/4-Transfomation-Cont/frustum.png' width=500></div><p>对于图中所示视锥。宽高比($Aspect ratio = width/height$)，而垂直可视角度(Vertical Field of View)如图所示。有了宽高比和视锥，就能得到宽和高。</p>]]></content>
      
      
      <categories>
          
          <category> computer graphics notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公路车shimano套件</title>
      <link href="/posts/3b34704b.html"/>
      <url>/posts/3b34704b.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>参考：<a href="http://www.cyclingchina.net/site/html/2018/new_product_0525/4057.html">文章1</a>、<a href="https://www.dongchedi.com/article/7052558265578045982">文章2</a>和<a href="https://www.bilibili.com/video/BV1xF411T7UA/?vd_source=4818ed7eb881f1eba75c12df1d2bd43c">视频</a></p></div><h2 id="Shimano-套件种类"><a href="#Shimano-套件种类" class="headerlink" title="Shimano 套件种类"></a>Shimano 套件种类</h2><p>Shimano套件近年来经过两次更新。2015~2018年间，对所有公路车套件大更新，顶级套件采用全新技术，然后上一代顶尖技术下放到中低端产品。包括去除中低端系列旧款手边的螳螂须（2400到r2000），牙盘从五爪镂空改为四爪设计。新款的套件大多都以r开头，指代“road”（Tiagra 4700是新一代中最早发布的，还用的上一代命名规则）。</p><p>速别不同的套件除了刹车之外不能进行混搭。</p><h3 id="Dura-Ace"><a href="#Dura-Ace" class="headerlink" title="Dura-Ace"></a>Dura-Ace</h3><p>Dura-Ace系列产品在Shimano的公路产品中代表着最顶尖的性能与最昂贵的售价，简称DA套件。你所看到的环法自行车赛中的车手，全部都是使用Dura-Ace级别性能的产品。</p><h4 id="Dura-Ace-DI2-R9150-（圈刹）-R9170（碟刹）"><a href="#Dura-Ace-DI2-R9150-（圈刹）-R9170（碟刹）" class="headerlink" title="Dura-Ace DI2 R9150 （圈刹） / R9170（碟刹）"></a>Dura-Ace DI2 R9150 （圈刹） / R9170（碟刹）</h4><ul><li>换档：电子</li><li>制动：轮圈 (R9150) 或碟盘 (R9170)</li><li>速度：2×11</li><li>重量：1911g/1931g</li><li>链轮（牙盘）片：50-34T、52-36T、53-39T、54-42T、55-42T</li><li>飞轮：11-25T、11-28T、11-30T、12-25T、12-28T</li></ul><h4 id="Dura-Ace-R9100-R9120"><a href="#Dura-Ace-R9100-R9120" class="headerlink" title="Dura-Ace R9100/R9120"></a>Dura-Ace R9100/R9120</h4><ul><li>换档：机械</li><li>制动：轮圈 (R9100) 或碟盘 (R9120)</li><li>速度：2×11</li><li>重量：1,973g/2,076g</li><li>曲柄：165mm、167.5mm、170mm、172.5mm、175mm、177.5mm、180mm</li><li>链轮（牙盘）片：50-34T、52-36T、53-39T、54-42T、55-42T</li><li>飞轮：11-25T、11-28T、11-30T、12-25T、12-28T</li></ul><h3 id="Ultegra"><a href="#Ultegra" class="headerlink" title="Ultegra"></a>Ultegra</h3><p>Ultegra系列产品是Shimano公路产品中的次顶级存在，简称UT套件。</p><h4 id="Ultegra-DI2-R8050-R8070"><a href="#Ultegra-DI2-R8050-R8070" class="headerlink" title="Ultegra DI2 R8050/R8070"></a>Ultegra DI2 R8050/R8070</h4><ul><li>换档：电子</li><li>制动：轮圈 (R8050) 或碟盘 (R8070)</li><li>速度：2×11</li><li>重量：2,209g/2,200g</li><li>曲柄：165mm、170mm、172.5mm、175mm</li><li>链轮（牙盘）：46-36T、50-34T、52-36T、53-39T</li><li>飞轮：11-25T、11-28T、11-30T、11-32T、11-34T、12-25T、14-28T</li></ul><h4 id="Ultegra-R8000-R8020-R8025"><a href="#Ultegra-R8000-R8020-R8025" class="headerlink" title="Ultegra R8000/R8020/R8025"></a>Ultegra R8000/R8020/R8025</h4><ul><li>换档：机械</li><li>制动：轮圈 (R8000) 或碟盘 (R8020/R8025)其中R8025适合小手</li><li>速度：2×11</li><li>重量：2,272g/2,314g</li><li>曲柄：165mm、170mm、172.5mm、175mm</li><li>链轮（牙盘）：46-36T、50-34T、52-36T、53-39T</li><li>飞轮：11-25T、11-28T、11-30T、11-32T、11-34T、12-25T、14-28T</li></ul><h3 id="105"><a href="#105" class="headerlink" title="105"></a>105</h3><p>105套件可以定位为专业入门级，可以用于骑行训练与竞赛。常见于各大整车品牌的专业入门级公路车上。</p><h4 id="105-R7000-R7020-R7025"><a href="#105-R7000-R7020-R7025" class="headerlink" title="105 R7000/R7020/R7025"></a>105 R7000/R7020/R7025</h4><ul><li>换档：机械</li><li>制动：轮圈 (R7000) 或碟盘 (R7020/R7025)其中R7025适合小手</li><li>速度：2×11</li><li>重量：2,453 克/2,469 克</li><li>曲柄：160mm、165mm、170mm、172.5mm、175mm</li><li>链轮（牙盘）：50-34T、52-36T、53-39T</li><li>飞轮：11-28T、11-30T、11-32T、11-34T、12-25T、14-28T</li></ul><h3 id="Tiagra"><a href="#Tiagra" class="headerlink" title="Tiagra"></a>Tiagra</h3><p>Tiagra套件是Shimano公路套件中关于变速级别的一个分水岭，Dura-Ace、Ultegra和105都属于2×11速变速系统，而Tiagra仅仅只有10速，但它多了一个3×10速的选择，能够应对更为复杂的骑行路线。由于只有10速，Tiagra 4700/4720 组件与 Shimano 的 11 速套件不兼容，因此升级路径并不容易。如果想升级到 11 速，那么需要一次性更换整个套件。</p><h4 id="Tiagra-4700-4720-4725"><a href="#Tiagra-4700-4720-4725" class="headerlink" title="Tiagra 4700/4720/4725"></a>Tiagra 4700/4720/4725</h4><ul><li>换档：机械</li><li>制动：轮圈 (4700) 或碟盘 (4720/4725)其中4725适合小手</li><li>速度：3×10 或 2×10</li><li>重量：2,767g/2,826g</li><li>曲柄：165mm、170mm、172.5mm、175mm</li><li>链轮（牙盘）：48-34T、50-34T、52-36T、50-39-30T</li><li>飞轮：11-25T、12-28T、11-32T、11-34T。型号为HG500-10</li></ul><p>提供开口圈刹轮组RS100。<br>花鼓方便，RS400为快拆圈刹花鼓，RS470为桶轴碟刹花鼓，RS505为快拆碟刹花鼓。<br>轮组以及三款花鼓都兼容10速和11速</p><h4 id="RS405"><a href="#RS405" class="headerlink" title="RS405"></a>RS405</h4><p>2016年。过渡期的油压碟刹手边，很快被淘汰</p><h4 id="4600"><a href="#4600" class="headerlink" title="4600"></a>4600</h4><h3 id="Sora"><a href="#Sora" class="headerlink" title="Sora"></a>Sora</h3><p>SORA系列算是入门级别的套件，适合户外运动、健身骑行。它是一个 9 速系统，有双牙盘和三牙盘可供选择，后拨链器可容纳 11-32t 飞轮和 50/34t 紧凑型牙盘。只提供了圈刹版本套件。</p><h4 id="r3000"><a href="#r3000" class="headerlink" title="r3000"></a>r3000</h4><ul><li>换档：机械</li><li>制动：轮圈</li><li>速度：3×9 或 2×9</li><li>链轮（牙盘）：50-34T、50-39-30T</li><li>飞轮：11-25T、11-30T、11-32T、12-25T、13-25T、14-25T</li></ul><p>有配套信号为RS300的前后花鼓</p><h4 id="3500"><a href="#3500" class="headerlink" title="3500"></a>3500</h4><h3 id="Claris"><a href="#Claris" class="headerlink" title="Claris"></a>Claris</h3><p>Claris 是 Shimano 最实惠的公路自行车套件，这是一款 8 速套件，主要用于健身、长途骑行、休闲骑以及日常通勤。有三重 (53/39/30) 和紧凑型 (50/34) 牙盘（常称为压缩盘，对入门者较为友好）选项，以及 11-34 飞轮。</p><p>后拨有两种型号，SS代表短腿，GS代表中腿。最大飞轮齿数小于28t采用短腿，大于则采用中腿</p><h4 id="r2000"><a href="#r2000" class="headerlink" title="r2000"></a>r2000</h4><ul><li>换档：机械</li><li>制动：轮圈</li><li>速度：3×8 或 2×8</li><li>链轮（牙盘）：50-34T、50-39-30T</li><li>飞轮：11-28T、11-30T、11-32T、11-34T、12-25T、13-26T<h4 id="2400"><a href="#2400" class="headerlink" title="2400"></a>2400</h4></li></ul><h3 id="Tourney"><a href="#Tourney" class="headerlink" title="Tourney"></a>Tourney</h3><p>Tourney A070是Shimano的7速低端套件</p><h2 id="大套、中套、小套"><a href="#大套、中套、小套" class="headerlink" title="大套、中套、小套"></a>大套、中套、小套</h2><p>（不确定）</p><ul><li>小套：手变、前拨、后拨</li><li>中套：手变、前拨、后拨、牙盘、中轴、飞轮、链条</li><li>大套：手变、前拨、后拨、牙盘、中轴、飞轮、链条、夹器</li></ul><h2 id="Shimano套件价格"><a href="#Shimano套件价格" class="headerlink" title="Shimano套件价格"></a>Shimano套件价格</h2><p>2023年6月24日，淘宝查询价格。不同店铺会略有不同。同时考虑到同一类型套件型号比较多，以及包装方式不同，因此价格差异也会比较大。故下表仅供参考。</p><table>  <tr>    <th></th><th>手变</th><th>前拨</th><th>后拨</th><th>牙盘</th><th>飞轮</th><th>链条</th><th>夹器</th><th>小套</th><th>中套</th><th>大套</th>  </tr>  <tr>    <td>Tourney</td><td>298</td><td>55</td><td>65</td><td>150</td><td></td><td></td><td></td><td>378</td><td></td><td></td>  </tr>  <tr>    <td>Claris r2000</td><td>468</td><td>74</td><td>84</td><td>410(加中轴)</td><td>68(HG50-8)</td><td>32(HG71)</td><td>200</td><td>589</td><td>1115</td><td>1198</td>  </tr>  <tr>    <td>Sora r3000</td><td>670</td><td>105</td><td>148</td><td>455(加中轴)</td><td>85(HG400-9)</td><td>48(HG35)</td><td>205</td><td>870</td><td>1430</td><td>1630</td>  </tr>  <tr>    <td>Tiagra 4700</td><td>848</td><td>98</td><td>198</td><td>515(加中轴)</td><td>145(HG500-10)</td><td>83(HG54)</td><td>208</td><td>1096</td><td>1675</td><td>1875</td>  </tr>  <tr>    <td>105 r7000</td><td>1098</td><td>178</td><td>265</td><td>800(加中轴)</td><td>235</td><td>130(HG601)</td><td>260</td><td>1650</td><td></td><td>2900</td>  </tr>  <tr>    <td>Ultegra r8000</td><td>1270</td><td>198</td><td>498</td><td>1200(加中轴)</td><td>338</td><td>138(HG701)</td><td>428</td><td>1800</td><td></td><td>4000</td>  </tr></table><p>DA懒得查了</p>]]></content>
      
      
      <categories>
          
          <category> 自行车 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 套件 </tag>
            
            <tag> 公路车 </tag>
            
            <tag> Shimano </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-2023秋季学期《电路理论》期末解答</title>
      <link href="/posts/ce3dbf43.html"/>
      <url>/posts/ce3dbf43.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>解答：林昊、朱小志</p></div><p><strong>问题2</strong></p><font color=#4A96C9>图中，若选支路{1, 2, 4, 5, 6}为树支，则{1, 2, 6, 7}是基本割集。</font><div align=center><img src='../../figure/电路理论2022-2023秋/20230302212209.png' width=300></div><font color=orange>解答：</font><p><strong>False</strong>。<br>基本割集只能包含一条树支。</p><p><strong>问题3</strong></p><font color=#4A96C9>图示电路中所有线性电阻的阻值相同，则图(a)的等效电阻$R_{ab}$更大。</font><div align=center><img src='../../figure/电路理论2022-2023秋/20230302212626.png' width=450></div><font color=orange>解答：</font><p><strong>True</strong></p><script type="math/tex; mode=display">(a)R_{eq}=\frac{1}{2}[R+\frac{1}{2}(2R+2R)+R]=\frac{3}{2}R</script><script type="math/tex; mode=display">(b)R_{eq}=2R//[R+(2R)//(R+2R+R)+R]=\frac{5}{4}R</script><div align=center><img src='../../figure/电路理论2022-2023秋/20230302212808.png' width=450></div><p><strong>问题4</strong></p><font color=#4A96C9>图示正弦稳态电路中功率表的读数与$2 \Omega$电阻吸收的有功功率相同。</font><div align=center><img src='../../figure/电路理论2022-2023秋/20230302212928.png' width=300></div><font color=orange>解答：</font><p><strong>True</strong><br>电感不消耗有功功率。</p><p><strong>问题5</strong></p><font color=#4A96C9>图示二端口网络若为对称二端口，则元件参数需满足 $R_1=(n^{2}-1)R_2$</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob5.png' width=300></div><font color=orange>解答：</font><p><strong>True</strong></p><p>若网络为对称端口，当 $i_1=i_2\equiv i$，有 $u_1=u_2\equiv u$</p><script type="math/tex; mode=display">(1+n)\cdot i\cdot R_2=\frac{1}{n}u</script><script type="math/tex; mode=display">iR_1=(1-\frac{1}{n})u</script><p>将上两式相除，得到</p><script type="math/tex; mode=display">(1+n)\frac{R_1}{R_2}=\frac{1}{n-1}</script><script type="math/tex; mode=display">R_1=(n^2-1)R_2</script><p><strong>问题6</strong></p><font kcolor=#4A96C9>若图示电路中 $R<5\Omega$，则此电路不存在谐振频率。 </font><div align=center><img src='../../figure/电路理论2022-2023秋/prob6.png' width=220></div><font color=orange>解答：</font><p><strong>False</strong></p><script type="math/tex; mode=display">Y=j\omega C+\frac{1}{j\omega L+R}=\frac{R}{\omega ^2L^2+R^2}+j\omega (C-\frac{L}{\omega ^2L^2+R^2})</script><script type="math/tex; mode=display">\omega =\frac{1}{L}\sqrt{\frac{L}{C}-R^2}</script><script type="math/tex; mode=display">\because \frac{L}{C}-R^2>0</script><p>所以存在谐振频率。</p><p><strong>问题7</strong></p><font color=#4A96C9>图示电路中，N仅由线性电阻构成，图(a)中$I_1=1A，I_2=0.5A$，则图(b)中电压$U_1$为($\quad$)。</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob7.png' width=600></div><font color=orange>解答：</font><p><strong>A</strong></p><p>重画电路图如图：</p><div align=center><img src='../../figure/电路理论2022-2023秋/prob7-ans1.png' width=400></div><p>有</p><script type="math/tex; mode=display">\begin{aligned}&i_1=I_1=1A \quad u_1=5-4\times 1=1V\\&i_2=I_2=0.5A\quad u_2=0\\&u_1'=4(1-i_1') \quad u_2'=6V\end{aligned}</script><p>利用特勒根定理</p><script type="math/tex; mode=display">-i_1u_1'+i_2u_2'=-i_1'u_1+i_2'u_2</script><script type="math/tex; mode=display">\Rightarrow i_1'=\frac{1}{5}A \quad U_1=u_1'=\frac{16}{5}V</script><p><strong>问题8</strong></p><font color=#4A96C9>图示电路中N为线性含源电阻电路，根据图(a)、(b)的情况，可得图(c)中的电压$U$为($\quad$ )。</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob8.png' width=600></div><font color=orange>解答：</font><p><strong>C</strong></p><p>对N做戴维宁等效，记等效电阻为 $R_0$，等效电压为 $U_0$.<br>(a). 最右侧支路无电流，所以 $5\Omega$ 电阻上电流为 $2 /5=0.4A$</p><script type="math/tex; mode=display">U_0=0.4(R_0+5)</script><p>(b). </p><script type="math/tex; mode=display">U_0=2R_0</script><p>由以上条件可以解得 $U_0=2.5V$，$R_0=1.25\Omega$</p><p>(c).</p><script type="math/tex; mode=display">\begin{aligned}I=\frac{5-U_0}{R_0+5}=0.4A \\U=5-5I=3V\end{aligned}</script><p><strong>问题9</strong></p><font color=#4A96C9>图示电路中$1\Omega$电阻吸收的功率为($\quad$ )。</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob9.png' width=500></div><font color=orange>解答：</font><p><strong>A</strong></p><div align=center><img src='../../figure/电路理论2022-2023秋/prob9-ans1.png' width=250></div><script type="math/tex; mode=display">1\times i_1+10\times 0.1i_1=2V \Rightarrow i_1=1A,P=1W</script><p><strong>问题10</strong></p><font color=#4A96C9>图示电路中理想二极管两端电压U为($\quad$)。</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob10.png' width=450></div><font color=orange>解答：</font><p><strong>B</strong></p><p>假设二极管不导通，则右侧支路无电流。则</p><script type="math/tex; mode=display">U=2-1\times 1=1V>0</script><p>可以看出假设成立，$U=1V$</p><p><strong>问题11</strong></p><font color=#4A96C9>图示电路的短路电导参数为($\quad$)。</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob11.png' width=550></div><font color=orange>解答：</font><p><strong>D</strong></p><div align=center><img src='../../figure/电路理论2022-2023秋/prob11-ans1.png' width=270></div><script type="math/tex; mode=display">\begin{cases}    i_1+i_2=0 \\    -u_1+i_1+u_2-i_2+i_1=0\end{cases}\Rightarrow u_1=u_2+3i_1</script><script type="math/tex; mode=display">\therefore \begin{pmatrix} i_1 \\ i_2\end{pmatrix} =\begin{pmatrix}     \frac{1}{3} & -\frac{1}{3}\\ -\frac{1}{3} & \frac{1}{3}\end{pmatrix} \begin{pmatrix}     u_1\\u_2 \end{pmatrix}</script><p><strong>问题12</strong></p><font color=#4A96C9>图示电路在开关K打开前已达稳态。$t=0$时开关打开，则下列选项中<strong><font color=red >错误</font></strong>的是 ($\quad$)。</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob12.png' width=400></div><font color=orange>解答：</font><p><strong>D</strong></p><script type="math/tex; mode=display">i_{L}(0_{-})=1A \quad u_{C}(0_{-})=5V</script><p>打开开关K，$i<em>{L}$ 和 $u</em>{C}$ 均为发生跳变</p><script type="math/tex; mode=display">\therefore  i_{L}(0_{+})=i_{L}(0_{-})=1A \quad u_{C}(0i_{+})=u_{C}(0_{-})=5V</script><p>A.$u<em>{R}(0</em>{+})=5\Omega\times i<em>{L}(0</em>{+})=5V$，正确<br>B.$u<em>{K}(0</em>{+})=u<em>{C}(0</em>{+})=5V$，正确<br>C.$i<em>{C}(0</em>{+})=i<em>{L}(0</em>{+})=1A$，正确<br>D.$u<em>{L}(0</em>{+})=10V-u<em>{C}(0</em>{+})-u<em>{R}(0</em>{+})=0$，错误</p><p><strong>问题13</strong></p><font color=#4A96C9>图示电路的相应为($\quad$)。</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob13.png' width=500></div><font color=orange>解答：</font><p><strong>A</strong></p><p>先将电路做如下等效变换</p><div align=center><img src='../../figure/电路理论2022-2023秋/prob13-ans1.png' width=600></div><script type="math/tex; mode=display">\begin{aligned}& i_1+i_2=I_0 \\& i_1=C\frac{\mathrm{d}u}{\mathrm{d}t}\\& Ri_2=u+L\frac{\mathrm{d}i_1}{\mathrm{d}t}\end{aligned}</script><script type="math/tex; mode=display">\Rightarrow LC\frac{\mathrm{d}^{2}u}{\mathrm{d}t^{2}}+RC\frac{\mathrm{d}u}{\mathrm{d}t}+u=RI_0</script><script type="math/tex; mode=display">\Delta=(RC)^{2}-4LC=4-2>0</script><p>因此为过阻尼。</p><p><strong>问题14</strong></p><font color=#4A96C9>图示有向图的降阶关联矩阵$\bm{A}$为($\quad$)。</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob14.png' width=600></div><font color=orange>解答：</font><p><strong>A</strong></p><p><strong>问题15</strong></p><font color=#4A96C9>图示电路的节点电压方程($\quad$)。</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob15.png' width=600></div><font color=orange>解答：</font><p><strong>D</strong></p><script type="math/tex; mode=display">u_1=u_s \\(\frac{1}{R_1}+\frac{1}{R_4})u_2-\frac{1}{R_1}u_1-i_{s}=0</script><p>将方程化成矩阵形式即可得到答案。</p><p><strong>问题16</strong></p><font color=#4A96C9>图示电路中理想运算放大器工作于线性区，则电路时间常数为($\quad$)。</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob16.png' width=500></div><font color=orange>解答：</font><p><strong>A</strong></p><p>分析电路，可以看出电路上方流过的电流恒定为 $0.5mA$</p><div align=center><img src='../../figure/电路理论2022-2023秋/prob16-ans1.png' width=300></div><script type="math/tex; mode=display">\therefore \tau =RC=4k\Omega*1000\mu F=4s</script><p><strong>问题17</strong></p><font color=#4A96C9>若图示电路外接 $\omega=1 rad/s$的正弦激励时的输入等效阻抗 $Z_{ab}=j4\Omega$，则方框中所接元件及其参数是($\quad$ )。</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob17.png' width=500></div><font color=orange>解答：</font><p><strong>B</strong></p><p>先去耦得到如图电路</p><div align=center><img src='../../figure/电路理论2022-2023秋/prob17-ans1.png' width=400></div><script type="math/tex; mode=display">Z_{ab}=\frac{(Z-2j)5j}{(Z-2j)+5j}+4j=4j\Rightarrow Z=2j</script><p>因此框中应该是一个 $2H$ 的电感。</p><p><strong>问题18</strong></p><font color=#4A96C9>图示三相对称电阻性负载外接三相对称正序(UVW)电源，电源相电压有效值为200V，三相负载吸收的有功功率为1200W。则以下选项<strong><font color=red >错误</font></strong>的是($\quad$ )。</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob18.png' width=450></div><font color=orange>解答：</font><p><strong>A</strong></p><div align=center><img src='../../figure/电路理论2022-2023秋/prob18-ans1.png' width=300></div><p>A. 如图所示，$U<em>{uw}$ 和 $I</em>{v}$ 垂直，功率为 $0$<br>B. 由于负载连接方式对线电流无影响，不妨设负载为星形连接。一个电阻有 $P_0=400W$。线电流等于负载端相电流 <script type="math/tex">I=P /U=2A</script><br>C. </p><script type="math/tex; mode=display">R=\frac{u^{2}}{P_0}=100 \Omega</script><p>D.</p><script type="math/tex; mode=display">R=\frac{(\sqrt{3}U)^{2}}{P_0}=300\Omega</script><p><strong>问题19</strong></p><font color=#4A96C9>图示电路中N是线性电阻网络。$t=0$ 时开关闭合，若 $u_{s}=2\varepsilon(t)V$，有<strong><font color=red >全响应</font></strong> $u_{C}=8-4e^{-3t}V(t\ge 0)$，则网络函数 $\displaystyle H(s)=\frac{U_{C}(s)}{U_{S}(s)}$ 为($\quad$) </font><div align=center><img src='../../figure/电路理论2022-2023秋/prob19.png' width=450></div><font color=orange>解答：</font><p><strong>A</strong></p><p>因为网络函数考虑的是一个零状态的运算电路，而电容的全响应为 $u<em>{C}=8-4e^{-3t}V(t\ge 0)$， 我们写出其零响应的形式，为 $u</em>{C}=8-8e^{-3t}V$。</p><script type="math/tex; mode=display">\therefore U_{C}(s)=\frac{8}{s}-\frac{8}{s+3}</script><script type="math/tex; mode=display">U_{S}(s)=\frac{2}{s}</script><script type="math/tex; mode=display">\Rightarrow H(s)=\frac{U_{C}(s)}{U_{S}(s)}=\frac{12}{s+3}</script><p><strong>问题20</strong></p><font color=#4A96C9>图示二端口网络<strong><font color=red >不存在</font></strong>以下哪种参数( $\quad$ )。</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob20.png' width=450></div><font color=orange>解答：</font><p><strong>A</strong></p><script type="math/tex; mode=display">I_1\left( s \right) +I_2(s)=0</script><script type="math/tex; mode=display">U_1(s)-U_2(s)=[I_1(s)-U_1(s)]\cdot j\omega L</script><p>而开路电阻参数的形式为</p><script type="math/tex; mode=display">\begin{pmatrix}     U_1 \\ U_2 \end{pmatrix} =\begin{pmatrix}     Z_{11}&Z_{12}\\ Z_{21} &Z_{22}\end{pmatrix} \begin{pmatrix}     I_1\\ I_2 \end{pmatrix}</script><p>可以看出由电路列出的两条方程无法写成开路电阻参数的形式。</p><p><strong>问题21</strong></p><font color=#4A96C9>图示电路中，理想运算放大器工作于线性区。欲使电流 $i_{L}$与负载电阻 $R_{L}$无关，则图中电阻元件参数需满足以下哪个条件($\quad$)。</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob21.png' width=500></div><font color=orange>解答：</font><p><strong>B</strong></p><p>设 $R_2$ 上电流为 $i_2$，$R_4$ 上电流为 $i_4$</p><script type="math/tex; mode=display">i_2=\frac{u_1-i_LR_L}{R_2}</script><script type="math/tex; mode=display">i_4=(i_{L}+i_{L}\frac{R_{L}}{R_1})</script><script type="math/tex; mode=display">\begin{aligned}u_i&=(R_2+R_3)i_2+R_4i_4+i_{L}R_{L} \\&=(R_2+R_3)\frac{u_i-i_{L}R_{L}}{R_2}+R_4(i_{L}+i_{L}\frac{R_{L}}{R_1})+i_{L}R_{L} \tag{1}\end{aligned}</script><p>如果想让 $i<em>{L}$ 与 $R</em>{L}$ 无关，那么方程(1)中应当没有 $i<em>{L}R</em>{L}$ 的项。即</p><script type="math/tex; mode=display">-\frac{R_3+R_2}{R_2}\cdot i_{L}R_{L}+\frac{R_4}{R_1}i_{L}R_{L}+i_{L}R_{L}=0</script><script type="math/tex; mode=display">\therefore R_1R_3=R_2R_4</script><p><strong>问题22</strong><br><strong>(1) 计算题</strong></p><font color=#4A96C9>试求图示电路的最简等效电路。</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob22-1.png' width=300></div><font color=orange>解答：</font><p>网孔电流法，设最左侧网孔有网孔电流 $i_2$，中间网孔 $i_1$，右侧假设 $ab$ 间接了电流源，电流 $i$。设以上网孔电流方向均为逆时针。</p><p>对于最左侧网孔</p><script type="math/tex; mode=display">12i_1-18i_2=U_S\,\,\Rightarrow \,\,i_1=\frac{18i_2+U_S}{12}</script><p>对于中间网孔</p><script type="math/tex; mode=display">24i_1-4U-12i_2-4i=0,U=12\left( i_1-i_2 \right) \Rightarrow i=-6i_1+9i_2=-\frac{U_S}{2}</script><p>从表达式中看出流入 $ab$ 端口的电流与 $ab$ 端口电压无关，为一个常数。最后得到等效电路为</p><div align=center><img src='../../figure/电路理论2022-2023秋/prob22-1-ans.png' width=300></div><p><strong>(2)计算题</strong></p><font color=#4A96C9>图示电路中，$L_1=1H,L_2=2H,R=3\Omega$，试计算单位阶跃响应 $i_{R}$。</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob22-2.png' width=350></div><font color=orange>解答：</font><p>将电路左侧等效为诺顿电路</p><script type="math/tex; mode=display">Z_{eq}=\left( 2s \right) //\left[ s+\left( 2s \right) //\left( 2s \right) \right] =s</script><script type="math/tex; mode=display">I_{S}(s)=\frac{1}{4s^{2}}</script><p>从而解得电阻上电流</p><script type="math/tex; mode=display">I_R(s)=\frac{1}{4s^2}\cdot \frac{s}{s+3}=\frac{1}{12}\left( \frac{1}{s}-\frac{3}{s+3} \right)</script><script type="math/tex; mode=display">\therefore i_R\left( t \right) =\frac{1}{12}\left( 1-e^{-3t} \right) \varepsilon \left( t \right)</script><p><strong>(3)计算题</strong></p><font color=#4A96C9>图示电路中，$u_s=(1+\sqrt{2}\sin t+2\cos 2t)V$，试求电流 $i$ 的有效值。</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob22-3.png' width=240></div><font color=orange>解答：</font><p>使用叠加定理，</p><script type="math/tex; mode=display">u_s=\sqrt{2}\sin t \Rightarrow i=\sqrt{2}\sin t</script><script type="math/tex; mode=display">u_s=2\cos 2t \Rightarrow i=2\cos t</script><script type="math/tex; mode=display">u_s=1 \Rightarrow i=0</script><script type="math/tex; mode=display">\therefore i=\sqrt{2}\sin t+2\cos t</script><script type="math/tex; mode=display">\therefore I=\sqrt{\left( \frac{\sqrt{2}}{\sqrt{2}} \right) ^2+\left( \frac{2}{\sqrt{2}} \right) ^2}A=\sqrt{3}A</script><p><strong>(4)分析题</strong></p><font color=#4A96C9>图示电路中对称三相正序电源的相电压 $\dot{U}_{AN}=220 \angle 0 \degree V,Z_1=20\Omega,Z_2=(20+j40)\Omega$ 阻抗 $Z$ 为多大时可获得最大功率?并求此功率。</font><div align=center><img src='../../figure/电路理论2022-2023秋/prob22-4.png' width=360></div><font color=orange>解答：</font><p>先将电路等效为戴维宁电路，然后利用 $Z=Z_{eq}^{*}$ 时功率最大，得到 $Z$。最后求出该最大功率。</p><p>等效电阻为</p><script type="math/tex; mode=display">Z_{eq}=\left( 2Z_1 \right) //\left( 2Z_2 \right) =40//\left( 40+80j \right) =30+10j</script><script type="math/tex; mode=display">\Rightarrow Z=Z_{eq}^*=30-10j</script><p>再求此时流过 $Z$ 的电流</p><div align=center><img src='../../figure/电路理论2022-2023秋/prob22-4-ans.png' width=400></div><script type="math/tex; mode=display">U_a=\frac{Z_1}{Z_1+Z_2}U_{AN}=55\sqrt{10}\angle \varphi ,\,\,\varphi =\arctan \frac{1}{3}</script><script type="math/tex; mode=display">\therefore U_{ab}=22\sqrt{30}\angle \left( \varphi +30° \right) =U_{OC}</script><script type="math/tex; mode=display">\,\,I=\frac{U_{OC}}{Z+Z_{eq}}=\frac{11\sqrt{30}}{12}\angle \left( \varphi +30° \right) ,U_Z=ZI=\frac{275}{3}\sqrt{3}\angle 30°</script><p>最后得到功率</p><script type="math/tex; mode=display">S=P+jQ=U_ZI^*=\frac{3025}{12}\sqrt{10}\angle -\varphi \,\,</script><script type="math/tex; mode=display">\Rightarrow P={Re}\left\{ S \right\} =\frac{3025}{12}\sqrt{10}\cos \left( -\varphi \right) =756.25</script>]]></content>
      
      
      <categories>
          
          <category> 试卷解答 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电路理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>补充题目</title>
      <link href="/posts/b7b4c9c7.html"/>
      <url>/posts/b7b4c9c7.html</url>
      
        <content type="html"><![CDATA[<font color=#4A96C9>证明：对于一维粒子，设 $\psi_1(x)$ 和 $\psi_2(x)$ 均为定态方程的属于同一能量 $E$ 的解，则$$\psi_1 \frac{\mathrm{d} \psi_2}{\mathrm{d} x}-\psi_2\frac{\mathrm{d} \psi_1}{\mathrm{d} x}=Const \text{ （与 $x$ 无关）}$$</font><p>按照薛定谔方程，可以得到</p><script type="math/tex; mode=display">\frac{\mathrm{d} ^{2}\psi_1}{\mathrm{d} x^{2}}+\frac{2m}{\hbar^{2}}[E-V(x)]\psi_1=0 \tag{1}</script><script type="math/tex; mode=display">\frac{\mathrm{d} ^{2}\psi_2}{\mathrm{d} x^{2}}+\frac{2m}{\hbar^{2}}[E-V(x)]\psi_2=0 \tag{2}</script><p>由 $\psi_2\times (1)-\psi_1\times (2)$，得到</p><script type="math/tex; mode=display">\psi_2\frac{\mathrm{d} ^{2}\psi_1}{\mathrm{d} x^{2}}-\psi_1\frac{\mathrm{d} ^{2}\psi_2}{\mathrm{d} x^{2}}=0 \Leftrightarrow \frac{\mathrm{d} }{\mathrm{d} x}(\psi_2\frac{\mathrm{d} \psi_1}{\mathrm{d} x}-\psi_1\frac{\mathrm{d} \psi_2}{\mathrm{d} x})=0</script><font color=#4A96C9>证明：一维运动的束缚定态都是不简并的</font><p>设 $\psi_1$ 和 $\psi_2$ 是定态方程属于本征能量 $E$ 的两个束缚态。对于束缚态，当 $x \rightarrow \infty$ 时，有 $\psi_1,\psi_2 \rightarrow 0$，</p><script type="math/tex; mode=display">\therefore \psi_1 \frac{\mathrm{d} \psi_2}{\mathrm{d} x}-\psi_2\frac{\mathrm{d} \psi_1}{\mathrm{d} x}=0</script><p>由上题结论，知各处的波函数都满足上式。则有</p><script type="math/tex; mode=display">\psi_1\frac{\mathrm{d} \psi_2}{\mathrm{d} x}=\psi_2\frac{\mathrm{d} \psi_1}{\mathrm{d} x}</script><p>在 $\psi_1\neq 0$ 且 $\psi_2\neq 0$ 的各处，有</p><script type="math/tex; mode=display">\frac{1}{\psi_1}\frac{\mathrm{d} \psi_1}{\mathrm{d} x}=\frac{1}{\psi_2}\frac{\mathrm{d} \psi_2}{\mathrm{d} x} \Rightarrow \frac{\mathrm{d} }{\mathrm{d} x}(\ln \psi_1)=\frac{\mathrm{d} }{\mathrm{d} x}(\ln \psi_2) \Rightarrow \frac{\mathrm{d} }{\mathrm{d} x}\left( \ln \frac{\psi_2}{\psi_1} \right)=0</script><p>对 $x$ 积分可知，$\displaystyle \ln \left( \frac{\psi_2}{\psi_1} \right) =$ 常数，所以 $\psi_2=c\psi_1$，故 $\psi_1$ 和 $\psi_2$ 代表同一量子态。</p><p>注：对于不规则势，由于存在奇点，此结论不成立</p><font color=#4A96C9>证明：设 $\psi(x)$ 是定态薛定谔方程的一个解，对应的能量本征值为 $E$，则 $\psi^{*}(x)$ 也是方程的一个解，对应的能量也是 $E$。即能量 $E$ 可能是二重简并的。</font><p>定态薛定谔方程为 </p><script type="math/tex; mode=display">\left[ -\frac{\hbar^{2}}{2m}\frac{\mathrm{d}^{2}}{\mathrm{d}x^{2}}+V(x) \right]\psi(x)=E\psi(x)</script><p>对方程两侧取共轭，由于 $E,V$ 都为实数，因此</p><script type="math/tex; mode=display">\left[ -\frac{\hbar^{2}}{2m}\frac{\mathrm{d}^{2}}{\mathrm{d}x^{2}}+V(x) \right]\psi^{*}(x)=E\psi^{*}(x)</script><p>说明 $\psi^{*}$ 也是方程的解，能量本征值还是 $E$。</p><font color=#4A96C9>证明：一维束缚定态的波函数可以取为实函数</font><p>前面证明，一维运动的束缚定态都是不简并的，同时 $\psi(x)$ 和 $\psi^{*}(x)$ 都是能量 $E$ 的本征态，因此需要满足</p><script type="math/tex; mode=display">\psi^{*}(x)=c\psi(x)</script><p>式中 $c$ 为复常数。取复共轭，有</p><script type="math/tex; mode=display">\psi(x)=c^{*}\psi^{*}(x)=\left\vert c \right\vert ^{2}\psi</script><script type="math/tex; mode=display">\therefore \left\vert c \right\vert =1 \Rightarrow c=e^{i\alpha}</script><p>取 $\alpha=0$，则 $\psi(x)=\psi^{*}(x)$，故 $\psi(x)$ 可以取为实函数。</p><font color=#4A96C9>证明：设 $V(x)$ 具有空间反射不变性，$V(-x)=-V(x)$，如 $\psi(x)$ 是定态薛定谔方程的属于能量为 $E$ 的解，则 $\psi(-x)$ 也是方程的相应于能量 $E$ 的解。</font><p>一维定态方程为</p><script type="math/tex; mode=display">-\frac{\hbar^{2}}{2m}\frac{\mathrm{d}^{2}}{\mathrm{d}x^{2}}\psi(x)+V(x)\psi(x)=E\psi(x)</script><p>做空间反射变换，$x \rightarrow -x$，即：</p><script type="math/tex; mode=display">-\frac{\hbar^{2}}{2m}\frac{\mathrm{d}^{2}}{\mathrm{d}(-x)^{2}}\psi(-x)+V(-x)\psi(-x)=E\psi(-x)</script><script type="math/tex; mode=display">\Rightarrow -\frac{\hbar^{2}}{2m}\frac{\mathrm{d}^{2}}{\mathrm{d}x^{2}}\psi(-x)+V(x)\psi(-x)=E\psi(-x)</script><p>故 $\psi(-x)$ 也是能量 $E$ 对应的本征函数。</p><p>（注：这里既可能是简并情况，也可能是 $\psi(x)=c\psi(-x)$，两者是同一个态）</p><font color=#4A96C9>推论：若 $V(x)=-V(x)$，且定态薛定谔方程的解无简并（如处于束缚态），则解必然有确定的宇称</font><p>此时 $\psi(x)$ 和 $\psi(-x)$ 表示同一个态，即</p><script type="math/tex; mode=display">\psi(x)=c\psi(-x)</script><p>引入宇称算符 $\hat{P}$：$\hat{P}f(\vec{r})=f(-\vec{r})$。按照前面的讨论，有</p><script type="math/tex; mode=display">\hat{P}\psi(x)=\psi(-x)=c\psi(x)</script><script type="math/tex; mode=display">\Rightarrow\hat{P}^{2}\psi(x)=c^{2}\psi(x)</script><p>又根据已知</p><script type="math/tex; mode=display">\hat{P}^{2}\psi(x)=\psi(x)</script><p>得到 $c^{2}=1$，$c=\pm 1$。取 $c=1$，为偶宇称；取 $c=-1$，为奇宇称。</p>]]></content>
      
      
      <categories>
          
          <category> 量子力学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双态系统</title>
      <link href="/posts/dacca95a.html"/>
      <url>/posts/dacca95a.html</url>
      
        <content type="html"><![CDATA[<p>双态系统是简单的量子系统<br>氨分子翻转、氢分子离子、磁场中1/2自旋粒子等都是有实际意义的双态系统。<br>一般量子系统不会只有两个能级，不过如果两个能级靠得很近，而离开其它能级又较远，在特定问题中它们与其它能级间的跃迁无需考虑，这种情况也可以视为双态系统。</p><h2 id="能级离散系统中薛定谔方程的矩阵形式"><a href="#能级离散系统中薛定谔方程的矩阵形式" class="headerlink" title="能级离散系统中薛定谔方程的矩阵形式"></a>能级离散系统中薛定谔方程的矩阵形式</h2><h3 id="含时薛定谔方程"><a href="#含时薛定谔方程" class="headerlink" title="含时薛定谔方程"></a>含时薛定谔方程</h3><p>波函数 $\psi(x)$ 可表示为 $|\psi(t)\rang$，称为<strong>态矢量</strong>。取一套完备正交归一函数 $\varphi_{j}(j=1,2,3\cdots )$，表示为 $|j\rang$，称为<strong>基矢</strong>。用基矢展开态矢量，有</p><script type="math/tex; mode=display">|\psi(t)\rang=\sum_{j}C_j|j\rang \quad</script><p>其中 $C_j=\lang j|\psi(t)\rang$，$C_j$ 称为<strong>展开系数</strong>，表示态矢量 $|\psi(t)\rang$ 分解为 $|j\rang$ 的概率幅。</p><p>用态矢量表示薛定谔方程，有</p><script type="math/tex; mode=display">i\hbar \frac{\partial }{\partial t}|\psi(t)\rang=\hat{H}|\psi(t)\rang</script><p>由</p><script type="math/tex; mode=display">|\psi(t)\rang=\sum_{j}C_j|j\rang = \sum_{j}|j\rang C_j = \sum_{j}|j\rang \lang j|\psi(t)\rang</script><p>代入薛定谔方程，得到</p><script type="math/tex; mode=display">i\hbar \frac{\partial }{\partial t}|\psi(t)\rang = \sum_{j}\hat{H}|j\rang \lang j|\psi(t)\rang \xrightarrow{\text{左右同乘 }\lang i|} i\hbar \frac{\partial }{\partial t}\lang i|\psi(t)\rang = \sum_{j}\lang i|\hat{H}|j \rang \lang j|\psi(t) \rang</script><script type="math/tex; mode=display">\Rightarrow i\hbar \frac{\partial }{\partial t}C_i=\sum_{j}H_{ij}C_j</script><p>式中矩阵元 $\displaystyle H<em>{ij}=\lang i|\hat{H}|j\rang=\int \varphi^{*}</em>{i}\hat{H}\varphi_{j}\mathrm{d}x$，同时上式为薛定谔方程在离散能级情况下的形式。</p><p>对于双态系统，态空间是二维的，所以只有两个基。薛定谔方程的矩阵形式为：</p><script type="math/tex; mode=display">i\hbar \frac{\partial }{\partial t}\begin{pmatrix} C_1 \\C_2     \end{pmatrix} =\begin{pmatrix}     H_{11}&H_{12}\\    H_{21}&H_{22} \end{pmatrix} \begin{pmatrix}     C_1\\    C_2 \end{pmatrix}</script><p>此处哈密顿算符变成<strong>哈密顿矩阵</strong>。</p><h3 id="定态薛定谔方程"><a href="#定态薛定谔方程" class="headerlink" title="定态薛定谔方程"></a>定态薛定谔方程</h3><script type="math/tex; mode=display">\begin{pmatrix}     H_{11}&H_{12}\\    H_{21}&H_{22} \end{pmatrix} \begin{pmatrix}     C_1'\\    C_2' \end{pmatrix} =E\begin{pmatrix}     C_1'\\    C_2' \end{pmatrix}</script><p>其中 $E$ 为本征值，$\begin{pmatrix} C_1’\C_2’ \end{pmatrix}$ 为本征矢。</p><p>若取哈密顿算符的本征态为基，记为 $|\beta\rang(\beta=\mathrm{I},\mathrm{II})$，有</p><script type="math/tex; mode=display">\hat{H}|\mathrm{I}\rang =E_{\mathrm{I}}|\mathrm{I}\rang\\\hat{H}|\mathrm{II}\rang = E_{\mathrm{II}}|\mathrm{II}\rang</script><p>矩阵元 $H<em>{\alpha \beta}=\lang \alpha|\hat{H}|\beta\rang=E</em>{\alpha}\delta_{\alpha\beta}$，可以看出此时哈密顿矩阵是对角的。</p><script type="math/tex; mode=display">\begin{pmatrix} H_{\mathrm{I\ I}}&H_{\mathrm{I\ II}}\\H_{\mathrm{II\ I}}&H_{\mathrm{II\ II}}\end{pmatrix} =\begin{pmatrix}     E_{\mathrm{I}} &0\\    0&E_{\mathrm{II}}\end{pmatrix}</script><p>此时定态薛定谔方程的形式为</p><script type="math/tex; mode=display">\begin{pmatrix}     E_{\mathrm{I}} &0\\    0&E_{\mathrm{II}}\end{pmatrix} \begin{pmatrix}     C_1'\\C_2' \end{pmatrix} =E\begin{pmatrix}     C_1'\\C_2' \end{pmatrix}</script><p>可以得到能量本征值为 $E<em>{\alpha}(\alpha=\mathrm{I,II})$，$E</em>{\mathrm{I}}$ 对应本征矢 $\begin{pmatrix} C<em>{\mathrm{I}}’\ C</em>{\mathrm{II}}’ \end{pmatrix} =\begin{pmatrix} 1\0 \end{pmatrix} =|\mathrm{I}\rang$，$E<em>{\mathrm{II}}$ 对应本征矢 $\begin{pmatrix} C</em>{\mathrm{I}}’\ C_{\mathrm{II}}’ \end{pmatrix} =\begin{pmatrix} 0\1 \end{pmatrix} =|\mathrm{II}\rang$</p><h2 id="氨分子"><a href="#氨分子" class="headerlink" title="氨分子"></a>氨分子</h2><p>对于一个氨分子，其N原子有一个镜像对称位置，对应的量子态分别为 $|1\rang$ 和 $|2\rang$，其他自由度不计。若将 $|1\rang$ 和 $|2\rang$ 取为基，那么任意时刻分子的状态 $|\psi\rang =|1\rang \lang 1|\psi\rang+|2\rang \lang 2|\psi\rang\equiv |1\rang C_1+|2\rang C_2$</p><h3 id="假设情况"><a href="#假设情况" class="headerlink" title="假设情况"></a>假设情况</h3><p>首先考虑一种特殊情况，即假如系统一开始处于态 $|1\rang$，以后不再有机会进入态 $|2\rang$，反之亦然。那么考虑到非对角元会引起两个态之间的跃迁，则 $H<em>{12}=0,H</em>{21}=0$。由薛定谔方程的矩阵形式</p><script type="math/tex; mode=display">i\hbar \frac{\partial }{\partial t}\begin{pmatrix} C_1 \\ C_2     \end{pmatrix} =\begin{pmatrix}     H_{11}&H_{12}\\    H_{21}&H_{22} \end{pmatrix} \begin{pmatrix}     C_1\\ C_2 \end{pmatrix}</script><p>可以得到</p><script type="math/tex; mode=display">i\hbar \frac{\partial C_1}{\partial t}=H_{11}C_1 \Rightarrow C_1(t)=C_1(0)e^{-iH_{11}t /\hbar}\\ \quad \\i\hbar \frac{\partial C_2}{\partial t}=H_{22}C_2 \Rightarrow C_2(t)=C_2(0)e^{-iH_{22}t /\hbar}</script><p>$C<em>1(t)$ 和 $C_2(t)$ 为氨分子处于 $E_1=H</em>{11},E<em>2=H</em>{22}$ 定态的概率幅。再由对称性，$H<em>{11}=H</em>{22}=E_0$。</p><h3 id="真实情况"><a href="#真实情况" class="headerlink" title="真实情况"></a>真实情况</h3><p>但这并非氨分子的实际行为。氨分子中的N原子可以通过隧道效应在 $|1\rang,|2\rang$ 态之间穿越。此时则假设矩阵元 $H<em>{12}=H</em>{21}=A\neq 0(A&lt;0)$，则薛定谔方程为</p><script type="math/tex; mode=display">i\hbar \frac{\partial }{\partial t}\begin{pmatrix} C_1 \\ C_2     \end{pmatrix} =\begin{pmatrix}     E_0&A\\ A&E_0\end{pmatrix} \begin{pmatrix}     C_1\\ C_2 \end{pmatrix}</script><p>通过一些数学上的技巧，可以解得</p><script type="math/tex; mode=display">C_1(t)=\frac{a}{2}e^{-i(E_0+A)t /\hbar}+\frac{b}{2}e^{-i(E_0-A)t/\hbar}\\ \quad\\C_2(t)=\frac{a}{2}e^{-i(E_0+A)t /\hbar}-\frac{b}{2}e^{-i(E_0-A)t/\hbar}\\</script><p>式中 $a,b$ 为待定常量。而氨分子波函数 $|\psi\rang =C_1|1\rang+C_2|2\rang$。</p><p>若 $b=0$，则两项具有相同的频率 $\omega=(E<em>0+A) /\hbar$，具有相同的概率幅 $\displaystyle C_1=C_2=\frac{a}{2}e^{-i(E_0+A)t /\hbar}$。那么此时分子具有确定的能量 $E</em>{\mathrm{I}}=E_0+A$，分子处于定态。定态的态矢量为</p><script type="math/tex; mode=display">|\psi_{\mathrm{I}}(t)\rang =\frac{1}{\sqrt{2}}(|1\rang +|2\rang)e^{-i(E_0+A)t /\hbar}</script><p>态矢量通常又用与时间无关的态矢量来表示</p><script type="math/tex; mode=display">|\mathrm{I}\rang =\frac{1}{\sqrt{2}}(|1\rang+|2\rang)</script><p>该态矢量也记为 $|+\rang$。同时可以看出，这就是 $\hat{H}$ 的本征态， $\hat{H}|\mathrm{I}\rang=E_{\mathrm{I}}|\mathrm{I}\rang$。</p><p>若 $a=0$，和上方类似的，我们可以得到 $C_1=-C_2=\displaystyle \frac{b}{2}e^{-i(E_0-A)t /\hbar}$，表示N原子“在上”或者“在下”具有相反的概率幅。分子处于定态态矢量为</p><script type="math/tex; mode=display">|\psi_{\mathrm{II}}(t)\rang =\frac{1}{\sqrt{2}}(|1\rang -|2\rang)e^{-i(E_0-A)t /\hbar}</script><script type="math/tex; mode=display">|\mathrm{II}\rang =\frac{1}{\sqrt{2}}(|1\rang-|2\rang)</script><p>该态矢量记为 $|-\rang$，也是 $\hat{H}$ 的本征态，$\hat{H}|\mathrm{II}\rang=E_{\mathrm{II}}|\mathrm{II}\rang$</p><p>如果从定态薛定谔方程讨论</p><script type="math/tex; mode=display">\begin{pmatrix}     E_0&A\\ A &E_0\end{pmatrix} \begin{pmatrix}     x_1\\ x_2 \end{pmatrix} =\begin{pmatrix}     x_1\\ x_2 \end{pmatrix}</script><p>同样可以求得能量本征值与本征矢。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>如果 $t=0$ 时刻，分子处于态 $|1\rang$，则 $C_1(0)=1,C_2(0)=0 \Rightarrow a=b=1$，解得</p><script type="math/tex; mode=display">C_1(t)=e^{-iE_0t /\hbar}\cos \frac{At}{\hbar}\\ \quad \\C_2(t)=-e^{-iE_0t /\hbar}\sin \frac{At}{\hbar}</script><p>此时系统能量不确定。同时波函数为两个振动的叠加，会出现拍的现象。在 $t$ 时刻，分子处于态 $|1\rang,|2\rang$ 的概率分别为</p><script type="math/tex; mode=display">P_1=\left\vert C_1(t) \right\vert ^{2}=\cos ^{2}\frac{At}{\hbar}\quad P_2=\left\vert C_2(t) \right\vert ^{2}=\sin ^{2}\frac{At}{\hbar}</script><p>量子与经典的重要区别：统一的能级分裂为二，分裂为两个定态 $(E_0\rightarrow E_0\pm A)$。这就是能量的翻转分裂。同时从实验数据可知，$A$ 非常小，因此能极差也非常小。激发氨分子能级翻转仅需要微波提供的能量。</p>]]></content>
      
      
      <categories>
          
          <category> 量子力学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Makefile编写</title>
      <link href="/posts/f353ec85.html"/>
      <url>/posts/f353ec85.html</url>
      
        <content type="html"><![CDATA[<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-Wall</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o</span><br><span class="line">rm -rf fcfs</span><br><span class="line">rm -rf sjf</span><br><span class="line">rm -rf rr</span><br><span class="line">rm -rf priority</span><br><span class="line">rm -rf priority_rr</span><br><span class="line"></span><br><span class="line"><span class="section">rr: driver.o list.o CPU.o schedule_rr.o</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o rr driver.o schedule_rr.o list.o CPU.o</span><br><span class="line"></span><br><span class="line"><span class="section">sjf: driver.o list.o CPU.o schedule_sjf.o</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o sjf driver.o schedule_sjf.o list.o CPU.o</span><br><span class="line"></span><br><span class="line"><span class="section">fcfs: driver.o list.o CPU.o schedule_fcfs.o</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o fcfs driver.o schedule_fcfs.o list.o CPU.o</span><br><span class="line"></span><br><span class="line"><span class="section">priority: driver.o list.o CPU.o schedule_priority.o</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o priority driver.o schedule_priority.o list.o CPU.o</span><br><span class="line"></span><br><span class="line"><span class="section">schedule_fcfs.o: schedule_fcfs.c</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c schedule_fcfs.c</span><br><span class="line"></span><br><span class="line"><span class="section">priority_rr: driver.o list.o CPU.o schedule_priority_rr.o</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o priority_rr driver.o schedule_priority_rr.o list.o CPU.o</span><br><span class="line"></span><br><span class="line"><span class="section">driver.o: driver.c</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c driver.c</span><br><span class="line"></span><br><span class="line"><span class="section">schedule_sjf.o: schedule_sjf.c</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c schedule_sjf.c</span><br><span class="line"></span><br><span class="line"><span class="section">schedule_priority.o: schedule_priority.c</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c schedule_priority.c</span><br><span class="line"></span><br><span class="line"><span class="section">schedule_rr.o: schedule_rr.c</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c schedule_rr.c</span><br><span class="line"></span><br><span class="line"><span class="section">list.o: list.c list.h</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c list.c</span><br><span class="line"></span><br><span class="line"><span class="section">CPU.o: CPU.c cpu.h</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c CPU.c</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-Wall</span><br></pre></td></tr></table></figure><p>这两行代码定义了变量 <code>CC</code> 和 <code>CFLAGS</code>。</p><ul><li><code>CC=gcc</code>：定义变量 <code>CC</code> 为 gcc，指定使用 gcc 编译器进行编译。<br><code>CFLAGS=-Wall</code>：定义变量 <code>CFLAGS</code> 为 <code>-Wall</code>，指定编译时使用的选项，其中 <code>-Wall</code> 表示显示所有警告信息。</li></ul><h3 id="Makefile执行规则"><a href="#Makefile执行规则" class="headerlink" title="Makefile执行规则"></a>Makefile执行规则</h3><p>对于<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">rr: driver.o list.o CPU.o schedule_rr.o</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o rr driver.o schedule_rr.o list.o CPU.o</span><br></pre></td></tr></table></figure></p><p>开头的 <code>rr</code> 表示后面的命令行代码可以用 <code>make rr</code> 来执行。而 <code>rr</code> 后面的 <code>driver.o list.o CPU.o schedule_rr.o</code> 指的是<strong>文件依赖项</strong>，文件依赖项的作用在于，在执行下面的编译命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -o rr driver.o schedule_rr.o list.o CPU.o</span><br></pre></td></tr></table></figure></p><p>时，假如编译器发现找不到 <code>schedule_rr.o</code> 文件，那么它会找到 Makefile 中的这一行代码<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">schedule_rr.o: schedule_rr.c</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c schedule_rr.c</span><br></pre></td></tr></table></figure></p><p>先生成 <code>schedule_rr.o</code> 文件后再继续执行。</p><h3 id="文件依赖项作用"><a href="#文件依赖项作用" class="headerlink" title="文件依赖项作用"></a>文件依赖项作用</h3><ul><li>构建顺序控制：依赖项指定了目标构建所依赖的文件或目标。如果依赖项中的文件发生变化或不存在，则目标会被重新构建。依赖项的存在可以确保在构建目标之前先构建其所依赖的文件或目标。</li><li>增量构建优化，避免重复构建：依赖项允许 make 工具进行增量构建优化。只有发生变化的文件及其相关依赖项会被重新构建，而不需要重新构建所有目标。这样可以提高构建效率。</li></ul><h3 id="头文件的依赖关系"><a href="#头文件的依赖关系" class="headerlink" title="头文件的依赖关系"></a>头文件的依赖关系</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">list.o: list.c list.h</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c list.c</span><br></pre></td></tr></table></figure><p>这段代码中只指明了 <code>list.o</code> 和 <code>list.h</code> 之间的依赖关系，而事实上 <code>list.c</code> 文件中还用到了头文件 <code>task.h</code>。这样可行是因为 Makefile 文件其实并不需要显式的包含源文件和头文件的依赖关系，这个关系在编译的时候会自动读取。所以将 <code>list.o</code> 后面的 <code>list.h</code> 去掉也是可行的。</p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj-m += seconds.o jiffies.o</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(<span class="built_in">shell</span> pwd)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(<span class="built_in">shell</span> pwd)</span> clean</span><br></pre></td></tr></table></figure><h3 id="目标文件选择"><a href="#目标文件选择" class="headerlink" title="目标文件选择"></a>目标文件选择</h3><p><code>obj-m += seconds.o jiffies.o</code> 指要构建的目标文件为 <code>seconds.o</code> 和 <code>jiffies.o</code>，最后将构建名为 <code>seconds</code> 和 <code>jiffies</code> 的模块。</p><h3 id="Makefile执行规则-1"><a href="#Makefile执行规则-1" class="headerlink" title="Makefile执行规则"></a>Makefile执行规则</h3><p>对于<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(<span class="built_in">shell</span> pwd)</span> modules</span><br></pre></td></tr></table></figure></p><p>开头的 <code>all</code> 表示后面的命令行代码可以用 <code>make</code> 来执行。接下来对后面的命令行进行解释：</p><ul><li>这里直接使用的是 <code>make</code> 命令而非之前那样的 <code>gcc</code>，这是因为这是因为构建 Linux 内核模块的过程通常不仅仅涉及到 C 代码的编译，还包括了其他的操作，例如链接、处理符号表、生成模块文件等。这些操作超出了单纯的 C 代码编译所需的步骤。因此，在构建内核模块时，<code>make</code> 命令会负责执行整个构建过程，其中也包含了调用 <code>gcc</code>。</li><li>后面的 <code>-C /lib/modules/$(shell uname -r)/build</code> 表示指定工作目录。如果不这么做，会导致工作目录不正确，<code>make</code> 无法找到正确的库来编译生成模块。</li><li><code>M</code> 参数用于指定内核模块构建过程中的路径，这里 <code>M=$(shell pwd)</code> 指指定构建过程中的路径为当前工作目录。如果不这样做同样可以生成模块（因为上一步已经进入了正确的工作目录），但是从实践来看会出现一些权限上的问题，需要使用 <code>sudo make</code> 才能正常生成内核模块。</li><li>最后的 <code>modules</code> 是 <code>make</code> 命令的目标，表示要构建的目标是内核模块。</li></ul><h3 id="obj-m"><a href="#obj-m" class="headerlink" title="obj-m"></a>obj-m</h3><p>在示例1中，我们的 Makefile 文件并没有用到 <code>obj-m</code>，这是因为 <code>obj-m</code> 是用于编译内核模块的特定变量，而在编译普通的用户空间程序时不会被用到。</p><p>在编写一个内核模块时，我们需要使用 <code>obj-m</code> 变量来定义的模块对象（.o 文件），以便在构建过程中让 <code>make</code> 工具会编译和链接相应的内核模块。<br>对于普通的用户空间程序，我们可以直接在 Makefile 中指定你的源文件和目标文件，而无需使用 <code>obj-m</code> 变量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Makefile </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>氢原子问题</title>
      <link href="/posts/f2521a3c.html"/>
      <url>/posts/f2521a3c.html</url>
      
        <content type="html"><![CDATA[<h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><h3 id="定态薛定谔方程"><a href="#定态薛定谔方程" class="headerlink" title="定态薛定谔方程"></a>定态薛定谔方程</h3><script type="math/tex; mode=display">[-\frac{\hbar^{2}}{2m}\nabla ^{2}+U(r)]\psi=E\psi</script><p>其中 </p><script type="math/tex; mode=display">U(r)=-\frac{e^{2}}{4\pi \varepsilon_0 r}</script><ul><li>在直角坐标中<script type="math/tex; mode=display">\left[-\frac{\hbar^{2}}{2 m}\left(\frac{\partial^{2}}{\partial x^{2}}+\frac{\partial^{2}}{\partial y^{2}}+\frac{\partial^{2}}{\partial z^{2}}\right)+U(r)\right] \psi=E \psi \quad(r=\sqrt{x^{2}+y^{2}+z^{2}})</script></li><li>在球坐标系中<script type="math/tex; mode=display">\nabla^{2}=\frac{1}{r^{2}} \frac{\partial}{\partial r}\left(r^{2} \frac{\partial}{\partial r}\right)+\frac{1}{r^{2} \sin \theta} \frac{\partial}{\partial \theta}\left(\sin \theta \frac{\partial}{\partial \theta}\right)+\frac{1}{r^{2} \sin ^{2} \theta} \frac{\partial^{2}}{\partial \varphi^{2}}=\frac{1}{r^{2}} \frac{\partial}{\partial r}\left(r^{2} \frac{\partial}{\partial r}\right)-\frac{1}{r^{2}} \frac{\hat{L}^{2}}{\hbar^{2}}</script></li></ul><p>其中 $\hat{L}^{2}$ 是角动量平方算符。</p><script type="math/tex; mode=display">\hat{L}^{2}=-\hbar^{2}\left[ \frac{1}{\sin \theta}\frac{\partial }{\partial \theta}\left( \sin \theta \frac{\partial }{\partial \theta} \right) +\frac{1}{\sin ^{2} \theta}\frac{\partial ^{2}}{\partial \varphi^{2}} \right]</script><p>故最终得到球坐标系下的定态薛定谔方程为</p><script type="math/tex; mode=display">\left(-\frac{\hbar^{2}}{2 m r^{2}} \frac{\partial}{\partial r}\left(r^{2} \frac{\partial}{\partial r}\right)-\frac{e^{2}}{4 \pi \varepsilon_{0} r}\right) \psi+\frac{\hat{L}^{2}}{2 m r^{2}} \psi=E \psi</script><h3 id="分离变量"><a href="#分离变量" class="headerlink" title="分离变量"></a>分离变量</h3><p>设 $\psi=R(r)Y(\theta,\varphi)$，代入，得到</p><script type="math/tex; mode=display">\Rightarrow \frac{1}{R}\left(-\frac{\hbar^{2}}{2 m r^{2}} \frac{\partial}{\partial r}\left(r^{2} \frac{\partial}{\partial r}\right)-\frac{e^{2}}{4 \pi \varepsilon_{0} r}\right) R+\frac{1}{Y} \frac{\hat{L}^{2} Y}{2 m r^{2}}=E</script><p>然后再经过移项，把含有相同自变量的项移到同一边</p><script type="math/tex; mode=display">2 m r^{2} E-\frac{2 m r^{2}}{R}\left(-\frac{\hbar^{2}}{2 m r^{2}} \frac{\partial}{\partial r}\left(r^{2} \frac{\partial}{\partial r}\right)-\frac{e^{2}}{4 \pi \varepsilon_{0} r}\right) R=\frac{\hat{L}^{2} Y}{Y} \equiv C</script><p>对于</p><script type="math/tex; mode=display">\frac{\hat{L}^{2} Y}{Y} = C \Rightarrow \hat{L}^{2}Y=CY</script><p>可以看出是 $\hat{L}^{2}$ 的本征方程，同时考虑到 $Y$ 是关于 $\theta,\varphi$ 的函数，那么本征函数应当是球谐函数。即</p><script type="math/tex; mode=display">\hat{L}^{2}Y_{lm}(\theta,\varphi)=l(l+1)\hbar^{2}Y_{l m}(\theta,\varphi)</script><p>得到本征值为 $l(l+1)\hbar^{2}=L^{2}$，$L=\sqrt{l(l+1)}\hbar$ 为角动量大小。</p><p>然后还要求解径向方程</p><script type="math/tex; mode=display">\left(\frac{\partial}{\partial r}\left(r^{2} \frac{\partial}{\partial r}\right)+\frac{2 m r^{2}}{\hbar^{2}}\left(E+\frac{e^{2}}{4 \pi \varepsilon_{0} r}\right)-l(l+1)\right) R(r)=0</script><p>可以最终得到能量本征值 $E<em>n$ 和 $R</em>{nl}(r)$。</p><h2 id="能量量子化"><a href="#能量量子化" class="headerlink" title="能量量子化"></a>能量量子化</h2><p>通过求解径向方程，利用波函数的有限性条件：$r\rightarrow 0$ 时 $R(r)$ 有限，$r \rightarrow \infty$ 时 $R\rightarrow 0(E&lt;0)$，最终可以解得当粒子能量小于零的情况下（束缚态），仅当粒子能量 $E_n$ 取分立值时，波函数才满足上述要求。并且得到</p><script type="math/tex; mode=display">E_n=-\frac{me^{4}}{32\pi^{2}\varepsilon_0^{2}\hbar^{2}}\frac{1}{n^{2}}\thickapprox -13.6 \frac{1}{n^{2}}eV \quad n=1,2,3\cdots</script><p>符合实验结果。</p><p>当 $n=1,2,3$ 时的 $R_{nl}$(径向波函数)：</p><script type="math/tex; mode=display">\begin{array}{ll}\displaystyle R_{10}=\frac{2}{a^{3 / 2}} e^{-r / a} &\displaystyle  R_{30}=\frac{2}{3 \sqrt{3} a^{3 / 2}}\left(1-\frac{2 r}{3 a}+\frac{2}{27}\left(\frac{r}{a}\right)^{2}\right) e^{-r / 3 a} \\\quad \\\displaystyle R_{20}=\frac{1}{\sqrt{2} a^{3 / 2}}\left(1-\frac{r}{2 a}\right) e^{-r / 2 a} & \displaystyle R_{31}=\frac{8}{27 \sqrt{6} a^{3 / 2}}\left(1-\frac{r}{6 a}\right) e^{-r / 3 a} \cdot\left(\frac{r}{a}\right) \\ \quad \\\displaystyle R_{21}=\frac{1}{2 \sqrt{6} a^{3 / 2}} \frac{r}{a} e^{-r / 2 a} &\displaystyle  R_{32}=\frac{4}{81 \sqrt{30} a^{3 / 2}}\left(\frac{r}{a}\right)^{2} e^{-r / 3 a}\end{array}</script><p>其中 $\displaystyle a=\frac{\varepsilon_0\hbar}{\pi m e^{2}}\thickapprox 0.05nm$，称为波尔半径。</p><h2 id="电子轨道角动量量子化"><a href="#电子轨道角动量量子化" class="headerlink" title="电子轨道角动量量子化"></a>电子轨道角动量量子化</h2><p>通过求解薛定谔方程可以得到 $L=\sqrt{l(l+1)}\hbar$，而角量子数 $l$ 受主量子数 $n$ 限制，$l$ 的取值只能为 $0,1,2,3 \cdots  n-1$，对应的符号为 $s,p,d,f\cdots$。</p><p>回忆波尔理论，$L=n\hbar$，由此处可以知道波尔的假设是错误的，但是最终却能得到氢原子能级的正确的结果，这是因为氢原子的轨道假设同样是错误的，两个错误最终得到了正确的结果。</p><p>对于角动量在 $z$ 方向的分量(此处 $z$ 方向为外加磁场方向)，$L_z=m\hbar$，其中 $m=0,\pm 1,\pm 2\cdots \pm l$，为磁量子数，与原子光谱在外磁场中发生的分裂有关。在角动量 $L$ 大小一定的情况下 $L_z$ 取确定值，这体现了<strong>角动量空间取向量子化</strong>。</p><h3 id="Zeeman-效应"><a href="#Zeeman-效应" class="headerlink" title="Zeeman 效应"></a>Zeeman 效应</h3><p>Zeeman效应指的是在磁场作用下氢原子从第一激发态向基态跃迁时光谱谱线一分为三。这与磁矩和外磁场相互作用有关。</p><p>电子磁矩与角动量关系为 $\displaystyle \vec{M}=-\frac{e}{2m}\vec{L}$，因此磁场与电子磁矩相互作用能为 </p><script type="math/tex; mode=display">W=-\vec{M}\cdot \vec{B}=-M_zB=\frac{e}{2m}L_zB=\frac{e}{2m}m\hbar B=\begin{cases}    \displaystyle \frac{e}{2m}\hbar B &m=1\\    0 &m=0\\    \displaystyle -\frac{e}{2m}\hbar B &m=-1\end{cases}</script><p>这几个相互作用能叠加在第一激发态的能量上，导致最后跃迁释放的能量有三个值，即能量分裂成三条。</p><h2 id="氢原子定态波函数"><a href="#氢原子定态波函数" class="headerlink" title="氢原子定态波函数"></a>氢原子定态波函数</h2><script type="math/tex; mode=display">\psi_{nlm}(r,\theta,\varphi)=R_{nl}(r)Y_{l m}(\theta,\varphi)</script><p>该波函数为 $(\hat{H},\hat{L}^{2},\hat{L}_z)$ 三个算符共同的本征函数。</p><h3 id="沿径向概率密度"><a href="#沿径向概率密度" class="headerlink" title="沿径向概率密度"></a>沿径向概率密度</h3><script type="math/tex; mode=display">\left\vert \psi(r,\theta,\varphi) \right\vert ^{2}\mathrm{d}V=\left\vert R_{nl}(t) \right\vert ^{2}\left\vert Y_{l m}(\theta,\varphi) \right\vert ^{2}r^{2}\mathrm{d}r\sin \theta \mathrm{d}\theta \mathrm{d}\varphi</script><script type="math/tex; mode=display">\Rightarrow W_{nl}(r)\mathrm{d}r=\left[ \int\left\vert Y_{lm}(\theta,\varphi) \right\vert^{2} \mathrm{d}\Omega \right]\left\vert R_{nl}(r) \right\vert^{2} r^{2}\mathrm{d}r=\left\vert R_{nl}(r) \right\vert^{2} r^{2}\mathrm{d}r</script><p>得到电子沿径向概率密度为 $W<em>{nl}(r)=\left\vert R</em>{nl}(r) \right\vert^{2} r^{2}$</p><div align=center><img src="../../figure/氢原子问题/径向概率密度.png" width=1000></div><h3 id="立体角元概率密度"><a href="#立体角元概率密度" class="headerlink" title="立体角元概率密度"></a>立体角元概率密度</h3><script type="math/tex; mode=display">W_{l m}(\theta,\varphi)\mathrm{d}\Omega=\left[ \int_{0}^{\infty}\left\vert R_{nl}(r) \right\vert^{2} r^{2}\mathrm{d}r \right] \left\vert Y_{lm}(\theta,\varphi) \right\vert^{2} \mathrm{d}\Omega=\left\vert Y_{lm}(\theta,\varphi) \right\vert^{2} \mathrm{d}\Omega</script><p>得到电子在立体角元的概率密度为 $W<em>{l m}(\theta,\varphi)=\left\vert Y</em>{l m}(\theta,\varphi) \right\vert ^{2}$</p><h2 id="电子自旋角动量及其空间量子化"><a href="#电子自旋角动量及其空间量子化" class="headerlink" title="电子自旋角动量及其空间量子化"></a>电子自旋角动量及其空间量子化</h2><p>这一点无法从薛定谔方程中得出，而是从实验中推出的。</p><h3 id="斯特恩——盖拉赫实验"><a href="#斯特恩——盖拉赫实验" class="headerlink" title="斯特恩——盖拉赫实验"></a>斯特恩——盖拉赫实验</h3><p>一束银原子通过非匀强磁场。考虑到银原子与磁场相互作用能 $W=-\vec{M}\cdot \vec{B}$，$\displaystyle \therefore F_z=\frac{\partial W}{\partial z}=M_z\frac{\partial B}{\partial z}$，银原子 $z$ 方向的受力情况与其磁矩的 $z$ 分量 $M_z$ 有关。</p><p>银原子核外电子排布式为 $Ag(Z=47) \quad 1s^{2}2s^{2}2p^{6}3s^{2}3p^{6}3d^{10}4s^{2}4p^{6}4d^{10}5s^{1}$，内层电子 $z$ 方向的角动量、磁矩矢量和为 $0$，最外层只有一个 $5s$ 电子，$l=0$。故银原子应不受 $z$ 方向的力，不偏转。但实际情况是，银原子束通过非均匀的磁场时，分裂成了两束。由此推测，电子还具有其他自由度。</p><h4 id="实验意义"><a href="#实验意义" class="headerlink" title="实验意义"></a>实验意义</h4><ul><li><em>进一步说明了空间量子化的存在</em>。因为原子沉积层不是连续一片，而是分开的线，说明角动量空间量子化的存在。</li><li><em>发现了新的矛盾</em>。揭示了原有理论的不足。</li><li><em>提供了原子的“态分离”技术</em>。（指的就是像实验中将银原子分成两半）</li></ul><h3 id="理论解释"><a href="#理论解释" class="headerlink" title="理论解释"></a>理论解释</h3><p>乌伦贝克和古兹密特提出假设：电子不是质点，有固定的自旋角动量 $\vec{S}$ 和相应的自旋磁矩 $\vec{\mu}_{S}$，电子带负电，磁矩的方向和自旋的方向应相反。相对于外磁场方向 $z$，$\vec{S}$ 有向上和向下两种取法。</p><p>自旋虽然不能用经典的图像来理解，但仍然和角动量有关。自旋角动量无经典对应，是一种相对论效应。电子自旋是一种 “内禀” 运动，不是小球自转。</p><p>类比轨道角动量的量子化，可给出自旋角动量的量子化：<br>自旋角动量有：$S=\sqrt{s(s+1)}\hbar$，$S<em>z=m</em>{S}\hbar$，其中 $s$ 是自旋量子数，$m<em>{S}$ 是自旋磁量子数。类似 $m</em>{l}$ 有 $2l+1$ 种取法，$m_{S}$ 应有 $2s+1$ 种取法。</p><p>根据施 — 盖实验，最后银原子分成两条线，因此电子自旋磁量子数共有两种取法：</p><script type="math/tex; mode=display">2s+1=2\Rightarrow s=\frac{1}{2},\quad m_{S}=\pm \frac{1}{2}</script><p>进而得到</p><script type="math/tex; mode=display">S=\sqrt{s(s+1)}\hbar = \frac{\sqrt{3}}{2}\hbar,\quad S_z=m_{S}\hbar=\pm \frac{1}{2}\hbar</script><p>经过测量和计算（根据施 — 盖实验得到的数据），银原子（电子自旋）磁矩大小为</p><script type="math/tex; mode=display">\vec{M}_s=-\frac{e}{m}\vec{S}</script><p>不同于轨道角动量与轨道磁矩的关系</p><script type="math/tex; mode=display">\vec{M}=-\frac{e}{2m}\vec{L}</script><h3 id="泡利不相容原理"><a href="#泡利不相容原理" class="headerlink" title="泡利不相容原理"></a>泡利不相容原理</h3><ul><li>费米子：自旋量子数为半奇数的粒子</li><li><p>玻色子：自旋量子数为整数的粒子</p></li><li><p><strong>泡利不相容原理</strong>：不能有两个电子具有相同的 $n,l,m_l,m_s$</p></li><li><strong>玻色凝聚</strong>：玻色子不受泡利不相容原理的限制，一个单粒子态可容纳多个玻色子</li></ul>]]></content>
      
      
      <categories>
          
          <category> 量子力学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>谐振子</title>
      <link href="/posts/bb557832.html"/>
      <url>/posts/bb557832.html</url>
      
        <content type="html"><![CDATA[<h2 id="波函数求解"><a href="#波函数求解" class="headerlink" title="波函数求解"></a>波函数求解</h2><h3 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h3><p>一维线性谐振子势能为 $\displaystyle U(x)=\frac{1}{2}kx^{2}=\frac{1}{2}m\omega^{2}x^{2}$，其中 $\displaystyle \omega=\sqrt{\frac{k}{m}}$</p><p>由定态薛定谔方程 </p><script type="math/tex; mode=display">E\phi=\hat{H}\phi=(-\frac{\hbar^{2}}{2m}\frac{\partial ^{2}}{\partial x^{2}}+U(x))\phi</script><p>得到</p><script type="math/tex; mode=display">\frac{\partial ^{2}\phi}{\partial x^{2}} + \frac{2m}{\hbar^{2}}(E-\frac{1}{2}m\omega^{2}x^{2})\phi=0</script><h3 id="无量纲常数引入"><a href="#无量纲常数引入" class="headerlink" title="无量纲常数引入"></a>无量纲常数引入</h3><p>将方程写为</p><script type="math/tex; mode=display">\frac{\hbar}{m\omega}\frac{\partial ^{2}\phi}{\partial x^{2}}+(\frac{2E}{\hbar \omega}-\frac{m \omega}{\hbar}x^{2})\phi=0</script><p>看出可以引入无量纲常量 $\displaystyle \lambda=\frac{2E}{\hbar \omega}$ 与变量 $\displaystyle \xi=\sqrt{\frac{m\omega}{\hbar}}x$，方程可以重新写为</p><script type="math/tex; mode=display">\frac{\partial ^{2}\phi}{\partial \xi^{2}}+(\lambda-\xi^{2})\phi=0</script><h3 id="解的渐进行为"><a href="#解的渐进行为" class="headerlink" title="解的渐进行为"></a>解的渐进行为</h3><p>研究解的渐进行为</p><script type="math/tex; mode=display">\left\vert x \right\vert \rightarrow \infty \Rightarrow \left\vert \xi \right\vert \to \infty  \Rightarrow \frac{\partial ^{2}\phi}{\partial \xi^{2}}-\xi^{2}\phi=0</script><p>方程解为 $\displaystyle \phi \sim e^{\pm \frac{\xi^{2}}{2}}$，但考虑到波函数不应该发散，因此 $\phi \sim e^{-\frac{\xi^{2}}{2}}$</p><p>令 $\phi(\xi)=e^{-\frac{\xi^{2}}{2}}u(\xi)$，得到<strong>厄密微分方程</strong></p><script type="math/tex; mode=display">\frac{\partial ^{2}u}{\partial \xi^{2}}-2\xi \frac{\partial u}{\partial \xi}+(\lambda-1)u=0</script><h3 id="幂级数展开求解"><a href="#幂级数展开求解" class="headerlink" title="幂级数展开求解"></a>幂级数展开求解</h3><p>设 $\displaystyle u(\xi)=\sum<em>{k=0}^{\infty}c_k\xi^{k}$，$\displaystyle u’(\xi)=\sum</em>{k=1}^{\infty}c<em>k k \xi^{k-1}$，$\displaystyle u’’(\xi)=\sum</em>{k=2}^{\infty}c_k k(k-1)\xi^{k-2}$，代入方程，得到</p><script type="math/tex; mode=display">\sum_{k=2}^{\infty}c_k k(k-1)\xi^{k-2}-2\sum_{k=1}^{\infty}c_k k \xi^{k}+(\lambda-1)\sum_{k=0}^{\infty}c_k \xi^{k}=0</script><p>考虑 $j$ 次幂 $\xi^{j}$ 系数</p><script type="math/tex; mode=display">c_{j+2}(j+2)(j+1)-2c_{j}j+(\lambda-1)c_j=0</script><p>由此我们得到了递推关系</p><script type="math/tex; mode=display">c_{j+2}=\frac{2j-(\lambda-1)}{(j+2)(j+1)}c_j \tag{1}</script><p>于是所有偶次幂系数都可以用 $c_0$ 表示，所有奇次幂系数都可以用 $c_1$ 表示，且 $c_0$ 和 $c_1$ 任意取值。由此方程有两个线性无关的解</p><script type="math/tex; mode=display">\begin{aligned}u_1(\xi)=c_0+c_2\xi^{2}+c_4\xi^{4}+ \cdots  \\u_2(\xi)=c_1\xi+c_3\xi^{3}+c_5\xi^{5}+ \cdots \end{aligned}</script><p>这两个解在 $\xi$ 取有限值时都收敛。现考察 $\left\vert \xi \right\vert \rightarrow \infty$ 时，$\phi$ 是否收敛。</p><p>由函数递推关系，当 $j\rightarrow\infty$</p><script type="math/tex; mode=display">\frac{c_{j+2}}{c_j}\rightarrow \frac{2}{j}</script><ul><li>当 $j$ 为偶数 $j=2m$，$\displaystyle \frac{c<em>{2m+2}}{c</em>{2m}}\sim \frac{1}{m}$<script type="math/tex; mode=display">e^{\xi^{2}}=1+\frac{\xi^{2}}{1!}+\frac{\xi^{4}}{2!}+ \cdots +\frac{\xi^{2m}}{m!}+\frac{\xi^{2m+2}}{(m+1)!}+ \cdots</script></li></ul><p>相继两项之比为</p><script type="math/tex; mode=display">\frac{\xi^{2m+2}}{(m+1)!}/\frac{\xi^{2m}}{m!}=\frac{1}{m+1}\xi^{2} \xrightarrow{m\rightarrow\infty}\frac{1}{m}\xi^{2}</script><p>所以 $u_1(\xi)\xrightarrow{\xi\rightarrow\infty}e^{\xi^{2}}$，发现 $\phi=e^{-\frac{1}{2}\xi^{2}}u_1(\xi)$ 在 $\xi\rightarrow\infty$ 时发散。</p><ul><li>当 $j$ 为奇数 $j=2m+1$，$\displaystyle \frac{c<em>{2m+3}}{c</em>{2m+1}}\sim \frac{1}{m}$<script type="math/tex; mode=display">\xi e^{\xi^{2}}=\xi+\frac{\xi^{2+1}}{1!}+\frac{\xi^{4+1}}{2!}+ \cdots +\frac{\xi^{2m+1}}{m!}+\frac{\xi^{2m+3}}{(m+1)!}+ \cdots</script></li></ul><p>相继两项之比为</p><script type="math/tex; mode=display">\frac{\xi^{2m+3}}{(m+1)!}/\frac{\xi^{2m+1}}{m!}=\frac{1}{m+1}\xi^{2} \xrightarrow{m\rightarrow\infty}\frac{1}{m}\xi^{2}</script><p>所以 $u_2(\xi)\xrightarrow{\xi\rightarrow\infty}\xi e^{\xi^{2}}$，发现 $\phi=e^{-\frac{1}{2}\xi^{2}}u_2(\xi)$ 在 $\xi\rightarrow\infty$ 时发散。</p><h3 id="能量量子化导出"><a href="#能量量子化导出" class="headerlink" title="能量量子化导出"></a>能量量子化导出</h3><p>所以若 $\phi$ 满足束缚条件，则级数必须截断为多项式。从递推关系 (1) 中，我们可以看出需要满足 $\lambda-1=2n\quad(n=0,1,2, \ldots )$。当 $n$ 为偶数，$u_1(\xi)$ 截断为多项式，当 $n$ 为奇数，$u_2(\xi)$ 截断为多项式。最后得到的多项式 $H_n(\xi)$ 称为<strong>厄密多项式</strong>。</p><p>$\displaystyle \because \lambda=\frac{2E}{\hbar \omega}$，</p><script type="math/tex; mode=display">E_n=(n+\frac{1}{2})\hbar \omega=(n+\frac{1}{2})h\nu</script><p>此即为能量量子化条件。</p><h3 id="能量本征函数"><a href="#能量本征函数" class="headerlink" title="能量本征函数"></a>能量本征函数</h3><p>能量 $E_n$ 对应的能量本征函数为 </p><script type="math/tex; mode=display">\phi_{n}(\xi)=N_{n}H_n(\xi)e^{-\frac{1}{2}\xi^{2}}</script><p>其中 $N_n$ 为归一化系数。经过归一化之后为</p><script type="math/tex; mode=display">\phi_{n}(\xi)=\left( \frac{m\omega}{\pi \hbar} \right)^{\frac{1}{4}}\frac{1}{\sqrt{2^{n}n!}}H_n(\xi)e^{-\frac{1}{2}\xi^{2}}</script><p>厄密多项式微分形式为</p><script type="math/tex; mode=display">H_n(\xi)=(-1)^{n}e^{\xi^{2}}\frac{\mathrm{d}^{n}}{\mathrm{d}\xi^{n}}e^{-\xi^{2}}</script><p>同时可以证明，能量本征函数 $\phi<em>{n}$ 满足正交归一化条件 $\displaystyle \int</em>{-\infty}^{+\infty}\phi<em>{n}^{*}(\xi)\phi</em>{m}(\xi)\mathrm{d}x=\delta_{mn}$</p><p>经过分析波函数，还可以发现波函数具有确定的宇称，当 $n$ 为偶数，$\phi<em>{n}$ 为偶宇称波函数；当 $n$ 为奇数，$\phi</em>{n}$ 为奇宇称波函数。</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><h3 id="能量本征值恒为正数"><a href="#能量本征值恒为正数" class="headerlink" title="能量本征值恒为正数"></a>能量本征值恒为正数</h3><p>之前通过对薛定谔方程的求解得到了具体的能量本征值，同时得到能量本征值恒为正数，即使是基态能量也大与 $0$。但其实即使不求解薛定谔方程，同样也可以说明能量恒正。</p><script type="math/tex; mode=display">\begin{aligned}E_n&=\int_{-\infty}^{+\infty}\phi_{n}^{*}(x)\hat{H}\phi_{n}(x)=\int_{-\infty}^{+\infty}\phi_{n}^{*}(x) \left( \frac{\hat{p}_{x}}{2m}+\frac{1}{2}m\omega^{2}x^{2} \right)\phi_{n}(x)\mathrm{d}x\\&= \frac{1}{2m}\int_{-\infty}^{+\infty}\phi_{n}^{*}(x)\hat{p}_{x}^{2}\phi_{n}(x)\mathrm{d}x+\frac{1}{2}m\omega^{2}\int_{-\infty}^{+\infty}\phi_{n}^{*}(x)x^{2}\phi_{n}(x)\mathrm{d}x\\&=\frac{1}{2m}\int_{-\infty}^{+\infty}(\hat{p}_{x}\phi_{n}(x))^{*}\hat{p}_{x}\phi_{n}(x)\mathrm{d}x+\frac{1}{2}m\omega^{2}\int_{-\infty}^{+\infty}\phi_{n}^{*}(x)x^{2}\phi_{n}(x)\mathrm{d}x\\&>0\end{aligned}</script><h3 id="能量特点"><a href="#能量特点" class="headerlink" title="能量特点"></a>能量特点</h3><h4 id="能量量子化"><a href="#能量量子化" class="headerlink" title="能量量子化"></a>能量量子化</h4><p>$\Delta E=h\nu$，而 $\Delta E\sim (10^{-2}-10^{-1}eV)&gt;kT$，所以室温下分子可以视为刚性，即处于基态，分子振动自由度未被激发。</p><h4 id="有零点能"><a href="#有零点能" class="headerlink" title="有零点能"></a>有零点能</h4><p>$E_0=\frac{1}{2}h\nu$，符合不确定关系<br>同时也能说明在常压下，即使将液氦降温到绝对零度附近也不会称为固体。</p><h4 id="有选择定则"><a href="#有选择定则" class="headerlink" title="有选择定则"></a>有选择定则</h4><p>跃迁能级要满足 $\Delta n=\pm 1$，振子只能在相邻能级之间跃迁。因此由 $\Delta E=h\nu$ 可以看出跃迁时发出的光子频率与振子经典振动频率相同。</p><p>说明：<br>该定则可以理解为，光照射谐振子，其中的电场分量 $E=E_0\cos \omega t$ 与谐振子发生相互作用，能量为 $H’=-qxE_0\cos \omega t$。量子态之间跃迁概率与矩阵元有关 </p><script type="math/tex; mode=display">x_{nm}=\int_{-\infty}^{+\infty}\phi_{n}^{*}(x)x\phi_{m}(x)\mathrm{d}x</script><p>其中这里考虑对 $x$ 的积分是因为能量 $H’$ 那一项中比较关键的就是 $x$。</p><h4 id="波尔对应原理"><a href="#波尔对应原理" class="headerlink" title="波尔对应原理"></a>波尔对应原理</h4><p>在大量子数极限情况下，量子论必须渐进地趋于经典理论。</p><p>在这里，当 $n\rightarrow \infty$ 时，$\Delta E / E_n \rightarrow 0$，能量量子化 $\rightarrow$ 能量连续。比如考虑一个宏观的谐振子，$m=1g,k=0.1N /m,A=1mm \Rightarrow \omega=\sqrt{k /m},\Delta E=\hbar \omega=1.05\times 10^{-33}J$，而总能量 $E=\frac{1}{2}kA^{2}=5\times 10^{-3}J$，$n\sim 10^{30}\gg 1,\Delta E\sim 10^{-33}J\ll E$，可以看成能量连续。</p><h3 id="概率密度"><a href="#概率密度" class="headerlink" title="概率密度"></a>概率密度</h3><!-- TODO 或许还得补一补 -->]]></content>
      
      
      <categories>
          
          <category> 量子力学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一维方势垒和隧道效应</title>
      <link href="/posts/7adc43c2.html"/>
      <url>/posts/7adc43c2.html</url>
      
        <content type="html"><![CDATA[<h2 id="理论分析"><a href="#理论分析" class="headerlink" title="理论分析"></a>理论分析</h2><p>设 </p><script type="math/tex; mode=display">U(x)=\begin{cases}    U_0 &0<x<a \\    0 &x<0,x>a\end{cases}</script><p>称为方势垒。现有粒子从左往右入射，能量为 $E$，问粒子穿透势垒或被反射的概率是多少？</p><p>设 $E&lt;U_0$</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial^{2} \phi}{\partial x^{2}}+ \frac{2mE}{\hbar}\phi=0 \quad x<0,x>a \\\frac{\partial ^{2}\phi}{\partial x^{2}}+\frac{2m}{\hbar}(E-U_0)\phi=0 \quad 0<x<a\end{aligned}</script><p>记 $\displaystyle k^{2}=\frac{2mE}{\hbar^{2}},\quad k’^{2}=\frac{2m(U_0-E)}{\hbar^{2}}$，则</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial ^{2}\phi}{\partial x^{2}}+k^{2}\phi=0 \quad & x<0,x>a \\\frac{\partial ^{2}\phi}{\partial x^{2}}-k'^{2}\phi=0 \quad & 0<x<a\end{aligned}</script><p>解为</p><script type="math/tex; mode=display">\begin{aligned}&\phi_1=Ae^{ikx}+A'e^{-ikx} \quad x<0\\&\phi_2=Be^{k'x}+B'e^{-k'x} \quad 0<x<a \\&\phi_3=Ce^{ikx}+C'e^{-ikx} \quad x>a\end{aligned}</script><p>由于 $e^{ikx}$ 表示从左到右的波，应该为入射波或者透射波；$e^{-ikx}$ 为从右到左的波，为反射波。因此从这一物理条件考虑，$C’=0$，即透射波不可能有从右到左的成分。</p><p>再考虑连续性条件，有</p><script type="math/tex; mode=display">\begin{aligned}& \psi_1(0)=\psi_2(0) \rightarrow A+A^{\prime}=B+B^{\prime} \\& \psi_1^{\prime}(0)=\psi_2^{\prime}(0) \rightarrow i k\left(A-A^{\prime}\right)=k^{\prime}\left(B-B^{\prime}\right) \\& \psi_2(a)=\psi_3(a) \rightarrow B e^{k^{\prime} a}+B^{\prime} e^{-k^{\prime} a}=C e^{i k a} \\& \psi_2^{\prime}(a)=\psi_3^{\prime}(a) \rightarrow k^{\prime}\left(B e^{k^{\prime} a}-B^{\prime} e^{-k^{\prime} a}\right)=i k C e^{i k a}\end{aligned}</script><p>由这4条方程，最后可以将 $C$ 和 $A’$ 都用 $A$ 表示出来，就可以求出反射率和透射率。<br>反射系数为</p><script type="math/tex; mode=display">R=\frac{\left\vert A' \right\vert^{2} }{\left\vert A \right\vert^{2} }=\frac{(k^{2}+k'^{2})^{2}\sinh ^{2}k'a}{(k^{2}+k'^{2})^{2}\sinh ^{2}k'a+4k^{2}k'^{2}}</script><p>透射系数</p><script type="math/tex; mode=display">T=\frac{\left\vert C \right\vert^{2} }{\left\vert A \right\vert^{2} }=\frac{4k^{2}k'^{2}}{(k^{2}+k'^{2})^{2}\sinh^{2} k'a+4k^{2}k'^{2}}</script><p>经验证，$T+R=1$，粒子数守恒。</p><p>当 $k’a\gg 1$ 时，经小量近似可以得到</p><script type="math/tex; mode=display">T\thickapprox \frac{16E}{U_0}(1-\frac{E}{U_0})e^{-2k'a} = \frac{16E}{U_0}(1-\frac{E}{U_0})\exp (-\frac{2}{\hbar}\sqrt{2m(U_0-E)}a)</script><p>势垒越高，宽度越宽，穿透几率越小，但总有一定几率穿透，这一现象称为<strong>量子隧道效应</strong><br>另外，量子隧道效应中透射系数 $T$ 对势垒的宽度 $a$ 与粒子质量 $m$ 的变化很敏感。</p><h2 id="量子隧穿实例"><a href="#量子隧穿实例" class="headerlink" title="量子隧穿实例"></a>量子隧穿实例</h2><h3 id="核的-alpha-衰变"><a href="#核的-alpha-衰变" class="headerlink" title="核的 $\alpha$ 衰变"></a>核的 $\alpha$ 衰变</h3><p>原子核的势垒高度高于 $\alpha$ 粒子的能量，但是根据量子隧穿，$\alpha$ 粒子有一定概率挣脱原子核的束缚，从而让原子核发生 $\alpha$ 衰变。</p>]]></content>
      
      
      <categories>
          
          <category> 量子力学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>有限深势井</title>
      <link href="/posts/7ce137d0.html"/>
      <url>/posts/7ce137d0.html</url>
      
        <content type="html"><![CDATA[<h2 id="波函数求解"><a href="#波函数求解" class="headerlink" title="波函数求解"></a>波函数求解</h2><h3 id="列微分方程"><a href="#列微分方程" class="headerlink" title="列微分方程"></a>列微分方程</h3><p>有限深势井函数为</p><script type="math/tex; mode=display">U(x)=\begin{cases}    U_0 &\left\vert x \right\vert>a  \\    0 &\left\vert x \right\vert<a \end{cases}</script><p>势函数不显含时间，利用定态薛定谔方程</p><script type="math/tex; mode=display">\hat{H}\phi=E\phi \Rightarrow (-\frac{\hbar^{2}}{2m}+U(x))\phi=E\phi</script><p>考虑势井内和势井外。在势井内</p><script type="math/tex; mode=display">\frac{\partial ^{2}\phi}{\partial x^{2}}+ \frac{2mE}{\hbar^{2}}\phi=0 \quad \left\vert x \right\vert <a</script><p>在势井外</p><script type="math/tex; mode=display">\frac{\partial ^{2}\phi}{\partial x^{2}}+ \frac{2m}{\hbar^{2}}(E-U_0)\phi=0 \quad \left\vert x \right\vert >a</script><p>讨论 $0&lt;E&lt;U_0$ 的情况(束缚态)。设 </p><script type="math/tex; mode=display">k^{2}=\frac{2mE}{\hbar^{2}} ,\quad k'^{2}=\frac{2m(U_0-E)}{\hbar^{2}}</script><p>则</p><script type="math/tex; mode=display">\begin{aligned} \frac{\partial ^{2}\phi}{\partial x^{2}}+k^{2}\phi =0 \quad&\left\vert x \right\vert<a \\ \frac{\partial ^{2}\phi}{\partial x^{2}}-k'^{2}\phi=0 \quad&\left\vert x \right\vert >a\end{aligned}</script><h3 id="考虑波函数不发散"><a href="#考虑波函数不发散" class="headerlink" title="考虑波函数不发散"></a>考虑波函数不发散</h3><p>解为</p><script type="math/tex; mode=display">\phi=\begin{cases}    A\sin (kx+\delta)\quad &\left\vert x \right\vert <a\\    Be^{-k'x}+Ce^{k'x} \quad&\left\vert x \right\vert>a \end{cases}</script><p>其中 $A,B,C,\delta$ 为待定常数。</p><p>由于波函数在 $\left\vert x \right\vert \rightarrow \infty$ 时不发散，$\left\vert x \right\vert &gt;a$ 时的解可以写为</p><script type="math/tex; mode=display">\phi=\begin{cases}    Be^{-k'x} \quad&x>a\\    Ce^{k'x} \quad&x<a\end{cases}</script><h3 id="波函数连续性"><a href="#波函数连续性" class="headerlink" title="波函数连续性"></a>波函数连续性</h3><p><em>在 $x=\pm a$ 处波函数及其导数连续</em></p><p>Proof:</p><script type="math/tex; mode=display">\frac{\partial ^{2}\phi(x)}{\partial x^{2}}=-\frac{2m}{\hbar^{2}}[E-U(x)]\phi(x)</script><p>考虑在 $x=a$ 的邻域积分</p><script type="math/tex; mode=display">\lim_{n \to 0^{+}}\int_{a-\varepsilon}^{a+\varepsilon} \frac{\partial ^{2}\phi(x)}{\partial x^{2}}\mathrm{d}x =\int _{a-\varepsilon}^{a+\varepsilon}-\frac{2m}{\hbar^{2}}[E-U(x)]\phi(x) \mathrm{d}x</script><script type="math/tex; mode=display">\Rightarrow \phi'(a+0^{+})-\phi'(a-0^{-})=0</script><p>即波函数一阶导数连续，因而 $\phi(x)$ 也连续。</p><p>在 $x=a$ 处</p><script type="math/tex; mode=display">\begin{cases}A\sin (ka+\delta)=Be^{-k'a}\\kA\cos (ka+\delta)=-k'Be^{-k'a}\end{cases} \Rightarrow k\cot (ka+\delta)=-k'</script><p>在 $x=-a$ 处</p><script type="math/tex; mode=display">\begin{cases}    A\sin (-ka+\delta)=Ce^{-k'a} \\    kA\cos (-ka+\delta)=k'Ce^{-k'a}\end{cases} \Rightarrow k\cot (-ka+\delta)=k'</script><p>由于 $k,k’,a$ 都是由题目条件给定的，因此可以求出 $\delta$</p><script type="math/tex; mode=display">\begin{cases}    k\cot (ka+\delta)=-k' \\    k\cot (-ka+\delta)=k'\end{cases} \Rightarrow \cot (ka+\delta)=-\cot (-ka+\delta)</script><p>解得</p><script type="math/tex; mode=display">\delta=\begin{cases}    n\pi \\    (n+\frac{1}{2})\pi\end{cases}\quad n=0,\pm 1,\pm 2\cdots</script><p>由于 $n$ 取不同的值对于波函数来说结果一样，因此此处取 $n=0$。$\therefore \delta=0$ 或 $\pi /2$</p><p>若取 $\delta=0$，有</p><script type="math/tex; mode=display">\phi=\begin{cases}    A\sin kx &\left\vert x \right\vert <a\\    Be^{-k'x} &x>a\\    Ce^{k'x} &x<-a\end{cases}</script><p>考虑由连续性得到的式子，可以得到 $B=-C$，即</p><script type="math/tex; mode=display">\phi_{A}=\begin{cases}    A\sin kx &\left\vert x \right\vert<a  \\    Be^{-k'x} &x>a\\    -Be^{k'x} &x<-a\end{cases}</script><h3 id="宇称"><a href="#宇称" class="headerlink" title="宇称"></a>宇称</h3><p>宇称是函数在空间反演下表现出的特性。定义空间反演算符 $\hat{P}$ 为: $\hat{P}\psi(x)=\psi(-x)$</p><p>如果 $\hat{P}\psi(x)=\psi(-x)=\psi(x)$，称 $\psi(x)$ 具有确定的偶宇称；如果 $\hat{P}\psi(x)=\psi(-x)=-\psi(x)$，称 $\psi(x)$ 有确定的奇宇称。</p><p>因此在求解有限深势井薛定谔方程的时候，如果 $\delta=0$，则波函数有奇宇称；如果 $\delta=\pi /2$，则波函数有偶宇称。此时波函数中的未知数 $A,B$ 可以继续使用连续性条件加上归一化条件求出。</p><p>下面先考虑波函数有定态解的条件。<br>对于奇宇称 ($\delta=0$)，$k\cot ka=-k’$。令 $u=ka,v=k’a$，则方程写为 </p><script type="math/tex; mode=display">u\cot u=-v</script><p>同时</p><script type="math/tex; mode=display">u^{2}+v^{2}=(k^{2}+k'^{2})a^{2}=\frac{2mU_0}{\hbar^{2}}a^{2}</script><p>则可以通过作图的方式求出 $u$ 和 $v$</p><div align=center><img src="../../figure/有限深势阱/奇宇称.png" width=700></div><p>从图中可以看出，当 $\displaystyle \frac{2mU_0a^{2}}{\hbar^{2}}\ge \frac{\pi^{2}}{4}$ 时，才有第一奇宇称的束缚态。</p><p>同理，对于偶宇称 $(\delta=\pi /2)$，$k \tan ka=k’$。令 $u=ka,v=k’a$，则方程写为 </p><script type="math/tex; mode=display">u \tan u=u</script><p>同时</p><script type="math/tex; mode=display">u^{2}+v^{2}=\frac{2mU_0}{\hbar^{2}}a^{2}</script><p>则同样可以通过作图的方式求出 $u$ 和 $v$</p><div align=center><img src="../../figure/有限深势阱/偶宇称.png" width=700></div><p>可以看出无论 $U_0a^{2}$ 多小，总存在一束缚态，因此对一维方势阱总存在一个偶宇称的束缚态（基态）</p>]]></content>
      
      
      <categories>
          
          <category> 量子力学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch相关库版本对应</title>
      <link href="/posts/67d74f7.html"/>
      <url>/posts/67d74f7.html</url>
      
        <content type="html"><![CDATA[<p>在安装与 PyTorch 相关的 python 库的时候，经常要考虑版本对应的问题。</p><h3 id="torchtext"><a href="#torchtext" class="headerlink" title="torchtext"></a>torchtext</h3><p>可以按照该网址安装 <a href="https://pypi.org/project/torchtext/">https://pypi.org/project/torchtext/</a></p><p>截至2023年5月4日，版本对应情况如下：</p><table><caption>Version Compatibility</caption><colgroup><col><col><col></colgroup><thead><tr><th class="head"><p>PyTorch version</p></th><th class="head"><p>torchtext version</p></th><th class="head"><p>Supported Python version</p></th></tr></thead><tbody><tr><td><p>nightly build</p></td><td><p>main</p></td><td><p>&gt;=3.8, &lt;=3.11</p></td></tr><tr><td><p>1.13.0</p></td><td><p>0.14.0</p></td><td><p>&gt;=3.7, &lt;=3.10</p></td></tr><tr><td><p>1.12.0</p></td><td><p>0.13.0</p></td><td><p>&gt;=3.7, &lt;=3.10</p></td></tr><tr><td><p>1.11.0</p></td><td><p>0.12.0</p></td><td><p>&gt;=3.6, &lt;=3.9</p></td></tr><tr><td><p>1.10.0</p></td><td><p>0.11.0</p></td><td><p>&gt;=3.6, &lt;=3.9</p></td></tr><tr><td><p>1.9.1</p></td><td><p>0.10.1</p></td><td><p>&gt;=3.6, &lt;=3.9</p></td></tr><tr><td><p>1.9</p></td><td><p>0.10</p></td><td><p>&gt;=3.6, &lt;=3.9</p></td></tr><tr><td><p>1.8.1</p></td><td><p>0.9.1</p></td><td><p>&gt;=3.6, &lt;=3.9</p></td></tr><tr><td><p>1.8</p></td><td><p>0.9</p></td><td><p>&gt;=3.6, &lt;=3.9</p></td></tr><tr><td><p>1.7.1</p></td><td><p>0.8.1</p></td><td><p>&gt;=3.6, &lt;=3.9</p></td></tr><tr><td><p>1.7</p></td><td><p>0.8</p></td><td><p>&gt;=3.6, &lt;=3.8</p></td></tr><tr><td><p>1.6</p></td><td><p>0.7</p></td><td><p>&gt;=3.6, &lt;=3.8</p></td></tr><tr><td><p>1.5</p></td><td><p>0.6</p></td><td><p>&gt;=3.5, &lt;=3.8</p></td></tr><tr><td><p>1.4</p></td><td><p>0.5</p></td><td><p>2.7, &gt;=3.5, &lt;=3.8</p></td></tr><tr><td><p>0.4 and below</p></td><td><p>0.2.3</p></td><td><p>2.7, &gt;=3.5, &lt;=3.8</p></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pthread API的简单使用</title>
      <link href="/posts/2be5aa7c.html"/>
      <url>/posts/2be5aa7c.html</url>
      
        <content type="html"><![CDATA[<p>此处使用到 Pthread API 的代码以《操作系统概念》第4章和第7章的 Programming Project 为例。</p><h2 id="构建线程池"><a href="#构建线程池" class="headerlink" title="构建线程池"></a>构建线程池</h2><h3 id="pthread-mutex-init-与-pthread-mutex-destory"><a href="#pthread-mutex-init-与-pthread-mutex-destory" class="headerlink" title="pthread_mutex_init() 与 pthread_mutex_destory()"></a><code>pthread_mutex_init()</code> 与 <code>pthread_mutex_destory()</code></h3><p><code>pthread_mutex_init()</code> 函数用于初始化一个互斥锁对象，而 <code>pthread_mutex_destory()</code> 函数用于清除这个对象以释放资源。这两个函数在线程池的初始化和关闭的过程中会用到。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the thread pool</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pool_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    queue_head = queue_tail = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;queue_mutex, <span class="literal">NULL</span>);        <span class="comment">// initialize mutex</span></span><br><span class="line">    sem_init(&amp;thread_sem, <span class="number">0</span>, NUMBER_OF_THREADS);   <span class="comment">// initialize sem</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> id = <span class="number">0</span>; id &lt; NUMBER_OF_THREADS; id++) <span class="comment">// initialize thread</span></span><br><span class="line">        thread_working[id] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shutdown the thread pool</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pool_shutdown</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> id = <span class="number">0</span>; id &lt; NUMBER_OF_THREADS; id++)</span><br><span class="line">        pthread_join(thread_pool[id], <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;queue_mutex);</span><br><span class="line">    sem_destroy(&amp;thread_sem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在线程池初始化的函数中使用了 <code>pthread_mutex_init(&amp;queue_mutex, NULL)</code>，这里表示将一个 <code>pthread_mutex_t</code> 类型的变量 <code>queue_mutex</code> 初始化，而函数的第二个参数表示指向 <code>pthread_mutexattr_t</code> 的指针，用于设置互斥锁的属性。这里使用 <code>NULL</code> 则表示该 <code>queue_mutex</code> 将使用默认属性。同时需要注意，一个互斥锁只有经过初始化之后才能正常使用，所以这里的 <code>pthread_mutex_init()</code> 函数是必要的。</p><p>而在线程池的关闭函数中则使用了 <code>pthread_mutex_destroy(&amp;queue_mutex)</code>，这里表示释放 <code>queue_mutex</code> 所占用的资源。同时在互斥锁不被使用后销毁是一个良好的编程习惯。</p><h3 id="pthread-creat-与-pthread-exit"><a href="#pthread-creat-与-pthread-exit" class="headerlink" title="pthread_creat() 与 pthread_exit()"></a><code>pthread_creat()</code> 与 <code>pthread_exit()</code></h3><p><code>pthread_creat()</code> 函数用于创建一个线程。该函数在 <code>pool_submit()</code> 函数中被使用，表示在有新的任务到来的时候将从线程池中挑出一个空闲的 tid 来创建一个新的线程来处理任务。这里提到的 tid 可以用 <code>pthread_t</code> 来创建，它会被用于接收新建线程的标识符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pool_submit</span><span class="params">(<span class="type">void</span> (*somefunction)(<span class="type">void</span> *p), <span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    task worktodo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add task to the queue</span></span><br><span class="line">    worktodo.function = somefunction;</span><br><span class="line">    worktodo.data = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enqueue(worktodo))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Pool Submit Failure.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sem_wait(&amp;thread_sem);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> id = <span class="number">0</span>; id &lt; NUMBER_OF_THREADS; id++)</span><br><span class="line">        <span class="keyword">if</span> (!thread_working[id])</span><br><span class="line">        &#123;</span><br><span class="line">            thread_working[id] = <span class="number">1</span>;</span><br><span class="line">            pthread_create(&amp;thread_pool[id], <span class="literal">NULL</span>, &amp;worker, (<span class="type">void</span> *)&amp;id);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码中使用了 <code>pthread_create(&amp;thread_pool[id], NULL, &amp;worker, (void *)&amp;id)</code>。<code>&amp;thread_pool[id]</code> 是指向 <code>pthread_t</code> 类型的数组中特定位置的指针，用于接收新线程的标识符。第二个参数 <code>NULL</code> 和 <code>pthread_mutex_init(&amp;queue_mutex, NULL)</code> 中类似，表示使用默认属性创建线程。<code>&amp;worker</code> 是一个函数指针，指向线程要执行的函数。<code>(void *)&amp;id</code> 是传递给线程函数 <code>worker</code> 的参数。在这里，<code>id</code> 是一个整数值，通过将其地址转换为 <code>void *</code> 类型传递给线程函数。</p><p>在这里执行完 <code>pthread_create()</code> 之后，<code>worker()</code> 函数就会开始工作。工作结束之后执行 <code>pthread_exit(0)</code>，这里的参数 <code>0</code> 表示该线程传递了 <code>NULL</code> 指针作为退出状态。同时在执行了 <code>pthread_exit()</code> 之后，该线程的标识符 <code>thread_pool[id]</code> (这里的 <code>id</code> 是 <code>pool_submit()</code> 中的那个) 一方面可以作为 <code>pthread_join()</code> 的参数，让主线程获取该线程的退出状态；另一方面，该线程标识符被重新标记为可用，也就是能再次作为 <code>pthread_creat()</code> 的参数，来接收新的线程。</p><h3 id="pthread-mutex-lock-与-pthread-mutex-unlock"><a href="#pthread-mutex-lock-与-pthread-mutex-unlock" class="headerlink" title="pthread_mutex_lock() 与 pthread_mutex_unlock()"></a><code>pthread_mutex_lock()</code> 与 <code>pthread_mutex_unlock()</code></h3><p>在 <code>pool_submit()</code> 和 <code>worker()</code> 函数中调用了 <code>enqueue()</code> 和 <code>dequeue()</code> 函数，分别表示新任务被挂起放在等待队列中，和任务被从等待队列中取出执行。为了防止进队出队的过程中出现冲突，这里使用了 <code>pthread_mutex_t</code> 类型的变量 <code>queue_mutex</code> 来处理该临界区问题。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">enqueue</span><span class="params">(task t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((queue_tail + <span class="number">1</span>) % (QUEUE_SIZE + <span class="number">1</span>) == queue_head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enqueue Failure.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;queue_mutex);</span><br><span class="line">        task_queue[queue_tail] = t;</span><br><span class="line">        queue_tail = (queue_tail + <span class="number">1</span>) % (QUEUE_SIZE + <span class="number">1</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;queue_mutex);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>比如这段代码中，在操作 <code>queue_head</code> 和 <code>queue_tail</code> 的前后使用 <code>pthread_mutex_lock(&amp;queue_mutex)</code> 和 <code>pthread_mutex_unlock(&amp;queue_mutex)</code>，使得队列的队首和队尾不会被多个线程同时操作。</p><h3 id="sem-t-信号量"><a href="#sem-t-信号量" class="headerlink" title="sem_t 信号量"></a><code>sem_t</code> 信号量</h3><p><code>sem_t</code> 虽然不是 Pthread API 中的变量类型，但是与线程之间的同步有关，因此这里放在一起说明。这里创建的是一个匿名的信号量，因此在 <code>pthread_mutex_init()</code> 中初始化的时候使用的是 <code>sem_init(&amp;thread_sem, 0, NUMBER_OF_THREADS)</code>，其中第一个参数就是我们要初始化的信号量，第二个参数为 <code>0</code>，表示该信号量为匿名，第三个参数则表示信号量的初始值。</p><p>在使用的过程中，<code>sem_wait(&amp;queue_mutex)</code> 表示该信号量对应资源被申请，<code>sem_post(&amp;queue_mutex)</code> 表示该信号量对应资源被释放。</p>]]></content>
      
      
      
        <tags>
            
            <tag> operating system </tag>
            
            <tag> Pthread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux内核模块编写初步</title>
      <link href="/posts/afd0741b.html"/>
      <url>/posts/afd0741b.html</url>
      
        <content type="html"><![CDATA[<p>此处内核模块代码以《操作系统概念》第二章的 Programming Project为例。</p><h2 id="模块需求"><a href="#模块需求" class="headerlink" title="模块需求"></a>模块需求</h2><p>设计一个内核模块：创建一个名为 <code>/proc/jiffies</code> 的 <code>/proc</code> 文件。在读取 <code>/proc/jiffies</code> 文件时报告 <code>jiffies</code> 的当前值。结果可使用 <code>cat</code> 获取，命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/jiffies</span><br></pre></td></tr></table></figure></p><p>并确保在删除模块时删除 <code>/proc/jiffies</code>。</p><p>注：<code>jiffies</code> 是Linux内核中用于跟踪系统运行时间的变量，表示自系统启动以来的时钟滴答数。</p><h2 id="模块实现"><a href="#模块实现" class="headerlink" title="模块实现"></a>模块实现</h2><h3 id="头文件和宏定义"><a href="#头文件和宏定义" class="headerlink" title="头文件和宏定义"></a>头文件和宏定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/jiffies.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROC_NAME <span class="string">&quot;jiffies&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="proc-ops-结构体对象"><a href="#proc-ops-结构体对象" class="headerlink" title="proc_ops 结构体对象"></a><code>proc_ops</code> 结构体对象</h3><p><code>proc_ops</code> 结构体对象用于定义对于 <code>/proc</code> 文件的操作函数。在这段代码中,将 <code>proc_ops</code> 对象中的 <code>proc_read</code> 字段设置为 <code>proc_read</code> 函数，将该对象与后面要创建的 <code>/proc/jiffies</code> 文件关联起来。这样，在读取 <code>/proc/jiffies</code> 文件时，内核将调用 <code>proc_read</code> 函数来处理读取操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">proc_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *pos)</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">proc_ops</span> =</span> &#123;</span><br><span class="line">    .proc_read = proc_read,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="proc-init-和-proc-exit"><a href="#proc-init-和-proc-exit" class="headerlink" title="proc_init 和 proc_exit"></a><code>proc_init</code> 和 <code>proc_exit</code></h3><p>定义在模块加载时要调用的函数 <code>proc_init</code> ，使用 <code>proc_create</code> 函数创建了一个名为 <code>&quot;/proc/jiffies&quot;</code> 的文件，并将 <code>proc_ops</code> 结构体对象传递给它。然后使用 <code>printk</code> 函数在内核日志中打印一条信息,内核日志可以通过linux中的 <code>sudo dmesg</code> 命令读取和显示，<code>printk</code> 中 <code>KERN_INFO</code> 是一个宏定义，表示内核日志消息的级别为信息级别。不同的日志级别有不同的前缀，用于区分不同类型的日志消息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">proc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    proc_create(PROC_NAME, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;proc_ops);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;/proc/%s created\n&quot;</span>, PROC_NAME);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义在模块卸载时调用的函数 <code>proc_exit</code> ，使用 <code>remove_proc_entry</code> 函数删除之前创建的 <code>&quot;/proc/jiffies&quot;</code> 文件，并使用 <code>printk</code> 函数在内核日志中打印一条信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">proc_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    remove_proc_entry(PROC_NAME, <span class="literal">NULL</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;/proc/%s removed\n&quot;</span>, PROC_NAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="proc-read-函数"><a href="#proc-read-函数" class="headerlink" title="proc_read 函数"></a><code>proc_read</code> 函数</h3><p>定义 <code>proc_read</code> 函数，该函数在读取 <code>/proc/jiffies</code> 文件时被调用。函数的返回值类型为 <code>ssize_t</code>，这个类型类似于 <code>int</code>，但是 <code>ssize_t</code> 类型是专门为了在不同平台和操作系统上保持一致的数据类型，能够避免 <code>int</code> 在不同平台中大小和符号不同的问题。函数参数解释如下：</p><ul><li><code>struct file *file</code>：表示正在进行读取操作的文件的指针。在 <code>/proc</code> 文件系统中，该参数通常不会被使用，可以忽略。</li><li><code>char *buf</code>：表示用户空间的缓冲区指针，用于存储从文件中读取的数据。读取的内容将被复制到这个缓冲区中。用户缓冲区中的数据可以用 <code>cat</code> 命令读取。</li><li><code>size_t count</code>：表示要读取的最大字节数。读取的内容不能超过这个数值。</li><li><code>loff_t *pos</code>：表示文件的当前位置指针。在多次读取的情况下，可以使用该参数来跟踪文件读取的位置。</li></ul><p>函数内部首先定义了一些变量，包括一个字符数组 <code>buffer</code> 用于存储要输出的内容，以及一个静态变量 <code>completed</code> 用于追踪是否已经读取完成。<br>如果 <code>completed</code> 为真，则表示已经读取完成，直接返回 $0$。否则，将 <code>completed</code> 设置为真，并使用 <code>sprintf</code> 函数将当前的 <code>jiffies</code> 值格式化为字符串并存储在 <code>buffer</code> 中。<code>sprintf()</code> 函数是C语言标准库中的一个函数，该函数的第一个参数是要存储结果的字符数组，第二个参数是格式化字符串，后面的参数根据格式化字符串中的占位符进行替换，它的工作方式类似于 <code>printf()</code> 函数，但不会将输出发送到标准输出流（如控制台），而是将结果存储在字符数组中。<br>接下来，使用 <code>copy_to_user</code> 函数将 <code>buffer</code> 的内容复制到用户空间的 <code>usr_buf</code> 中，并返回 <code>rv</code> 作为读取的字节数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">proc_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *usr_buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> completed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completed) &#123;</span><br><span class="line">        completed = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    completed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    rv = <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;jiffies= %lu\n&quot;</span>, jiffies);</span><br><span class="line">    copy_to_user(usr_buf, buffer, rv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="模块入口出口点"><a href="#模块入口出口点" class="headerlink" title="模块入口出口点"></a>模块入口出口点</h3><p>使用 <code>module_init</code> 宏将 <code>proc_init</code> 函数指定为模块的入口点，即在模块加载时调用该函数。使用 <code>module_exit</code> 宏将 <code>proc_exit</code> 函数指定为模块的出口点，即在模块卸载时调用该函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_init(proc_init);</span><br><span class="line">module_exit(proc_exit);</span><br></pre></td></tr></table></figure></p><h3 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h3><p>最后使用MODULE_LICENSE、MODULE_DESCRIPTION和MODULE_AUTHOR宏设置模块的许可证、描述和作者信息。（这段代码应该不是很重要）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Hello Module&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SGG&quot;</span>);</span><br></pre></td></tr></table></figure></p><h2 id="proc-文件系统"><a href="#proc-文件系统" class="headerlink" title="/proc 文件系统"></a><code>/proc</code> 文件系统</h2><p>在这个project中，<code>/proc</code> 文件系统用于与内核模块的交互。内核模块在 <code>/proc</code> 文件系统中创建文件，通过读写这些文件来与用户空间程序通信，传递信息或接收命令。</p><p>“proc”在Linux中是”process”的缩写，在 <code>/proc</code> 文件系统中，每个运行中的进程都有一个对应的目录，以进程ID（PID）为名称。进程相关的信息可以在相应的目录中找到，例如 <code>/proc/&lt;PID&gt;/status</code> 和 <code>/proc/&lt;PID&gt;/stat</code> 文件用于获取特定进程的状态信息。</p><p>但事实上，<code>/proc</code> 提供了更广泛的功能，不仅仅用于进程相关的信息。它的主要作用如下：</p><ul><li>提供内核信息访问接口：<code>/proc</code> 文件系统提供了一种访问内核信息的机制，允许用户空间程序读取和操作内核数据。通过读取 <code>/proc</code> 文件系统中的文件，可以获取关于系统硬件、内核参数、进程信息、设备信息等多种内核数据。</li><li>运行时数据的监控和调试：<code>/proc</code> 文件系统为系统管理员和开发人员提供了一种监控和调试系统的手段。例如，可以通过读取 <code>/proc</code> 中的文件获取CPU使用情况、内存使用情况、网络状态等运行时数据，用于性能分析、故障排查和系统调优。</li><li>与内核模块的交互：内核模块可以通过创建自己的 <code>/proc</code> 文件来与用户空间进行交互。模块可以在 <code>/proc</code> 文件系统中创建文件，通过读写这些文件来与用户空间程序通信，传递信息或接收命令。</li><li>动态配置和控制：一些系统参数和配置选项可以通过 <code>/proc</code> 文件系统进行动态调整。通过修改相关文件中的值，可以实时更改内核的某些行为或配置选项，而无需重新启动系统。</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> operating system </tag>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode编写Linux内核模块头文件报错解决方案</title>
      <link href="/posts/2dbb0a4f.html"/>
      <url>/posts/2dbb0a4f.html</url>
      
        <content type="html"><![CDATA[<p>该解决方案参考了<a href="https://www.joyk.com/dig/detail/1620497242851117">这篇文章</a></p><h2 id="报错情况"><a href="#报错情况" class="headerlink" title="报错情况"></a>报错情况</h2><p>在使用 vscode 编写 Linux 内核模块的时候，需要 <code>#include</code> 一些与内核相关的头文件，然而经常会出现报错，比如当代码包含头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>就会出现如下报错：</p><blockquote><p>检测到 #include 错误。请更新 includePath。已为此翻译单元(/home/zxz/Project/System/final-src-osc10e/ch3/homework/pid_new.c)禁用波形曲线。C/C++(1696)<br>无法打开 源 文件 “asm/bug.h” (dependency of “linux/slab.h”)C/C++(1696)</p></blockquote><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>通常我们编译内核模块是用 <code>Makefile</code> 作为编译系统的，而 vscode 并不能自动从 <code>Makefile</code> 里读取出需要的信息，也就是说 vscode 不知道我们使用的这些头文件的目录在哪里。所以需要我们手动在 <code>.vscode</code> 目录下写一些配置文件。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="查找路径"><a href="#查找路径" class="headerlink" title="查找路径"></a>查找路径</h3><p>首先查找这些无法被 vscode 找到的头文件的路径。比如前面提到的报错信息，表示无法找到 <code>&quot;asm/bug.h&quot;</code>，那么可以在 Linux 终端输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name <span class="string">&quot;bug.h&quot;</span> 2&gt;/dev/null</span><br></pre></td></tr></table></figure></p><p>由于这里的 <code>&quot;bug.h&quot;</code> 文件是一个虚拟的 Linux 头文件，所以会返回比较多的结果。不过在这里正确的路径应该是 <code>/usr/src/linux-headers-5.15.0-69-generic/arch/x86/include/asm/bug.h</code>。筛选的方式为：</p><ul><li>Linux 源码中的一般头文件： 内核源码根目录/include/linux</li><li>Linux 源码中的与架构相关的头文件： 内核源码根目录/arch/架构名/include</li></ul><p>而对于某些 Linux 内核头文件的缺失，比如如下报错：</p><blockquote><p>无法打开 源 文件 “linux/proc_fs.h”C/C++(1696)</p></blockquote><p>那么通过查找可以得到唯一路径 <code>/usr/src/linux-headers-5.15.0-69-generic/include/linux/proc_fs.h</code>。</p><h3 id="修改-vscode-配置文件"><a href="#修改-vscode-配置文件" class="headerlink" title="修改 vscode 配置文件"></a>修改 vscode 配置文件</h3><p>在 vscode 中使用 <code>Ctrl + Shift + P</code> 调出命令面板，输入 <code>C/C++:Edit Configuration(JSON)</code>，打开配置文件。</p><p>对于文件 <code>/usr/src/linux-headers-5.15.0-69-generic/arch/x86/include/asm/bug.h</code>，那么就需要把文件夹 <code>/usr/src/linux-headers-5.15.0-69-generic/arch/x86/include/</code> 放到 <code>&quot;inlcudePath&quot;</code> 里。<br>同样的，对于文件 <code>/usr/src/linux-headers-5.15.0-69-generic/include/linux/proc_fs.h</code>，需要把 <code>&quot;/usr/src/linux-headers-5.15.0-69-generic/include&quot;</code> 放到路径里。</p><h3 id="配置文件示例"><a href="#配置文件示例" class="headerlink" title="配置文件示例"></a>配置文件示例</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/src/linux-headers-5.15.0-69-generic/include&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/src/linux-headers-5.15.0-69-generic/include/uapi/&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/src/linux-headers-5.15.0-69-generic/arch/x86/include&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/usr/src/linux-headers-5.15.0-69-generic/arch/x86/include/generated&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;__KERNEL__=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;KBUILD_MODNAME=\&quot;mod_hello\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;MODULE=1&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gnu++14&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux-gcc-x64&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>下面 <code>&quot;define&quot;</code> 还不清楚干啥用，是直接从<a href="https://www.joyk.com/dig/detail/1620497242851117">这里</a>复制过来的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> operating system </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无限深势井</title>
      <link href="/posts/7324d20.html"/>
      <url>/posts/7324d20.html</url>
      
        <content type="html"><![CDATA[<h2 id="波函数求解"><a href="#波函数求解" class="headerlink" title="波函数求解"></a>波函数求解</h2><p>无限深势井势函数为</p><script type="math/tex; mode=display">U(x)=\begin{cases}    0,&(0<x<a) \\    \infty,&(x\le 0,\quad x\ge a)\end{cases}</script><p>由于该势函数不显含时间，可以利用定态薛定谔方程求解。</p><script type="math/tex; mode=display">E\phi(x)=\hat{H}\phi(x)</script><p>波函数的形式为 $\psi(x,t)=\phi(x)T(t)$，其中 $T(t)=e^{- iEt / \hbar}$。</p><p>对于定态薛定谔方程</p><script type="math/tex; mode=display">E\phi(x)=(-\frac{\hbar^{2}}{2m}\frac{\partial ^{2}}{\partial x^{2}}+U(x))\phi(x)</script><p>考虑势井内和势井外两种情况。在势井中，</p><script type="math/tex; mode=display">\displaystyle \frac{\hbar^{2}}{2m}\frac{\partial ^{2}\phi}{\partial x^{2}}+E\phi=0 \Rightarrow \phi=A\cos kx+B\sin kx \ (k=\sqrt{\frac{2mE}{\hbar^{2}}})</script><p>在势井外，$\phi=0$。</p><p>由于波函数的连续性，$\phi(0)=\phi(a)=0$，即</p><script type="math/tex; mode=display">\begin{cases}    A=0 \\    A\cos ka+B\sin ka=0\end{cases}\Rightarrow A=0,\quad k=\frac{n\pi}{a}</script><p>故</p><script type="math/tex; mode=display">\phi(x)=B\sin \frac{n\pi}{a}x</script><p>再由归一化条件</p><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}\left\vert \phi(x) \right\vert^{2} \mathrm{d}x=1 \Rightarrow \int_{0}^{a}B^{2}\sin ^{2} \frac{n\pi}{a}x \mathrm{d}x=1</script><p>解得</p><script type="math/tex; mode=display">B=\sqrt{\frac{2}{a}}</script><script type="math/tex; mode=display">\therefore \phi(x)=\sqrt{\frac{2}{a}}\sin \frac{n\pi}{a}x</script><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><h3 id="能量量子化"><a href="#能量量子化" class="headerlink" title="能量量子化"></a>能量量子化</h3><p>在求解的过程中，我们得到了 $k=\sqrt{2mE /\hbar^{2}}$，而最后求解得到的结果则是 $k=n\pi /a$，因此有</p><script type="math/tex; mode=display">\sqrt{\frac{2mE}{\hbar^{2}}}=\frac{n\pi}{a} \Rightarrow E_{n}=\frac{\pi^{2}\hbar^{2}}{2ma^{2}}n^{2},\quad n=1,2,3\cdots</script><p>从这里可以看出能量量子化。</p><h3 id="势井中驻波"><a href="#势井中驻波" class="headerlink" title="势井中驻波"></a>势井中驻波</h3><script type="math/tex; mode=display">\begin{aligned}\Psi(x, t) & =\Phi(x) e^{-\frac{i}{\hbar} E t}=\sqrt{\frac{2}{a}} \sin k x e^{-\frac{i}{\hbar} E t} \\& =\frac{1}{2 i} \sqrt{\frac{2}{a}}\left(e^{i k x}-e^{-i k x}\right) e^{-\frac{i}{\hbar} E t} \\& =\frac{1}{2 i} \sqrt{\frac{2}{a}}\left[e^{-\frac{i}{\hbar}(E t-p x)}-e^{-\frac{i}{\hbar}(E t+p x)}\right] \quad\left(k=\frac{p}{\hbar}\right) \\k a=n \pi & \Rightarrow \frac{2 \pi}{\lambda} a=n \pi \Rightarrow a=n \frac{\lambda}{2} \quad n=1,2,3 \cdots\end{aligned}</script><h3 id="无限深势井薛定谔方程通解"><a href="#无限深势井薛定谔方程通解" class="headerlink" title="无限深势井薛定谔方程通解"></a>无限深势井薛定谔方程通解</h3><p>通解可以写成定态解叠加的形式</p><script type="math/tex; mode=display">\psi(x,t)=\sum_{n}c_n\psi_{n}(x,t)=\sum_{n}c_n\phi_{n}(x)e^{-\frac{i}{\hbar}E_nt}</script><p>其中 $c_n$ 称为展开系数。给定初始状态 $\psi(x,0)$，$c_n$ 可以计算出来</p><script type="math/tex; mode=display">c_n=\int_{-\infty}^{+\infty}\phi_{n}^{*}(x)\psi(x,0)\mathrm{d}x</script><p>$\left\vert c<em>n \right\vert ^{2}$ 可以表示系统处于态 $\psi(x,t)$ 对能量测量时，得到结果是 $E_n$ 的概率。从另一个角度来说，$\bar{E}=\displaystyle \int</em>{-\infty}^{+\infty}\psi^{*}(x,t)\hat{H}\psi(x,t)\mathrm{d}x=\sum_{n=1}^{\infty}\left\vert c_n \right\vert^{2} E_n$。</p>]]></content>
      
      
      <categories>
          
          <category> 量子力学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>任意观测量的不确定度关系</title>
      <link href="/posts/303505df.html"/>
      <url>/posts/303505df.html</url>
      
        <content type="html"><![CDATA[<h2 id="不同力学量同时有确定值的条件"><a href="#不同力学量同时有确定值的条件" class="headerlink" title="不同力学量同时有确定值的条件"></a>不同力学量同时有确定值的条件</h2><p>当体系处于力学量 $F$ 的本征态时，测量 $F$ 得到的是确定值，即该本征态对应的本征值。但如果在该状态下测量力学量 $G$，并不一定能得到确定值。如果两个力学量有共同的本征态，且处于该本征态时，才能都得到确定值。</p><p>可以证明，<em>$\hat{F}$ 与 $\hat{G}$ 对易 $\Rightarrow$ 力学量 $F$ 和 $G$ 具有共同本征态。</em><br>如果一组算符有共同的本征函数，且这些本征函数组成完全系 $\Rightarrow$ 这组算符中任意一个算符与其他所有算符对易。</p><h3 id="如何完全确定系统状态"><a href="#如何完全确定系统状态" class="headerlink" title="如何完全确定系统状态"></a>如何完全确定系统状态</h3><p>为完全确定状态所需的一组两两对易的力学量算符的最小（数目）集合称为<strong>力学量完全集</strong>。</p><p>假如有一组彼此独立相互对易的厄密算符 $\hat{A}(\hat{A}<em>{1},\hat{A}</em>{2}, \ldots )$，根据上面的性质，它们有一组共同的本征函数 $\phi<em>{n}$，可以用这组本征函数确定体系的一个可能状态，那么 $(\hat{A}</em>{1},\hat{A}_{2}, \ldots )$ 构成系统的一个力学量完全集。<br><em>力学量完全集包含的力学量数目等于体系的自由度</em>。体系的任何状态都可以用力学量完全集所确定的本征函数系展开</p><script type="math/tex; mode=display">\psi=\sum_{n}a_n \phi_{n}</script><p>例如：<br>一维运动粒子波函数可以用动量本征态 $\phi_{p}\sim e^{ipx /\hbar}$ 展开</p><script type="math/tex; mode=display">\psi(x)=\int C(p)e^{ipx /\hbar} \frac{\mathrm{d}p}{\sqrt{2\pi \hbar}}</script><p>故动量构成一维运动粒子的一个力学量完全集。如果是三维运动粒子，它的一个力学完全集可以是动量的三个分量 $(p_{x},p_y,p_z)$。</p><h2 id="不确定度关系的说明"><a href="#不确定度关系的说明" class="headerlink" title="不确定度关系的说明"></a>不确定度关系的说明</h2><p>两个力学量 $\hat{A},\hat{B}$，若彼此不对易 $[\hat{A},\hat{B}]\neq 0$，则一般不能同时有确定值。在任一量子态中，其测量值的不确定程度满足不确定度关系 $\displaystyle \Delta A \Delta B\ge \frac{1}{2}\left\vert \lang [\hat{A},\hat{B}]\rang \right\vert$</p><p>$\Delta A,\Delta B$ 的定义：</p><script type="math/tex; mode=display">(\Delta A)^{2}=\int \psi^{*}(\hat{A}-\lang \hat{A} \rang)^{2} \psi \mathrm{d}^{3}r =\lang \psi|(\hat{A}-\lang \hat{A} \rang)^{2}|\psi \rang</script><script type="math/tex; mode=display">(\Delta B)^{2}=\int \psi^{*}(\hat{B}-\lang \hat{B} \rang)^{2} \psi \mathrm{d}^{3}r =\lang \psi|(\hat{B}-\lang \hat{B} \rang)^{2}|\psi \rang</script><p>其中 $\Delta A,\Delta B$ 分别是力学量 $\hat{A},\hat{B}$ 的方均根偏差，代表它们的不确定度，反映的是测量时的涨落。</p><p>例子：</p><script type="math/tex; mode=display">\because [x,\hat{p}_{x}]=i \hbar \quad \therefore  \Delta x\Delta p_{x}\ge \frac{\hbar}{2}</script><p>验证了海森堡不确定性关系。</p>]]></content>
      
      
      <categories>
          
          <category> 量子力学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动量算符和角动量算符</title>
      <link href="/posts/78542535.html"/>
      <url>/posts/78542535.html</url>
      
        <content type="html"><![CDATA[<h2 id="动量算符"><a href="#动量算符" class="headerlink" title="动量算符"></a>动量算符</h2><p>动量算符 $\hat{\vec{p}}=-i\hbar \nabla$，分量形式 $\hat{p}<em>{x}=-i\hbar \frac{\partial }{\partial x},\hat{p}</em>{y}=-i\hbar \frac{\partial }{\partial y},\hat{p}_{z}=-i\hbar \frac{\partial }{\partial z}$。</p><p>动量算符各分量和坐标算符各分量之间的对易关系；</p><script type="math/tex; mode=display">[\hat{x}_i,\hat{p}_j]=i\hbar \delta_{ij}=\begin{cases}    0,& i\neq j \\    i \hbar ,&i=j\end{cases}</script><p>动量平方算符</p><script type="math/tex; mode=display">\hat{\vec{p}}^{2}=\hat{p}_{x}^{2}+\hat{p}_{y}^{2}+\hat{p}_{z}^{2}=-\hbar^{2}\nabla ^{2}</script><h2 id="角动量算符"><a href="#角动量算符" class="headerlink" title="角动量算符"></a>角动量算符</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><script type="math/tex; mode=display">\hat{\bm{L}}=\hat{\bm{r}}\times \hat{\bm{p}}=-i \hbar (\bm{r}\times \nabla )</script><p>分量形式</p><script type="math/tex; mode=display">\begin{aligned}\hat{L}_{x}&=y \hat{p}_{z} - z \hat{p}_{y}=-i \hbar (y\frac{\partial }{\partial z}-z\frac{\partial }{\partial y}) \\\hat{L}_{y}&=z \hat{p}_{x}-x p_{z}=-i \hbar (z \frac{\partial }{\partial x}-x \frac{\partial }{\partial z}) \\\hat{L}_{z}&=x \hat{p}_{y}-y \hat{p}_{x}=-i \hbar (x \frac{\partial }{\partial y}-y \frac{\partial }{\partial x})\end{aligned}</script><p>角动量平方算符</p><script type="math/tex; mode=display">\hat{\bm{L}}^{2}=\hat{L}_{x}^{2}+\hat{L}_y^{2}+\hat{L}_z^{2}</script><h3 id="角动量算符各分量对易式"><a href="#角动量算符各分量对易式" class="headerlink" title="角动量算符各分量对易式"></a>角动量算符各分量对易式</h3><p>角动量各分量之间不对易</p><script type="math/tex; mode=display">\begin{aligned}[\hat{L}_{x},\hat{L}_y]&=\hat{L}_{x}\hat{L}_y-\hat{L}_y \hat{L}_{x} \\&=(y \hat{p}_z-z \hat{p}_y)(z \hat{p}_{x}-x \hat{p}_z)-(z \hat{p}_{x}-x \hat{p}_z)(y \hat{p}_z- z \hat{p}_y)\\&=(\hat{p}_z z- z\hat{p}_z)y \hat{p}_{x} +(z \hat{p}_z-\hat{p}_z z)x \hat{p}_y\\&=-i\hbar y \hat{p}_{x}+i \hbar x \hat{p}_y=i \hbar (x \hat{p}_y-y \hat{p}_{x} )=i \hbar \hat{L}_z\end{aligned}</script><p>同理 $[\hat{L}<em>y,\hat{L}_z]=i\hbar \hat{L}</em>{x}$, $[\hat{L}<em>z,\hat{L}</em>{x}]=i\hbar \hat{L}_y$ $\Rightarrow$ $\hat{\bm{L}}\times \hat{\bm{L}}=i \hbar \hat{\bm{L}}$</p><p>角动量平方算符与其各分量之间是对易的</p><script type="math/tex; mode=display">\begin{aligned}[\hat{L}^{2},\hat{L}_{x}]&=[\hat{L}_{x}^{2}+\hat{L}_{y}^{2}+\hat{L}_z^{2},\hat{L}_{x}]\overset{[\hat{L}_{x}^{2},\hat{L}_{x}=0]}{=} [\hat{L}_y^{2},\hat{L}_{x}]+[\hat{L}_z^{2},\hat{L}_{x}] \\&=\hat{L}_y[\hat{L}_y,\hat{L}_{x}]+[\hat{L}_y,\hat{L}_{x}]\hat{L}_y+\hat{L}_z[\hat{L}_z,\hat{L}_{x}]+[\hat{L}_z,\hat{L}_{x}]\hat{L}_z\\&=i \hbar (-\hat{L}_y \hat{L}_z-\hat{L}_z \hat{L}_y + \hat{L}_z \hat{L}_y+ \hat{L}_y \hat{L}_z)=0\end{aligned}</script><p>同理 $[\hat{L}^{2},\hat{L}_y]=0$,$[\hat{L}^{2},\hat{L}_z]=0$</p><h2 id="球坐标系中的角动量-不要求记忆"><a href="#球坐标系中的角动量-不要求记忆" class="headerlink" title="球坐标系中的角动量(不要求记忆)"></a>球坐标系中的角动量(不要求记忆)</h2><script type="math/tex; mode=display">\begin{aligned}\hat{L}_{x}&=i \hbar\left(\sin \varphi \frac{\partial}{\partial \theta}+\operatorname{ctg} \theta \cos \varphi \frac{\partial}{\partial \varphi}\right) \\\hat{L}_{y}&=-i \hbar\left(\cos \varphi \frac{\partial}{\partial \theta}-\operatorname{ctg} \theta \sin \varphi \frac{\partial}{\partial \varphi}\right) \\\hat{L}_{z}&=-i \hbar \frac{\partial}{\partial \varphi} \end{aligned}</script><script type="math/tex; mode=display">\hat{\mathbf{L}}^{2}=\hat{L}_{x}^{2}+\hat{L}_{y}^{2}+\hat{L}_{z}^{2}=-\hbar^{2}\left[\frac{1}{\sin \theta} \frac{\partial}{\partial \theta}\left(\sin \theta \frac{\partial}{\partial \theta}\right)+\frac{1}{\sin ^{2} \theta} \frac{\partial^{2}}{\partial \varphi^{2}}\right]</script><script type="math/tex; mode=display">\begin{aligned}\nabla^{2}&=\frac{1}{r^{2}}\left[\frac{\partial}{\partial r}\left(r^{2} \frac{\partial}{\partial r}\right)+\frac{1}{\sin \theta} \frac{\partial}{\partial \theta}\left(\sin \theta \frac{\partial}{\partial \theta}\right)+\frac{1}{\sin ^{2} \theta} \frac{\partial^{2}}{\partial \varphi^{2}}\right] \\&=\frac{1}{r^{2}}\left[\frac{\partial}{\partial r}\left(r^{2} \frac{\partial}{\partial r}\right)-\frac{\hat{\mathbf{L}}^{2}}{\hbar^{2}}\right]\end{aligned}</script><h2 id="角动量算符的本征函数和本征值"><a href="#角动量算符的本征函数和本征值" class="headerlink" title="角动量算符的本征函数和本征值"></a>角动量算符的本征函数和本征值</h2><h3 id="hat-L-z-算符的本征值和本征函数"><a href="#hat-L-z-算符的本征值和本征函数" class="headerlink" title="$\hat{L}_z$ 算符的本征值和本征函数"></a>$\hat{L}_z$ 算符的本征值和本征函数</h3><p>球坐标系中，$\displaystyle \hat{L}_z=-i\hbar \frac{\partial }{\partial \varphi}$</p><script type="math/tex; mode=display">\hat{L}_z \psi =l_z \psi \Rightarrow -i \hbar \frac{\partial }{\partial \varphi} \psi=l_z \psi</script><p>解得</p><script type="math/tex; mode=display">\psi(\varphi)=C \exp (\frac{i}{\hbar}l_z \varphi)</script><p>同时考虑到 $\varphi$ 和 $\varphi+2\pi$ 时系统处于同一状态，得到</p><script type="math/tex; mode=display">l_z=m \hbar , \quad m \in \mathbb{Z}</script><p>$l_z=m \hbar$ 为算符 $l_z$ 的本征值，对应的本征函数为</p><script type="math/tex; mode=display">\psi_{m}(\varphi)=C e^{im \varphi} \xrightarrow{\text{归一化}} \psi_{m}(\varphi)=\frac{1}{\sqrt{2\pi}} e^{im \varphi}</script><h3 id="球谐函数"><a href="#球谐函数" class="headerlink" title="球谐函数"></a>球谐函数</h3><p>球谐函数 $Y_{lm}(\theta, \varphi)$ 是 $\hat{L}^{2}$ 和 $\hat{L}_z$ 的共同本征波函数(下式要记)</p><script type="math/tex; mode=display">\begin{cases}    \hat{L}^{2}Y_{l m}(\theta, \varphi)=l(l+1)\hbar^{2}Y_{l m}(\theta,\varphi) \\    \hat{L}_zY_{l m}(\theta,\varphi)=m \hbar Y_{l m}(\theta,\varphi)\\    l=0,1,2, \ldots \quad m=-l,-l+1, \ldots ,0, \ldots l-1,l\end{cases}</script><p>$l$ 表征了角动量的大小，称为角量子数；$m$ 称为磁量子数，与原子光谱在外磁场中发生分裂有关，每一个 $l$ 值对应 $2l+1$ 个 $m$。在无外磁场时，角量子数为 $l$ 的量子态是 $2l+1$ 重简并的。$\hat{L}^{2},\hat{L}_z$ 的本征值谱都是分立的，量子数为 $l$ 和 $m$。</p><p>在 $Y_{l m}(\theta,\varphi)$ 的状态下，角动量大小为 $L=\sqrt{l(l+1)\hbar}$，角动量在 $z$ 方向上的投影 $L_z=m\hbar$。因此可以看出，角动量的空间取向是量子化的。</p><p>正交归一化条件：</p><script type="math/tex; mode=display">\int_{0}^{2\pi}\mathrm{d}\varphi \int_{0}^{2\pi}\sin \theta \mathrm{d} \theta Y_{l m}^{*}(\theta,\varphi)^{*} Y_{l'm'}(\theta,\varphi)=\delta_{ll'}\delta_{mm'}</script><h2 id="补充：量子力学五大假设"><a href="#补充：量子力学五大假设" class="headerlink" title="补充：量子力学五大假设"></a>补充：量子力学五大假设</h2><ul><li>粒子的态可以用波函数描述</li><li>力学量对应算符一定是线性的厄密算符</li><li>测量假设：对力学量进行测量，得到的一定是本征值中的一个</li><li>态的演化可以用薛定谔方程描述</li><li>多粒子系统中粒子不可分辨</li></ul>]]></content>
      
      
      <categories>
          
          <category> 量子力学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux插入内核模块报错</title>
      <link href="/posts/5aac262c.html"/>
      <url>/posts/5aac262c.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo insmod simple.ko</span><br></pre></td></tr></table></figure><p>输出 <code>insmod: ERROR: could not insert module simple.ko: Invalid module format</code>。</p><h2 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因"></a>可能原因</h2><p>根据chatgpt的回复，可能的原因有：</p><ol><li>内核版本不匹配：该模块是在另一个内核版本中编译的，与当前运行的内核版本不兼容。检查一下该模块所支持的内核版本，确保它与当前运行的内核版本相匹配。</li><li>架构不匹配：该模块是为另一个 CPU 架构编译的，与当前 CPU 架构不兼容。例如，在 x86 平台上编译的模块无法在 ARM 平台上加载。检查一下该模块所支持的 CPU 架构，确保它与当前的 CPU 架构相匹配。</li><li>编译错误：该模块编译时出现了错误，可能是由于编译器版本不兼容或编译选项不正确等原因导致。检查一下该模块的编译日志，查找任何编译错误或警告。</li></ol><h3 id="查询内核版本"><a href="#查询内核版本" class="headerlink" title="查询内核版本"></a>查询内核版本</h3><p>首先查询当前Linux的运行的内核版本：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure></p><p>得到 <code>5.15.0-69-generic</code>。然后查询<code>.ko</code>文件所支持的内核版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modinfo simple.ko</span><br></pre></td></tr></table></figure></p><p>得到<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filename:       /home/zxz/final-src-osc10e/ch2/simple.ko</span><br><span class="line">author:         SGG</span><br><span class="line">description:    Simple Module</span><br><span class="line">license:        GPL</span><br><span class="line">srcversion:     864167AB1A7021659306236</span><br><span class="line">depends:        </span><br><span class="line">retpoline:      Y</span><br><span class="line">name:           simple</span><br><span class="line">vermagic:       5.15.0-69-generic SMP mod_unload modversions </span><br></pre></td></tr></table></figure></p><p>说明内核版本没有问题。</p><h3 id="查询CPU架构"><a href="#查询CPU架构" class="headerlink" title="查询CPU架构"></a>查询CPU架构</h3><p>首先查询模块文件的对应架构<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file simple.ko</span><br></pre></td></tr></table></figure></p><p>得到 <code>simple.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=b56d8837eacb05001d12de71890131fa97b8902f, with debug_info, not stripped</code></p><p>然后再查询内核对应的CPU架构<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -m</span><br></pre></td></tr></table></figure></p><p>然后得到 <code>x86_64</code>。说明架构一致。</p><h3 id="编译情况"><a href="#编译情况" class="headerlink" title="编译情况"></a>编译情况</h3><p>再次运行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure></p><p>得到输出<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">make -C /lib/modules/5.15.0-69-generic/build M=/home/zxz/final-src-osc10e/ch2 modules</span><br><span class="line">make[1]: Entering directory &#x27;/usr/src/linux-headers-5.15.0-69-generic&#x27;</span><br><span class="line">  CC [M]  /home/zxz/final-src-osc10e/ch2/simple.o</span><br><span class="line">  MODPOST /home/zxz/final-src-osc10e/ch2/Module.symvers</span><br><span class="line">  CC [M]  /home/zxz/final-src-osc10e/ch2/simple.mod.o</span><br><span class="line">  LD [M]  /home/zxz/final-src-osc10e/ch2/simple.ko</span><br><span class="line">make[1]: Leaving directory &#x27;/usr/src/linux-headers-5.15.0-69-generic&#x27;</span><br></pre></td></tr></table></figure></p><p>可以看出编译过程正常。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>参考了<a href="https://stackoverflow.com/questions/71746914/linux-kernel-module-development-module-x86-modules-skipping-invalid-relocatio?noredirect=1">stackoverflow</a>中的一个回答。需要运行如下指令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update # 更新系统的软件包列表</span><br><span class="line">sudo apt upgrade # 升级已经安装的软件包和系统</span><br><span class="line">sudo apt remove --purge linux-headers-* # 删除现有的所有linux-headers</span><br><span class="line">sudo apt autoremove # 自动删除系统中已经不再需要的软件包及其依赖项</span><br><span class="line">sudo apt autoclean # 会删除系统中已经过期的软件包缓存文件</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo apt install linux-headers-generic</span></span><br><span class="line">sudo apt-get install linux-headers-$(uname -r) # 安装与当前运行内核相一致的linux-header</span><br></pre></td></tr></table></figure></p><p>然而之前的操作似乎删除了 <code>linux-source</code>，因此我又重新装了一遍。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install linux-source</span><br></pre></td></tr></table></figure></p><p>之后再运行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo make</span><br><span class="line">sudo insmod simple.ko</span><br></pre></td></tr></table></figure></p><p>就没有再出现问题。</p><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p>尽管最后成功了，但还是很奇怪，因为现在的 <code>linux-source</code> 模块和 <code>uname -r</code> 输出的当前运行模块是不相符的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> operating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter11-12 Storage management</title>
      <link href="/posts/28253751.html"/>
      <url>/posts/28253751.html</url>
      
        <content type="html"><![CDATA[<h2 id="存储设备"><a href="#存储设备" class="headerlink" title="存储设备"></a>存储设备</h2><p>HDD（Hard Disk Drive）：机械硬盘<br>SSD（Solid State Drive）：固态硬盘</p><h3 id="机械硬盘"><a href="#机械硬盘" class="headerlink" title="机械硬盘"></a>机械硬盘</h3><h4 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h4><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/Disk_Drive.png" width=500></div><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>磁极方向表示数据，用加热的方式改变磁极方向。</p><h4 id="硬盘结构图"><a href="#硬盘结构图" class="headerlink" title="硬盘结构图"></a>硬盘结构图</h4><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/structure_of_disk.png" width=400></div><p>Disk $\rightarrow$ platter $\rightarrow$ surface $\rightarrow$ track $\rightarrow$ sector $\rightarrow$ block</p><p>其中sector由gap分开。<br>每个paltter有两个surface，每个surface上都有磁头可以读写。</p><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/sector_and_gap.png" width=400></div><h4 id="访问时间"><a href="#访问时间" class="headerlink" title="访问时间"></a>访问时间</h4><script type="math/tex; mode=display">T_{access} = T_{seek} + T_{rot} + T_{lat}</script><p>$T<em>{seek}$ 表示的是磁头移动到磁道(track)的时间；$T</em>{rot}$ 表示的是磁头在磁道上旋转的时间，这一步需要找到正确的sector；$T_{lat}$ 表示的是磁头在磁道上等待，也就是数据传输的时间。</p><p>$T_{rot}$ 与参数RPM有关，RPM指的是每分钟转动的圈数，单位为 $r/min$。</p><p>$T_{lat}$ 与参数BPS有关，BPS指的是每秒传输的bit数，单位为 $bit/s$。</p><h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><h4 id="总体结构-1"><a href="#总体结构-1" class="headerlink" title="总体结构"></a>总体结构</h4><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/flash_chip.png" width=400></div><p>图中的flash chip是基本的存储单元。</p><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/flash_die_layout.png" width=400></div><ul><li><strong>Die</strong>: Semiconductor wafers are cut from a block of electronic-grade silicon. The piece of wafer cut from the block is referred to as a die.</li><li><strong>Plane</strong>: One die contains one to two planes. Planes can (generally) execute identical operations together.</li><li><strong>Block</strong>: Planes contain varying numbers of blocks. NAND Flash cells can only be erased at the block level.</li><li><strong>Page</strong>: Blocks usually contain around 128 pages. Pages are the smallest units that can be programmed (or written to)</li></ul><h4 id="Flash颗粒结构"><a href="#Flash颗粒结构" class="headerlink" title="Flash颗粒结构"></a>Flash颗粒结构</h4><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/flash_cell.png" width=600></div><p>以上是一个Flash颗粒的结构图，就是一个MOS管。</p><p>Flash是组成固态硬盘的颗粒，同时闪存也可以用来做U盘。</p><h4 id="SLC-MLC-TLC-QLC-Flash"><a href="#SLC-MLC-TLC-QLC-Flash" class="headerlink" title="SLC, MLC, TLC, QLC Flash"></a>SLC, MLC, TLC, QLC Flash</h4><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/slc_flash.png" width=500></div><p>就是让一个flash颗粒存储更多位的数据。方式是让不同范围的电压表示不同的数据。例如对于MLC来说，一种可行的数据表示方式如下：</p><script type="math/tex; mode=display">electron\ number>80\% \rightarrow 11\\60\sim 80\% \rightarrow 10\\40\sim 60\% \rightarrow 01\\<20\% \rightarrow 00</script><p>但是存储的数量越多，就越容易出错，耐久性也越低。所以一般来说，SLC的可靠性最高，QLC的可靠性最低。</p><h4 id="Wear-Leveling"><a href="#Wear-Leveling" class="headerlink" title="Wear Leveling"></a>Wear Leveling</h4><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/wear_leveling.png" width=600></div><p>使用过程中可能有些位置读写较多，有些较少。所以就通过数据存储位置的调整来保证每个位置的使用均匀。</p><h2 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I/O接口"></a>I/O接口</h2><h3 id="各种的I-O接口"><a href="#各种的I-O接口" class="headerlink" title="各种的I/O接口"></a>各种的I/O接口</h3><p>ATA/IDE:<br>ATA（Advanced Technology Attachment）是一种硬盘接口标准，而IDE（Integrated Drive Electronics）指的是Parallel ATA（PATA）的一种实现方式。</p><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/ATA_IDE.png" width=400></div><p>SATA:<br>Serial ATA（SATA）是一种硬盘接口标准，是ATA的升级版。采用了串行的方式传输数据，而不是并行的方式，使得数据传输速度更快。这是如今主流使用的接口。</p><p>SCSI:<br>SCSI（Small Computer System Interface）主要用于大容量数据传输（如数据中心）。</p><p>SAS:<br>Serial Attached SCSI（SAS）是一种硬盘接口标准，是SCSI的升级版。采用了串行的方式传输数据。</p><p>USB:<br>Universal Serial Bus（USB）是一种硬盘接口标准，是一种通用的接口，可以支持多种设备。主要用于小容量数据传输。</p><p>PCIe:<br>PCI Express（PCIe）是一种硬盘接口标准，是一种高速的接口，可以支持多个硬盘。主要用于大容量数据传输。</p><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/PCIe.png" width=500></div><p>PCIe的插槽越长，接口数量越多，传输速度越快。现在的GPU和SSD都是通过PCIe接口连接的。</p><h3 id="A-Typical-PC-Bus-Structure"><a href="#A-Typical-PC-Bus-Structure" class="headerlink" title="A Typical PC Bus Structure"></a>A Typical PC Bus Structure</h3><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/pc_bus_structure.png" width=600></div><h3 id="Polling"><a href="#Polling" class="headerlink" title="Polling"></a>Polling</h3><p>I/O调度的方法和CPU类似。Polling是将各种I/O请求放到一起，然后一次处理多个请求。</p><h3 id="DMA-transfer"><a href="#DMA-transfer" class="headerlink" title="DMA transfer"></a>DMA transfer</h3><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/dma_transfer.png" width=600></div><h3 id="A-Kernel-I-O-Structure"><a href="#A-Kernel-I-O-Structure" class="headerlink" title="A Kernel I/O Structure"></a>A Kernel I/O Structure</h3><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/kernel_IO_structure.png" width=600></div><h2 id="硬盘调度算法"><a href="#硬盘调度算法" class="headerlink" title="硬盘调度算法"></a>硬盘调度算法</h2><p>主要优化的是寻道时间。</p><p>以下用一个例子展示各种算法。当先Head pointer在 53，后面请求数据的硬盘位置在98, 183, 37, 122, 14, 124, 65, 67。</p><h3 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h3><p>First Come First Serve，先来先服务。先到先服务。</p><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/FCFS.png" width=500></div><h3 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h3><p>SCAN（Elevator）算法，电械臂扫描算法。</p><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/SCAN.png" width=500></div><p>从任意两个方向都可以先走，但一般优先更短的。</p><p>优化之后有LOOK算法，可以不用走到头。（如在上图中不用到达位置0）</p><p>SCAN算法有个问题，就是可能会导致各个请求等待时间不一定最短。因此有了C-SCAN算法。</p><h3 id="C-SCAN"><a href="#C-SCAN" class="headerlink" title="C-SCAN"></a>C-SCAN</h3><p>Circular SCAN，循环扫描算法。</p><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/C-SCAN.png" width=500></div><p>先扫描请求多的一侧，然后快速倒回，再扫描剩下的。</p><h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>checksum：对原数据取模<br>CRC(cyclic redundancy check)：用哈希函数<br>ECC：有一定的纠错能力</p><h3 id="RAID-redundant-array-of-inexpensive-disks"><a href="#RAID-redundant-array-of-inexpensive-disks" class="headerlink" title="RAID(redundant array of inexpensive disks)"></a>RAID(redundant array of inexpensive disks)</h3><p>Storage Array（存储阵列）。 A set of disks from one or more commonly accessible disk subsystems, combined with a body of control software.<br>原因：内存比硬盘快很多，因此多个硬盘对一个内存。</p><h4 id="JBOD"><a href="#JBOD" class="headerlink" title="JBOD"></a>JBOD</h4><p>Just a Bunch of Disks。仅仅实现了将一个硬盘互联，同时对接一个内存的操作。没有校验能力。</p><h4 id="RAID-Array-Components"><a href="#RAID-Array-Components" class="headerlink" title="RAID Array Components"></a>RAID Array Components</h4><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/raid_array_components.png" width=500></div><p>中间的controller用于调度。</p><p>RAID的几种方法：strip（分条），Mirroring（镜像，即复制数据作为备份），Parity（校验，同样有一定恢复数据的能力）</p><h4 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID-0"></a>RAID-0</h4><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/raid0.png" width=150></div>仅仅提供了更好的读写性能。只使用了strip方法。#### RAID-1<div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/raid1.png" width=150></div>使用了mirroring方法，对数据做了备份。但是会造成双倍的空间被占用。#### RAID-4<div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/raid4.png" width=400></div><p>使用了parity方法。最后一个硬盘放的是校验位。如果出错，可以通过异或的计算恢复原来的数据。（parity就是根据异或计算出来的）</p><h4 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID-5"></a>RAID-5</h4><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/raid5.png" width=400></div><p>Distributed Parity。因为校验位需要不断地被写入，导致对应硬盘寿命更短。因此采用将校验位分布在各个硬盘的方法，让最后的负载均衡。</p><h4 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID-6"></a>RAID-6</h4><div align=center><img src="../../figure/operating-system/Chapter11-12-Storage-management/raid6.png" width=500></div><p>double parity。即如果同时错了两个位，同样能做修正。例如</p><script type="math/tex; mode=display">\begin{cases}    A_1 \oplus A_2 \oplus A_3 =A_p\\    A_1 \oplus 2A_2 \oplus 4A_3 =A_q\end{cases}</script><p>这样即使 $A_1,A_2,A_3$中有两个位丢失，同样可以修正回来。</p>]]></content>
      
      
      <categories>
          
          <category> Operating system </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>latex写伪代码</title>
      <link href="/posts/861f8bbe.html"/>
      <url>/posts/861f8bbe.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言部分"><a href="#引言部分" class="headerlink" title="引言部分"></a>引言部分</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[linesnumbered,ruled,vlined]&#123;algorithm2e&#125;</span><br></pre></td></tr></table></figure><p>这个宏包用于排版算法，提供了一些命令和环境，可以生成带有行号、注释、缩进等的算法代码。其中，<code>linesnumbered</code>选项可以添加行号，<code>ruled</code>选项可以生成横线，<code>vlined</code>选项可以在每个语句前面添加竖线，使得排版的算法代码更加美观和易读。</p><h2 id="伪代码写作"><a href="#伪代码写作" class="headerlink" title="伪代码写作"></a>伪代码写作</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\IncMargin</span>&#123;1em&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;[H] </span><br><span class="line"><span class="keyword">\SetKwData</span>&#123;Left&#125;&#123;left&#125;<span class="keyword">\SetKwData</span>&#123;This&#125;&#123;this&#125;<span class="keyword">\SetKwData</span>&#123;Up&#125;&#123;up&#125; <span class="keyword">\SetKwFunction</span>&#123;Union&#125;&#123;Union&#125;</span><br><span class="line"><span class="keyword">\SetKwFunction</span>&#123;FindCompress&#125;&#123;FindCompress&#125; <span class="keyword">\SetKwInOut</span>&#123;Input&#125;&#123;input&#125;<span class="keyword">\SetKwInOut</span>&#123;Output&#125;&#123;output&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">\Input</span>&#123;A directed graph <span class="built_in">$</span>G=(V,E)<span class="built_in">$</span>&#125;</span><br><span class="line">    <span class="keyword">\Output</span>&#123;A reversed graph <span class="built_in">$</span>G<span class="built_in">^</span>R=(V,E<span class="built_in">^</span>R)<span class="built_in">$</span>&#125;</span><br><span class="line">    <span class="keyword">\BlankLine</span></span><br><span class="line">    <span class="keyword">\For</span>&#123;<span class="built_in">$</span>v <span class="keyword">\in</span> V<span class="built_in">$</span>&#125;&#123;<span class="built_in">$</span>G<span class="built_in">^</span>&#123;R&#125;<span class="built_in">$</span>.adj<span class="keyword">\_</span>list[v]=[]&#125;</span><br><span class="line">    <span class="keyword">\For</span>&#123;<span class="built_in">$</span>u <span class="keyword">\in</span> V<span class="built_in">$</span>&#125;&#123;</span><br><span class="line">        <span class="keyword">\For</span>&#123;<span class="built_in">$</span>v <span class="keyword">\in</span> G.adj<span class="keyword">\_</span>list[u]<span class="built_in">$</span>&#125;&#123;</span><br><span class="line">            <span class="built_in">$</span>G<span class="built_in">^</span>&#123;R&#125;<span class="built_in">$</span>.adj<span class="keyword">\_</span>list[v].append(u)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;Graph reversal algorithm&#125;</span><br><span class="line">    <span class="keyword">\label</span>&#123;alg:graph-reversal&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125;</span><br><span class="line"><span class="keyword">\DecMargin</span>&#123;1em&#125;</span><br></pre></td></tr></table></figure><h3 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h3><ul><li><code>\IncMargin&#123;1em&#125;</code>和<code>\DecMargin&#123;1em&#125;</code>是<code>algorithm2e</code>宏包提供的命令，用于控制算法环境中的缩进，<code>\IncMargin</code>用于增加缩进，<code>\DecMargin</code>用于减少缩进，参数1em表示缩进的距离为1个字号的宽度。</li><li><code>\begin&#123;algorithm&#125;[H]</code>和<code>\end&#123;algorithm&#125;</code>是算法环境的开始和结束标记，其中选项[H]表示强制将算法排版在当前位置，不浮动到其他页面或位置。</li><li><code>\caption&#123;Graph reversal algorithm&#125;</code>命令用于设置算法的标题，<code>\label&#123;alg:graph-reversal&#125;</code>命令用于为算法添加标签，方便在文中引用该算法。</li><li><code>\SetKwData&#123;Left&#125;&#123;left&#125;\SetKwData&#123;This&#125;&#123;this&#125;\SetKwData&#123;Up&#125;&#123;up&#125;</code>和<code>\SetKwFunction&#123;Union&#125;&#123;Union&#125;\SetKwFunction&#123;FindCompress&#125;&#123;FindCompress&#125;</code>分别定义了三个变量和两个函数，用于在算法中使用。<code>\SetKwInOut&#123;Input&#125;&#123;input&#125;\SetKwInOut&#123;Output&#125;&#123;output&#125;</code>定义了两个输入输出命令，用于说明算法的输入和输出。</li></ul><p><code>\SetKwInOut&#123;Input&#125;&#123;input&#125;</code> 这段代码表示，在代码的输入部分使用 <code>\Input</code> 进行输入:<code>\Input&#123;A directed graph $G=(V,E)$&#125;</code>。同时在伪代码显示时显示 ‘input’ 如图</p><h3 id="伪代码语法"><a href="#伪代码语法" class="headerlink" title="伪代码语法"></a>伪代码语法</h3>]]></content>
      
      
      <categories>
          
          <category> latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>latex插入图片</title>
      <link href="/posts/c56f9fd.html"/>
      <url>/posts/c56f9fd.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言部分"><a href="#引言部分" class="headerlink" title="引言部分"></a>引言部分</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;float&#125;</span><br></pre></td></tr></table></figure><ul><li><code>graphicx</code>：这个宏包用于支持插入和操作图形文件。它提供了一些命令和选项，可以插入各种格式的图像文件，例如<code>\includegraphics</code>命令可以插入图片文件，<code>\scalebox</code>命令可以调整图片的大小等。</li><li><code>float</code>：这个宏包用于控制浮动体的位置和格式。它提供了一些命令和选项，可以将图片、表格等浮动体放置在适当的位置，并设置其标题、标签等格式，例如[H]选项可以将浮动体固定在当前位置，<code>\caption</code>命令可以设置浮动体的标题等。</li></ul><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[H]</span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=1.0<span class="keyword">\textwidth</span>]&#123;figure/模拟波形.png&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;仿真波形图&#125;</span><br><span class="line">    <span class="keyword">\label</span>&#123;fig:example&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure><ul><li><code>\begin&#123;figure&#125;[H]</code> 指定了将图片固定在当前位置，不到处乱跑</li><li><code>[width=1.0\textwidth]</code> 将插入的图片宽度设置为当前页面的宽度，即将图片的宽度设置为文本宽度的100%。这样做可以确保图片的宽度与当前页面的宽度相同。</li></ul>]]></content>
      
      
      <categories>
          
          <category> latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex插入代码块</title>
      <link href="/posts/1bc4beea.html"/>
      <url>/posts/1bc4beea.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言部分"><a href="#引言部分" class="headerlink" title="引言部分"></a>引言部分</h2><p>首先导入宏包<br><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;listings&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;xcolor&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>xcolor</code>：这个宏包用于支持使用颜色。它提供了一些命令和选项，可以定义和使用颜色，例如<code>\color</code>命令可以在文本中改变字体颜色，<code>\pagecolor</code>命令可以改变页面背景颜色等。</li></ul><p>同时对代码样式做出设置<br><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\lstset</span>&#123;</span><br><span class="line">  language=verilog,  <span class="comment">%代码语言使用的是verilog</span></span><br><span class="line">  frame=shadowbox, <span class="comment">%把代码用带有阴影的框圈起来</span></span><br><span class="line">  rulesepcolor=<span class="keyword">\color</span>&#123;red!20!green!20!blue!20&#125;,<span class="comment">%代码块边框为淡青色</span></span><br><span class="line">  keywordstyle=<span class="keyword">\color</span>&#123;blue!90&#125;<span class="keyword">\bfseries</span>, <span class="comment">%代码关键字的颜色为蓝色，粗体</span></span><br><span class="line">  commentstyle=<span class="keyword">\color</span>&#123;red!10!green!70&#125;<span class="keyword">\textit</span>,    <span class="comment">% 设置代码注释的颜色</span></span><br><span class="line">  showstringspaces=false,<span class="comment">%不显示代码字符串中间的空格标记</span></span><br><span class="line">  numbers=left, <span class="comment">% 显示行号</span></span><br><span class="line">  numberstyle=<span class="keyword">\tiny</span>,    <span class="comment">% 行号字体</span></span><br><span class="line">  stringstyle=<span class="keyword">\ttfamily</span>, <span class="comment">% 代码字符串的特殊格式</span></span><br><span class="line">  breaklines=true, <span class="comment">%对过长的代码自动换行</span></span><br><span class="line">  extendedchars=false,  <span class="comment">%解决代码跨页时，章节标题，页眉等汉字不显示的问题</span></span><br><span class="line">  escapebegin=<span class="keyword">\begin</span>&#123;CJK*&#125;,escapeend=<span class="keyword">\end</span>&#123;CJK*&#125;,      <span class="comment">% 代码中出现中文必须加上，否则报错</span></span><br><span class="line">  texcl=true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><p>在插入代码块时，使用如下代码（以Verilog为例）<br><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;lstlisting&#125;</span><br><span class="line">    flowing<span class="built_in">_</span>light u0(</span><br><span class="line">        .clock(clock),</span><br><span class="line">        .reset(reset),</span><br><span class="line">        .led(led)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    parameter PERIOD = 10;</span><br><span class="line"></span><br><span class="line">    always <span class="params">#</span>(PERIOD*2) clock=!clock;</span><br><span class="line"></span><br><span class="line">    initial begin</span><br><span class="line">        clock=1&#x27;b0;</span><br><span class="line">        reset=1&#x27;b0;</span><br><span class="line">        <span class="params">#</span>(PERIOD*2)reset=1&#x27;b1;</span><br><span class="line">        <span class="params">#</span>(PERIOD*4)reset=1&#x27;b0;</span><br><span class="line">    end</span><br><span class="line"><span class="keyword">\end</span>&#123;lstlisting&#125;</span><br></pre></td></tr></table></figure></p><p>同时在插入代码块的地方也可以指定语言，如要插入c语言代码<br><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;lstlisting&#125;[language=C]</span><br><span class="line">    // A C program to print &quot;Hello, world!&quot;</span><br><span class="line">    <span class="params">#</span>include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">    int main() &#123;</span><br><span class="line">        printf(&quot;Hello, world!&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;lstlisting&#125;</span><br></pre></td></tr></table></figure></p><p>如果同时在引言部分和插入代码块的地方指定了语言，那么在插入代码块的地方优先级更高。</p>]]></content>
      
      
      <categories>
          
          <category> latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算符的性质</title>
      <link href="/posts/d8964c1.html"/>
      <url>/posts/d8964c1.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是算符"><a href="#什么是算符" class="headerlink" title="什么是算符"></a>什么是算符</h2><p>算符是指作用在一个函数上得出另一个函数的运算符号。表示为 $\hat{F}u=v$,$\hat{F}$ 为一个算符。</p><p>例如 $\frac{\mathrm{d}}{\mathrm{d}x}$ 是微商算符，$\sqrt{\ }$ 是开方算符。</p><h3 id="线性与非线性算符"><a href="#线性与非线性算符" class="headerlink" title="线性与非线性算符"></a>线性与非线性算符</h3><p>线性算符满足：$\hat{F}(\alpha<em>1u_1+\alpha_2u_2)=\alpha_1 \hat{F} u_1+\alpha_2 \hat{F}u_2$。因此 位置算符 $\hat{x}=x$ 和 $\displaystyle \hat{p}</em>{x}=-i\hbar \frac{\partial }{\partial x}$ 都是线性算符。</p><p>$\sqrt{\ }$ 是典型的非线性算符，因为 $\sqrt{\alpha_1 u_1+\alpha_2u_2}\neq \alpha_1 \sqrt{u_1}+\alpha_2 \sqrt{u_2}$</p><p>由于态叠加原理，要求薛定谔方程 $\displaystyle i\hbar \frac{\partial \psi}{\partial x}=\hat{H}\psi$ 是线性微分方程，定态薛定谔方程 $\hat{H}\psi=E\psi$ 应该也要是线性的。所以<em>要求</em> $\hat{H}$ 算符是线性算符，</p><p><em>态叠加原理要求量子力学中的力学量是线性算符。</em></p><h3 id="算符的本征方程"><a href="#算符的本征方程" class="headerlink" title="算符的本征方程"></a>算符的本征方程</h3><p>如果算符 $\hat{F}$ 作用于某个函数 $u$ 有 </p><script type="math/tex; mode=display">\hat{F}u=\lambda u</script><p>该方程就是算符 $\hat{F}$ 的<strong>本征方程</strong>， $\lambda$ 是算符的<strong>本征值</strong>，$u$ 是算符的<strong>本征函数</strong>。（从这里可以发现，定态薛定谔方程就是哈密顿算符 $\hat{H}$ 的本征方程，因此也被称为能量本征方程）</p><p>注：本征方程的解不仅取决于算符本身，同时取决于函数所满足的边界条件。</p><p>对于一个本征值，若只有一个本征函数，则称<strong>无简并</strong>。若同一本征值，对应 $f$ 个线性无关本征函数，则该本征值<strong>有简并</strong>，<strong>简并度</strong>为 $f$。<br>对于同一个本征值的 $f$ 个本征函数的而线性组合仍是本征函数（要求 $\hat{F}$ 是线性算符）</p><script type="math/tex; mode=display">\hat{F}(c_1u_1+c_2u_2+ \cdots +c_{f}u_f)=\lambda(c_1u_1+c_2u_2+ \cdots +c_f u_f)</script><p>例：动量算符的本征方程<br>在一维的情况下， </p><script type="math/tex; mode=display">-i \hbar \frac{\partial }{\partial x}e^{\frac{ipx}{\hbar}}=p e^{\frac{ipx}{\hbar}}</script><p>令 $\hat{p}=-i\hbar \frac{\partial }{\partial x}$, $\psi_p(x)=e^{\frac{ipx}{\hbar}}$，得到</p><script type="math/tex; mode=display">\hat{p}\psi_p(x)=p \psi_p(x)</script><p>$\psi_p(x)$ 称为动量算符 $\hat{p}$ 的本征函数，对应本征值为 $p$。</p><p>在三维条件下，有</p><script type="math/tex; mode=display">-i\hbar \nabla \psi_p(\vec{r})=\vec{p}\psi_p(\vec{r})</script><p>$\vec{p}$ 是动量算符的本征值，$\displaystyle \psi_p(\vec{r})=Ce^{\frac{i}{\hbar}(\vec{p}\cdot \vec{r})}$ 为动量算符的本征函数。</p><h2 id="厄密算符"><a href="#厄密算符" class="headerlink" title="厄密算符"></a>厄密算符</h2><p>对任意两个波函数 $\psi$ 和 $\phi$，如果满足</p><script type="math/tex; mode=display">\iiint \psi^{*}\hat{F}\phi \mathrm{d}\tau =\iiint (\hat{F}\psi)^{*}\phi \mathrm{d}\tau\quad (\mathrm{d}\tau=\mathrm{d}x\mathrm{d}y\mathrm{d}z)</script><p>则算符 $\hat{F}$ 为<strong>厄密算符</strong>。</p><h3 id="厄密算符本征值为实数"><a href="#厄密算符本征值为实数" class="headerlink" title="厄密算符本征值为实数"></a>厄密算符本征值为实数</h3><p>（要求会证明）<br>若 $\hat{F}$ 为厄密算符，则由本征方程 $\hat{F}\psi=\lambda \psi$ 可得</p><script type="math/tex; mode=display">\int \psi^{*}\hat{F}\psi\mathrm{d}\tau=\lambda \int \psi^{*} \psi \mathrm{d}\tau \tag{1}</script><p>同时 </p><script type="math/tex; mode=display">\int \psi^{*}\hat{F}\psi\mathrm{d}\tau=\int (\hat{F}\psi)^{*}\psi\mathrm{d}\tau=\int (\lambda\psi)^{*}\psi\mathrm{d}\tau=\lambda^{*}\int \psi^{*} \psi \mathrm{d} \tau</script><p>因此 $\lambda=\lambda^{*}$，特征值为实数。</p><p>注：其实从(1)式可以看出，算符的特征值和平均值之间有关。</p><h3 id="在任何情况下，厄密算符的平均值为实数"><a href="#在任何情况下，厄密算符的平均值为实数" class="headerlink" title="在任何情况下，厄密算符的平均值为实数"></a>在任何情况下，厄密算符的平均值为实数</h3><p>当 $\psi$ 为任意波函数时(即不一定是本征函数)，</p><script type="math/tex; mode=display">\lang F \rang =\int \psi ^{*}\hat{F} \psi \mathrm{d}\tau=\int (\hat{F}\psi)^{*} \psi\mathrm{d}\tau</script><p>对上式取共轭</p><script type="math/tex; mode=display">\lang F \rang ^{*} =\int (\hat{F}\psi)\psi^{*}\mathrm{d}\tau=\int \psi^{*} \hat{F} \psi \mathrm{d} \tau =\lang F \rang</script><p>同时，<em>在任何情况下平均值都是实数的线性算符一定时厄密算符</em>。</p><p><em>在量子力学中表示力学量的算符都是厄密算符。</em></p><h3 id="厄密算符的本征方程"><a href="#厄密算符的本征方程" class="headerlink" title="厄密算符的本征方程"></a>厄密算符的本征方程</h3><p>在状态 $u$ 下测量力学量 $F$，平均值为</p><script type="math/tex; mode=display">\lang \hat{F} \rang =\int u^{*} \hat{F}u\mathrm{d}x\equiv \lang u |\hat{F}|u \rang</script><p>（最右侧是狄拉克定义的简化写法）</p><p>对于单次测量，测定的结果应当是某个特定值 $F’$，与平均值的差为 $F’-\lang \hat{F} \rang$。现在考虑<strong>涨落</strong>的情况，使用方差 $\overline{(F’-\lang \hat{F} \rang)^{2}}$ 来考虑。在计算的过程中，应当使用算符来表示力学量。</p><script type="math/tex; mode=display">\overline{(F'-\lang \hat{F} \rang )^{2}}=\lang (\hat{F}-\lang \hat{F}\rang)^{2} \rang =\int u^{*}(\hat{F}-\lang \hat{F} \rang)^{2} u \mathrm{d}x</script><p>考虑到力学量都为厄密算符，即 $\hat{F}$ 为厄密算符，那么 $\hat{F}-\lang \hat{F} \rang$ 也为厄密算符。</p><script type="math/tex; mode=display">\therefore  \int u^{*}(\hat{F}-\lang \hat{F} \rang)(\hat{F}-\lang \hat{F} \rang)u \mathrm{d}x=\int \left[ (\hat{F}-\lang \hat{F} \rang)u \right]^{*} (\hat{F}-\lang \hat{F} \rang)u \mathrm{d}x=\int \left\vert (\hat{F}-\lang \hat{F} \rang)u \right\vert ^{2}\mathrm{d}x\ge 0</script><p>若体系处于一种特殊的状态，在这种状态下测量力学量 $F$ 的结果总是同一个值，即 $F’=\lang \hat{F} \rang$，涨落为 $0$，则这种状态被称为力学量 $F$ 的<strong>本征态</strong>。</p><script type="math/tex; mode=display">\int \left\vert (\hat{F}-\lang \hat{F} \rang)u \right\vert ^{2}\mathrm{d}x=0 \Rightarrow (\hat{F}-\lang \hat{F} \rang)u=0 \Rightarrow \hat{F}u=F'u</script><p>测量到的值即为该本征态下 $\hat{F}$ 的本征值。从另一方面来说，如果系统处于 $\hat{F}$ 的本征态 $u$ 下，考虑到 $\hat{F}u=\lambda u$，$\displaystyle \int \left\vert (\hat{F}-\lambda)u \right\vert ^{2}\mathrm{d}x=0$，那么每次测量力学量 $F$ 得到的都将是本征值 $\lambda$。</p><p><em>量子力学假设：测量力学量 $F$ 时，所有可能出现的值，都是相应厄米算符 $\hat{F}$ 的本征值</em>。<br>这里指的是，在任意一种状态下测量 $F$ （有可能不是本征态），测到的 $F’$ 一定是 $\hat{F}$ 的一系列本征值中的一个。</p><h3 id="厄密算符本征函数的正交性"><a href="#厄密算符本征函数的正交性" class="headerlink" title="厄密算符本征函数的正交性"></a>厄密算符本征函数的正交性</h3><p>当两个函数 $\psi_1,\psi_2$ 满足</p><script type="math/tex; mode=display">\int \psi_1^{*} \psi_2\mathrm{d}x=\lang \psi_1|\psi_2 \rang=0</script><p>则我们称两函数<strong>相互正交</strong>。$\lang \psi_1|\psi_2 \rang$ 称为两个函数的<strong>内积</strong>。</p><p><em>厄密算符两个不同本征值的本征函数总是正交的</em>。证明：<br>设 $u_1,u_2, \ldots ,u_n$ 是 $\hat{F}$ 的本征函数，对应本征值为 $\lambda_1,\lambda_2, \ldots \lambda_n$。$\forall k\neq l:$</p><script type="math/tex; mode=display">\lambda_l\int u_k^{*}u_l\mathrm{d}x=\int u_k^{*} \hat{F} u_l\mathrm{d}x= \int(\hat{F} u_k)^{*} u_l\mathrm{d}x=\int (\lambda_k u_k)^{*}u_l\mathrm{d}x=\lambda_k\int u_k^{*} u_l\mathrm{d}x</script><p>(以上利用了厄密算符本征值为实数的性质。)<br>$\because \lambda_l\neq \lambda_k$，$\displaystyle \therefore \lang u_k|u_l \rang=\int u_k^{*} u_l\mathrm{d}x=0$<br>得证。</p><p>如果将 $u_1,u_2, \ldots u_n$ 归一化，那么 $\hat{F}$ 就能得到一组<strong>正交归一化</strong>的本征函数：</p><script type="math/tex; mode=display">\int u_k^{*}u_l\mathrm{d}x=\delta_{kl},\quad \delta_{kl}=\begin{cases}    1,&k=1 \\    0,&k\neq l\end{cases}</script><h3 id="厄密算符本征函数的完备性"><a href="#厄密算符本征函数的完备性" class="headerlink" title="厄密算符本征函数的完备性"></a>厄密算符本征函数的完备性</h3><h4 id="广义傅里叶展开"><a href="#广义傅里叶展开" class="headerlink" title="广义傅里叶展开"></a>广义傅里叶展开</h4><p>厄密算符 $\hat{F}$ 所对应的一组本征函数 $u_1(x),u_2(x), \ldots ,u_n(x), \ldots$ 是完备的，即对于任一模<em>平方可积</em>函数 $\psi$，可表示为：</p><script type="math/tex; mode=display">\psi(x)=\sum_{l}c_l u_l(x) \quad \psi(x,t)=\sum_{l}c_l(t)u_l(x)</script><p>其中 $c_l$ 为<strong>展开系数</strong>。其中计算方法如下：</p><script type="math/tex; mode=display">\lang u_l|\psi \rang =\sum_{k}c_k \lang u_l|u_k\rang =\sum_{k}c_k \delta_{lk}=c_l \Leftrightarrow c_l=\int u_l^{*}(x)\psi(x)\mathrm{d}x</script><p>将 $c_l$ 的值代入展开式</p><script type="math/tex; mode=display">\psi(x)=\sum_{l}\lang u_l | \psi \rang u_l(x)</script><p>即为广义傅里叶展开。（此处默认本征值分立，如果本征值连续，则求和化为积分）</p><h4 id="各种状态的概率"><a href="#各种状态的概率" class="headerlink" title="各种状态的概率"></a>各种状态的概率</h4><p>若 $\psi(x)$ 已经归一化，</p><script type="math/tex; mode=display">\int \psi^{*}(x)\psi(x)\mathrm{d}x=\sum_{k,l}c_k^{*}c_l\int u_k^{*}u_l \mathrm{d}x=\sum_{k,l}c_k^{*}c_l\delta_{kl}=\sum_{l}\left\vert c_l \right\vert ^{2}=1</script><p>在 $\psi$ 态中，力学量 $F$ 的平均值</p><script type="math/tex; mode=display">\lang \hat{F} \rang =\lang \psi|\hat{F} |\psi\rang =\sum_{l,m}c_m^{*}c_l \lang u_m|\hat{F}|u_l \rang =\sum_{l,m}c_m^{*}c_l \lambda_l \delta_{m,l}=\sum_{l}\left\vert c_l \right\vert ^{2}\lambda_l</script><p>由此可见，测量力学量 $F$ 测得的可能值必定是 $\hat{F}$ 的本征值中的一个。测量后系统状态发生改变，从 $\psi$ 变成了某一个本征态 $u_l$，称为波包塌缩。</p><h4 id="定态"><a href="#定态" class="headerlink" title="定态"></a>定态</h4><p>在一般情况下</p><script type="math/tex; mode=display">\psi(x,t)=\sum_{l}c_l(t)u_l(x)</script><p>波函数随时间变化。如果 $\psi(x,t)$ 是定态，</p><script type="math/tex; mode=display">\psi(x,t)=\xi(x)\exp (- \frac{iE}{\hbar}t) =\left( \sum_{l}c_l' u_l(x) \right)\exp (- \frac{iE}{\hbar}t)</script><p>则 $c_l(t)=c_l’\exp (-iEt /\hbar)$, $\left\vert c_l(t) \right\vert^{2}=\left\vert c_l’\exp (-iEt /\hbar) \right\vert^{2}=\left\vert c_l’ \right\vert ^{2}$</p><p>这表明，对处于定态中的体系，测量不显含时间 $t$ 的力学量 $F$ 取可能值的概率不变,当然平均值也不变（前已证明）。</p><h2 id="动量算符的厄密性"><a href="#动量算符的厄密性" class="headerlink" title="动量算符的厄密性"></a>动量算符的厄密性</h2><p>首先证明动量算符 $\hat{p}_{x}=-i\hbar \partial/\partial x$ 的厄密性。</p><script type="math/tex; mode=display">\begin{aligned}\int_{-\infty}^{+\infty}\psi^{*}\hat{p}_{x}\varphi \mathrm{d}x&=\int _{-\infty}^{+\infty}\psi^{*}(-i\hbar \frac{\partial }{\partial x})\varphi\mathrm{d}x \\&=-i \hbar (\varphi\psi^{*}) \vert _{-\infty}^{+\infty}+i\hbar \int _{-\infty}^{+\infty}\varphi \frac{\partial }{\partial x}\psi^{*}\mathrm{d}x\end{aligned}</script><p>而考虑到 $\psi$ 和 $\varphi$ 平方可积</p><script type="math/tex; mode=display">-i \hbar (\varphi \psi^{*})\vert _{-\infty}^{+\infty}=0</script><script type="math/tex; mode=display">\therefore \int_{-\infty}^{+\infty}\psi^{*}\hat{p}_{x}\varphi \mathrm{d}x=i \hbar \int _{-\infty}^{+\infty}\varphi \frac{\partial }{\partial x}\psi^{*}\mathrm{d}x=\int _{-\infty}^{+\infty}(i \hbar \frac{\partial }{\partial x}\psi^{*})\varphi \mathrm{d}x =\int _{-\infty}^{+\infty}(-i \hbar \frac{\partial }{\partial x}\psi)^{*}\varphi \mathrm{d}x=\int _{-\infty}^{+\infty}(\hat{p}_{x}\psi)^{*}\varphi\mathrm{d}x</script><h2 id="算符运算初步"><a href="#算符运算初步" class="headerlink" title="算符运算初步"></a>算符运算初步</h2><p>算符之和(分配律)</p><script type="math/tex; mode=display">\hat{A}+\hat{B}=\hat{C}\\\hat{C}\psi=(\hat{A}+\hat{B})\psi=\hat{A}\psi+\hat{B}\psi</script><p>算符之积（结合律）</p><script type="math/tex; mode=display">\hat{A}\hat{B}=\hat{C}\\\hat{C}\psi=(\hat{A}\hat{B})\psi=\hat{A}(\hat{B}\psi)</script><h3 id="算符的对易性"><a href="#算符的对易性" class="headerlink" title="算符的对易性"></a>算符的对易性</h3><p>一般情况下，算符之积不满足交换律 $\hat{A}\hat{B}\neq \hat{B}\hat{A}$。若 $\hat{A}\hat{B}=\hat{B}\hat{A}$，则称 $\hat{A}$ 和 $\hat{B}$ <strong>对易</strong>。</p><script type="math/tex; mode=display">[\hat{A},\hat{B}]\equiv \hat{A}\hat{B}-\hat{B}\hat{A}</script><p>为算符 $\hat{A},\hat{B}$ 的<strong>对易式</strong>。</p><p>例：求 $[\hat{x},\hat{p}_{x}]$</p><script type="math/tex; mode=display">\begin{aligned}(\hat{x}\hat{p}_{x}-\hat{p}_{x}\hat{x})\psi &=-i \hbar x\frac{\partial }{\partial x}\psi+i \hbar \frac{\partial }{\partial x}(x\psi) \\&= -i \hbar x \frac{\partial }{\partial x}\psi +i\hbar \psi +i \hbar x \frac{\partial }{\partial x}\psi\\&= i \hbar \psi\end{aligned}</script><p>$\therefore [\hat{x},\hat{p}_{x}]=i \hbar$.</p><h3 id="对易式的性质"><a href="#对易式的性质" class="headerlink" title="对易式的性质"></a>对易式的性质</h3><p>$[\hat{A},\hat{B}]=-[\hat{B},\hat{A}]$<br>$[\hat{A},\hat{B}+\hat{C}]=[\hat{A},\hat{B}]+[\hat{A},\hat{C}]$</p><p>$[\hat{A},\hat{B}\hat{C}]=[\hat{A},\hat{B}]\hat{C}+\hat{B}[\hat{A},\hat{C}]$<br>证明：</p><script type="math/tex; mode=display">\begin{aligned}[\hat{A},\hat{B}\hat{C}]&=\hat{A}(\hat{B}\hat{C})-(\hat{B}\hat{C})\hat{A} \\&= \hat{A}\hat{B}\hat{C}-\hat{B}\hat{A}\hat{C}+\hat{B}\hat{A}\hat{C}-\hat{B}\hat{C}\hat{A}\\&=[\hat{A},\hat{B}]\hat{C}+\hat{B}[\hat{A},\hat{C}]\end{aligned}</script>]]></content>
      
      
      <categories>
          
          <category> 量子力学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动量的算符表示</title>
      <link href="/posts/6418f805.html"/>
      <url>/posts/6418f805.html</url>
      
        <content type="html"><![CDATA[<h2 id="平面波的叠加"><a href="#平面波的叠加" class="headerlink" title="平面波的叠加"></a>平面波的叠加</h2><h3 id="自由粒子"><a href="#自由粒子" class="headerlink" title="自由粒子"></a>自由粒子</h3><p>自由粒子平面波函数：$\psi_{\vec{p}}=A \exp \left[ \frac{i}{\hbar}(\vec{p}\cdot \vec{r}-Et) \right]$<br>该粒子空间坐标完全不确定（弥散于全空间），但是能量和动量确定。</p><p>但在实际情况下，粒子处于随时间和位置变化的力场中运动，他的动量和能量不再是常量粒子的状态就不再是一个平面波，而是一个一般的波函数 $\psi(\vec{r},t)$。$\psi(\vec{r},t)$ 可以视为平面波的线性叠加。</p><h3 id="波函数叠加"><a href="#波函数叠加" class="headerlink" title="波函数叠加"></a>波函数叠加</h3><p>例：<br>考虑电子在晶体表面衍射，电子可能有各种动量 $p$，考虑一级衍射，即衍射角和电子动量关系为</p><script type="math/tex; mode=display">a \sin \theta =\frac{h}{p}</script><p>式中 $a$ 为晶格常数，$\theta$ 为衍射角，$p$ 为粒子动量。</p><!-- 以上方程从传统波动的方面说明了衍射图样的形状。 --><p>考虑概率波，在有确定的动量的情况下</p><script type="math/tex; mode=display">\psi_{\vec{p}}=A \exp \left[ \frac{i}{\hbar}(\vec{p}\cdot \vec{r}-Et) \right]</script><p>根据叠加原理，电子衍射后的状态 $\psi$ 可写为</p><script type="math/tex; mode=display">\psi(\vec{r},t)=\int C(\vec{p},t)\exp \left[ \frac{i}{\hbar}\vec{p}\cdot \vec{r} \right]\frac{\mathrm{d}\vec{p}}{(2\pi \hbar)^{3 /2}}</script><p>也就是考虑了各种动量的叠加。其中 $\mathrm{d}\vec{p}=\mathrm{d}p_{x} \mathrm{d}p_y \mathrm{d}p_z$；$(2\pi \hbar)^{3 /2}$ 项是平面波 $\delta$ 函数归一化的结果，可以视为一个常数。衍射图样正是这些平面波叠加干涉的的结果。</p><h3 id="C-p-t-的物理意义"><a href="#C-p-t-的物理意义" class="headerlink" title="$C(p,t)$ 的物理意义"></a>$C(p,t)$ 的物理意义</h3><p>衍射后电子动量在 $p \sim p+\mathrm{d}p$ 区间概率为 $\left\vert C(p,t) \right\vert^{2} \mathrm{d}p$。</p><ul><li>$C(\vec{p},t)$ 与动量空间概率密度相关。<strong>动量表象</strong>波函数。</li><li>$\psi(\vec{r},t)$ 与坐标空间概率密度相关。<strong>坐标表象</strong>波函数</li></ul><p>两者描述的是同一量子状态。</p><h2 id="力学量的平均值与动量算符"><a href="#力学量的平均值与动量算符" class="headerlink" title="力学量的平均值与动量算符"></a>力学量的平均值与动量算符</h2><h3 id="量子力学中对平均的理解"><a href="#量子力学中对平均的理解" class="headerlink" title="量子力学中对平均的理解"></a>量子力学中对平均的理解</h3><p>在经典物理中，我们可以认为平均就是对同一个物理量做多次测量，然后求平均。但是在量子力学中，对一个物理量多次测量会导致这个物理量的改变，因此不可取。</p><p>所以在量子力学中，我们需要一个<strong>系综</strong>，也就是大量完全相同的体系，都处于 $\psi(x,t)$ 态(这里以测量位置平均值为例)。我们对每一个体系分别做一次测量，最后再求平均。</p><h3 id="位置的平均值"><a href="#位置的平均值" class="headerlink" title="位置的平均值"></a>位置的平均值</h3><script type="math/tex; mode=display">\lang x \rang= \int _{-\infty}^{+\infty}\psi^{*}(x,t)\cdot x\cdot \psi(x,t)\mathrm{d}x</script><p>此处积分式子将 $x$ 放在波函数中间，是为了与之后动量算符求平均的积分式保持相同的形式。</p><p>与位置的平均值类似，势能 $V(x)$ 的平均值为</p><script type="math/tex; mode=display">\lang V \rang =\int _{-\infty}^{+\infty}\psi^{*}(x,t)V(x)\psi(x,t)\mathrm{d}x</script><h3 id="动量的平均值"><a href="#动量的平均值" class="headerlink" title="动量的平均值"></a>动量的平均值</h3><p>动量的平均值无法按照上面的方法来计算。</p><h4 id="动量不是位置的函数"><a href="#动量不是位置的函数" class="headerlink" title="动量不是位置的函数"></a>动量不是位置的函数</h4><p>$p=h /\lambda$，而 $\lambda$ 是与整个空间的波相关联的，所以说在某一点的波长是多少没有意义，那么说空间某点的动量也没有意义。</p><p>从另一方面来说，假如 $p(x)$ 有意义，那么就会违背不确定关系。</p><h4 id="动量平均值的计算"><a href="#动量平均值的计算" class="headerlink" title="动量平均值的计算"></a>动量平均值的计算</h4><script type="math/tex; mode=display">\lang p \rang =\int_{-\infty}^{+\infty}C^{*}(p,t)pC(p,t)\mathrm{d}p</script><p>如果想要在坐标表象中计算动量平均值，需要利用到以下关系式：</p><script type="math/tex; mode=display">\psi(x,t)=\int_{-\infty}^{+\infty}C(p,t)e^{ipx /\hbar}\frac{\mathrm{d}p}{\sqrt{2\pi \hbar}} \xleftrightarrow{Fourier变换式} C(p,t)=\int_{-\infty}^{+\infty}\psi(x,t)e^{-ipx /\hbar}\frac{\mathrm{d}x}{\sqrt{2\pi \hbar}}</script><p>然后求动量平均值的式子可以写为：</p><script type="math/tex; mode=display">\begin{aligned}\lang p \rang &=\int _{-\infty}^{+\infty}C^{*}(p,t)pC(p,t)\mathrm{d}p \\&= \int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}\psi^{*}(p,t)e^{\frac{ipx}{\hbar}}\frac{\mathrm{d}x}{\sqrt{2\pi \hbar}}\cdot pC(p,t)\mathrm{d}p\\&=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}C(p,t)e^{\frac{ipx}{\hbar}}p \frac{\mathrm{d}p}{\sqrt{2\pi \hbar}}\cdot \psi^{*}(x,t)\mathrm{d}x\\&=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}C(p,t)(-i\hbar) \frac{\partial }{\partial x}(e^{\frac{ipx}{\hbar}}) \frac{\mathrm{d}p}{\sqrt{2\pi\hbar}}\cdot \psi^{*}(x,t)\mathrm{d}x\\&=\int_{-\infty}^{+\infty}(-i\hbar)\frac{\partial }{\partial x}\int_{-\infty}^{+\infty}C(p,t)e^{\frac{ipx}{\hbar}}\frac{\mathrm{d}p}{\sqrt{2\pi\hbar}}\psi^{*}(x,t)\mathrm{d}x\\&=\int_{-\infty}^{+\infty}(-i\hbar)\frac{\partial }{\partial x}\psi(x,t)\psi^{*}(x,t)\mathrm{d}x\\&=\int_{-\infty}^{+\infty}\psi^{*}(x,t)(-i\hbar\frac{\partial }{\partial x})\psi(x,t)\mathrm{d}x\end{aligned}</script><p>可以看出，如果想在坐标表象计算动量的平均值，动量要变成一个算符 $\hat{p}= -i\hbar \frac{\partial }{\partial x}$</p><p>在三维的情况下，动量算符为 $\hat{\vec{p}}=-i\hbar \nabla$</p><h3 id="一般力学量的平均值"><a href="#一般力学量的平均值" class="headerlink" title="一般力学量的平均值"></a>一般力学量的平均值</h3><p>所有的经典力学量都可以写成坐标与动量的函数，因此对于任意力学量 $A(\vec{r},\vec{p})$，都可以变成算符 $\hat{A}(\vec{r},-i\hbar \nabla )$。</p><p>比如动能对应的算符</p><script type="math/tex; mode=display">\frac{p^{2}}{2m}= \frac{p_{x}^{2}+p_y^{2}+p_z^{2}}{2m}\rightarrow -\frac{\hbar^{2}}{2m}(\frac{\partial ^{2}}{\partial x^{2}} +\frac{\partial ^{2}}{\partial y^{2}}+\frac{\partial ^{2}}{\partial z^{2}})=- \frac{\hbar^{2}}{2m}\nabla ^{2}</script><p>可以看出原本力学量的乘法变成了算符的复合。</p><p>动能的平均值（一维）：</p><script type="math/tex; mode=display">\lang T \rang =\int_{-\infty}^{+\infty}\psi^{*}(x,t)(-\frac{\hbar^{2}}{2m}\frac{\partial ^{2}}{\partial x^{2}})\psi(x,t)\mathrm{d}x</script><p>从这里可以看出，哈密顿算符 $\displaystyle \hat{H}=- \frac{\hbar^{2}}{2m}\nabla ^{2}+V(x,t)$ 就是总能量（动能加势能）对应的算符。</p><p><em>量子力学基本假设：每个力学量都与一个算符相对应</em>，因此任意一个力学量的平均值可以写成</p><script type="math/tex; mode=display">\lang A \rang =\frac{\iiint \psi^{*}(x,y,z,t)\hat{A}\psi(x,y,z,t)\mathrm{d}x\mathrm{d}y\mathrm{d}z}{\iiint \psi^{*}(x,y,z,t)\psi(x,y,z,t)\mathrm{d}x\mathrm{d}y\mathrm{d}z}</script><p>如果 $\psi(x,y,z,t)$ 归一化了，那么上式分母为 $1$</p><script type="math/tex; mode=display">\lang A \rang =\iiint \psi^{*}\hat{A}\psi \mathrm{d}x\mathrm{d}y\mathrm{d}z</script><p>对于定态，任何不显含 $t$ 的力学量 $F$ 的平均值与 $t$ 无关。</p><script type="math/tex; mode=display">\begin{aligned} \lang F \rang &=\int \psi _{n}^{*}(\vec{r},t) \hat{F} \psi_{n}(\vec{r},t)\mathrm{d}x\mathrm{d}y\mathrm{d}z\\ &=\int \Phi_{n}^{*}(\vec{r})e^{\frac{iE_{n}t}{\hbar}}\hat{F}\Phi_{n}(\vec{r})e^{- \frac{iE_{n}t}{\hbar}}\mathrm{d}x\mathrm{d}y\mathrm{d}z\\ &=\int \psi_{n}^{*}(\vec{r})\hat{F}\psi_{n}(\vec{r})\mathrm{d}x\mathrm{d}y\mathrm{d}z\end{aligned}</script><p>与时间无关。</p>]]></content>
      
      
      <categories>
          
          <category> 量子力学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>态叠加原理</title>
      <link href="/posts/1bd25f8f.html"/>
      <url>/posts/1bd25f8f.html</url>
      
        <content type="html"><![CDATA[<h2 id="叠加态原理一般表述"><a href="#叠加态原理一般表述" class="headerlink" title="叠加态原理一般表述"></a>叠加态原理一般表述</h2><p>若 $\Psi<em>1, \Psi_2, \ldots \Psi</em>{n}$ 是体系的一系列可能的状态，则这些态的线性叠加 $\Psi=c<em>1\psi_1+c_2\psi_2+ \cdots +c_n\Psi</em>{n}$（其中 $c_1,c_2, \ldots c_n$ 为复常数）也是体系的一个可能状态。</p><p>处于 $\Psi$ 态的体系，部分地处于 $\Psi<em>1$ 态，部分地处于 $\Psi_2$ 态…，部分地处于 $\Psi</em>{n}$ 态。且处于 $\Psi_k$ 态的概率为 $\left\vert c_k \right\vert ^{2}$</p><p>条件：$\Psi<em>1, \Psi_2, \ldots \Psi</em>{n}$ 正交归一，$\Psi$ 归一。即：</p><script type="math/tex; mode=display">\int \Psi_k^{*}\Psi_l \mathrm{d}x=\delta_{kl},\quad \delta_{kl}=\begin{cases}    1 &k=l\\    0 &k\neq l\end{cases}</script><script type="math/tex; mode=display">\sum_{k=1}^{n}\left\vert c_k \right\vert ^{2}=1</script><h2 id="和经典力学中的不同"><a href="#和经典力学中的不同" class="headerlink" title="和经典力学中的不同"></a>和经典力学中的不同</h2><p>量子力学中：<br>比如系统处于 $\Psi_1$ 态，测量力学量 $A$ 的值确定，为 $a_1$;系统处于 $\Psi_2$ 态，测量力学量 $A$ 的值确定，为 $a_2$;<br>则在 $\Psi=c_1\Psi_1+c_2\Psi_2$ 描述的状态下，测量物理量 $A$ 的值既有可能为 $a_1$ 也可能为 $a_2$,这导致测量结果的不确定性。</p><p>在经典力学中：<br>合成波由若干子波叠加而成，性质是完全确定的新的波动。<br>$\Psi=c_1\Psi_1+c_2\Psi_2$ 由 $\Psi$ 描述,不能说物理量可能作 $\Psi_1$ 波动，或者可能作 $\Psi_2$ 波动。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>光子通过偏振片</p><p>若只让一个光子通过偏振片:当 $\alpha=0$ 时，光子通过，并且光子能量和偏振方向在通过偏振片前后不变;当 $\alpha=\pi/2$ 时，光子被吸收;</p><p>当夹角取其它值时，通过偏振片后，既有可能观测到光子，也有可能观测不到光子。观测到光子的概率为 $\cos^{2} \alpha$，观测不到光子的概率为 $\sin^{2} \alpha$。<br><em>注意</em>:观测到的光子总是一个完整的光子，而不是 $\cos ^{2}\alpha$ 个。</p><p>入射光子部分处于沿偏振方向的偏振态 $\psi<em>{\parallel}$，部分处于与偏振方向垂直的偏振态 $\psi</em>{\perp}$，因此可以用 $\psi<em>{\alpha}=\cos \alpha \psi</em>{\parallel}+\sin \alpha \psi_{\perp }$ 来描述。<br>或者也可以写为：$\left | \alpha \right \rang=\cos \alpha\left | x \right \rang+\cos \alpha\left | y \right \rang$</p>]]></content>
      
      
      <categories>
          
          <category> 量子力学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter10-Virtual Memory</title>
      <link href="/posts/1b14f8df.html"/>
      <url>/posts/1b14f8df.html</url>
      
        <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>一个进程的数据无法完全加载到整个内存中，所以需要虚拟内存来假装成物理内存。通过这种方式，能储存当前应用程序的几乎所有数据，而不需要全部加载到内存中。</p><div align=center><img src="../../figure/operating-system/Chapter10-Virtual-Memory/virtual_memory.png" width=600></div><h2 id="Demand-Paging"><a href="#Demand-Paging" class="headerlink" title="Demand Paging"></a>Demand Paging</h2><p><strong><em>demand pageing</em></strong>: Pages are loaded only when they are demanded during program execution. Pages that are never accessed are thus never loaded into physical memory. (stored in virtual memory)</p><h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><p>While a process is executing, some pages will be in memory, and some will be in secondary storage. </p><div align=center><img src="../../figure/operating-system/Chapter10-Virtual-Memory/page_table_virtual_memory.png" width=500></div><p>When the bit is set to </p><ul><li><em>valid</em>: the associated page is both legal and in memory.</li><li><em>invalid</em>: the page either is not valid (that is, not in the logical address space of the process) or is valid but is currently in secondary storage.</li></ul><p><strong><em>page fault</em></strong>: when a page is referenced that is not in memory.(被放在虚拟内存中)</p><p>The procedure for handling this page fault is straightforward：</p><div align=center><img src="../../figure/operating-system/Chapter10-Virtual-Memory/handle_page_fault.png" width=500></div><p><strong><em>pure demand paging</em></strong>: never bring a page into memory until it is required.</p><p>Programs tend to have <strong><em>locality</em></strong> of reference(时间局部性、空间局部性、访问频率局部性), which results in reasonable performance from demand paging.</p><p>The hardware to support demand paging is the same as the hardware for paging and swapping:</p><ul><li><strong>page table</strong></li><li><strong>Secondary memory.</strong> :It is known as the swap device, and the section of storage used for this purpose is known as <strong><em>swap space</em></strong>. </li></ul><h3 id="Free-Frame-List"><a href="#Free-Frame-List" class="headerlink" title="Free-Frame List"></a>Free-Frame List</h3><p>To resolve page faults, most operating systems maintain a <strong><em>free-frame list</em></strong>, a pool of <strong>free frames</strong> for satisfying such requests.</p><div align=center><img src="../../figure/operating-system/Chapter10-Virtual-Memory/free_fram_list.png" width=500></div><p>Operating systems typically allocate free frames using a technique known as <strong><em>zero-fill-on-deman</em></strong>: demand frames are “zeroed-out” before being allocated, thus erasing their previous contents.</p><p>When a system starts up, all available memory is placed on the free-frame list.</p><h3 id="Performance-of-Demand-Paging"><a href="#Performance-of-Demand-Paging" class="headerlink" title="Performance of Demand Paging"></a>Performance of Demand Paging</h3><p>As long as we have no page faults, the effective access time is equal to the memory access time. If, however, a page fault occurs, we must first read the relevant page from secondary storage and then access the desired word.</p><blockquote><p>effective access time = (1 − p) × ma + p × page fault time.</p></blockquote><h2 id="Copy-on-Write"><a href="#Copy-on-Write" class="headerlink" title="Copy-on-Write"></a>Copy-on-Write</h2><p>Process creation using the <code>fork()</code> system call may initially bypass the need for demand paging by using a technique similar to page sharing (covered in Section 9.3.4)</p><p><strong><em>copy-on-write</em></strong>: allowing the parent and child processes initially to share the same pages. These shared pages are marked as copy-on-write pages, meaning that if either process writes to a shared page, a copy of the shared page is created.<br>(就是如果要写数据，那就要重新拷贝一份)</p><div align=center><img src="../../figure/operating-system/Chapter10-Virtual-Memory/copy_on_wirte.png" width=500></div><h2 id="Page-Replacement"><a href="#Page-Replacement" class="headerlink" title="Page Replacement"></a>Page Replacement</h2><p><strong><em>page replacement</em></strong>: the process of selecting a page to be removed from memory and replaced with another page.</p><div align=center><img src="../../figure/operating-system/Chapter10-Virtual-Memory/need_for_page_replacement.png" width=600></div><p>不存在空闲页框，因此需要页面替换。</p><h3 id="Basic-Page-Replacement"><a href="#Basic-Page-Replacement" class="headerlink" title="Basic Page Replacement"></a>Basic Page Replacement</h3><div align=center><img src="../../figure/operating-system/Chapter10-Virtual-Memory/basic_page_replacement.png" width=500></div><p><strong><em>modify bits(dirty bits)</em></strong> :The modify bit for a page is set by the hardware whenever any byte in the page is written into, indicating that the page has been modified. (就是看内存和硬盘上数据是否一致，如果不一致，就设置为dirty，目的是为了减少写入硬盘的次数)</p><p>We must solve two major problems to implement demand paging:</p><ul><li><strong><em>frame-allocation algorithm</em></strong>: if we have multiple processes in memory, we must decide how many frames to allocate to each process</li><li><strong><em>page-replacement algorithm</em></strong>: when page replacement is required, we must select the frames that are to be replaced.</li></ul><h3 id="FIFO-Page-Replacement"><a href="#FIFO-Page-Replacement" class="headerlink" title="FIFO Page Replacement"></a>FIFO Page Replacement</h3><p><strong><em>first-in, first-out (FIFO) page replacement</em></strong>: the oldest page is replaced first.</p><div align=center><img src="../../figure/operating-system/Chapter10-Virtual-Memory/fifo_page_replacement_algo.png" width=650></div><p>Curve of page faults for this reference string versus the number of available frames:</p><div align=center><img src="../../figure/operating-system/Chapter10-Virtual-Memory/page_fault_curve_for_fifo_algo.png" width=400></div><p><strong><em>Belady’s anomaly</em></strong>: the number of page faults increases as the number of frames increases.</p><h3 id="Optimal-Page-Replacement"><a href="#Optimal-Page-Replacement" class="headerlink" title="Optimal Page Replacement"></a>Optimal Page Replacement</h3><p><strong><em>optimal page replacement</em></strong>: the page that <em>will</em> not be referenced for the longest time is replaced first.(但是需要预知未来的访问情况，因此该算法无法实现)</p><p>Example: The reference to page 2 replaces page 7, because page 7 will not be used until reference 18, whereas page 0 will be used at 5, and page 1 at 14.</p><div align=center><img src="../../figure/operating-system/Chapter10-Virtual-Memory/optimal_page_replacement_algo.png" width=650></div><h3 id="LRU-Page-Replacement"><a href="#LRU-Page-Replacement" class="headerlink" title="LRU Page Replacement"></a>LRU Page Replacement</h3><p><strong><em>least-recently used (LRU) page replacement</em></strong>: the page that <em>has</em> not been referenced for the longest time is replaced first.</p><div align=center><img src="../../figure/operating-system/Chapter10-Virtual-Memory/LRU_page_replacement_algo.png" width=600></div><h2 id="Allocation-of-Frames"><a href="#Allocation-of-Frames" class="headerlink" title="Allocation of Frames"></a>Allocation of Frames</h2><p>How do we allocate the fixed amount of free memory among the various processes?<br><em>the basic strategy</em>: the user process is allocated any free frame.</p><h3 id="Minimum-Number-of-Frames"><a href="#Minimum-Number-of-Frames" class="headerlink" title="Minimum Number of Frames"></a>Minimum Number of Frames</h3><p>We must also allocate at least a minimum number of frames. </p><p>One reason for allocating at least a minimum number of frames involves performance. </p><h3 id="Allocation-Algorithms"><a href="#Allocation-Algorithms" class="headerlink" title="Allocation Algorithms"></a>Allocation Algorithms</h3><p><strong><em>equal allocation</em></strong>: split <em>m</em> frames among <em>n</em> processes is to give everyone an equal share, <em>m/n</em> frames .<br><strong><em>proportional allocation</em></strong>: 按照进程大小分配 frame<br>With proportional allocation, we would split 62 frames between two processes, one of 10 pages and one of 127 pages, by allocating 4 frames and 57 frames, respectively, since 10/137 × 62 ≈ 4 and 127/137 × 62 ≈ 57.</p><h2 id="Thrashing"><a href="#Thrashing" class="headerlink" title="Thrashing"></a>Thrashing</h2><p><strong><em>thrashing</em></strong>: A process is thrashing if it is spending more time paging than executing. As you might expect, thrashing results in severe performance problems.</p><h3 id="Cause-of-Thrashing"><a href="#Cause-of-Thrashing" class="headerlink" title="Cause of Thrashing"></a>Cause of Thrashing</h3><p><em>scenario</em>: A global page-replacement algorithm is used; it replaces pages without regard to the process to which they belong.</p><div align=center><img src="../../figure/operating-system/Chapter10-Virtual-Memory/trashing.png" width=400></div><p>并行度增加，更多的进程导致更多的 page fault，甚至从正在运行的进程中做 page swapping，从而导致更严重的 page fault。最终计算机大多数时间都浪费在 page swapping 上，CPU利用率严重下降。</p><p>At this point, to increase CPU utilization and stop thrashing, we must decrease the degree of multiprogramming.</p><h3 id="Working-Set-Model"><a href="#Working-Set-Model" class="headerlink" title="Working-Set Model"></a>Working-Set Model</h3><p>The working-set model is based on the assumption of locality. The set of pages in the most recent Δ page references is the working set. Thus, the working set is an approximation of the program’s locality.</p><div align=center><img src="../../figure/operating-system/Chapter10-Virtual-Memory/working_set_model.png" width=600></div><p>For example, given the sequence of memory references shown in Figure above, if Δ = 10 memory references, then the working set at time $t_1$ is {1, 2, 5, 6, 7}. By time $t_2$, the working set has changed to {3, 4}.</p><p>If we compute the working-set size, $WSS<em>{i}$, for each process in the system, we can consider that $D=\sum</em>{}WSS_{i}$, where $D$ is the total demand for frames. If the total demand is greater than the total number of available frames $(D &gt; m)$, thrashing will occur.</p><h3 id="Page-Fault-Frequency"><a href="#Page-Fault-Frequency" class="headerlink" title="Page-Fault Frequency"></a>Page-Fault Frequency</h3><p>Thrashing has a high page-fault rate. We can establish upper and lower bounds on the desired page-fault rate </p><div align=center><img src="../../figure/operating-system/Chapter10-Virtual-Memory/page_fault_frequency.png" width=400></div><p>If the actual page-fault rate exceeds the upper limit, we allocate the process another frame. If the page-fault rate falls below the lower limit, we remove a frame from the process.</p><h2 id="Allocating-Kernel-Memory"><a href="#Allocating-Kernel-Memory" class="headerlink" title="Allocating Kernel Memory"></a>Allocating Kernel Memory</h2><p>Kernel memory is often allocated from a free-memory pool different from the list used to satisfy ordinary user-mode processes. </p><h3 id="Buddy-System"><a href="#Buddy-System" class="headerlink" title="Buddy System"></a>Buddy System</h3><p>The buddy system allocates memory from a fixed-size segment consisting of physically contiguous pages. Memory is allocated from this segment using a <strong><em>power-of-2 allocator</em></strong>.</p><div align=center><img src="../../figure/operating-system/Chapter10-Virtual-Memory/buddy_system_allocation.png" width=400></div><h3 id="Slab-Allocation"><a href="#Slab-Allocation" class="headerlink" title="Slab Allocation"></a>Slab Allocation</h3><p>A second strategy(和 buddy system 共同使用) for allocating kernel memory is known as <strong><em>slab allocation</em></strong>. A <strong><em>slab</em></strong> is made up of one or more physically contiguous pages. A <strong><em>cache</em></strong> consists of one or more slabs.</p><p>There is a single cache for each unique kernel data structure. Each cache is populated with objects that are instantiations of the kernel data structure the cache represents.</p><div align=center><img src="../../figure/operating-system/Chapter10-Virtual-Memory/slab_allocation.png" width=400></div><h2 id="Other-Considerations"><a href="#Other-Considerations" class="headerlink" title="Other Considerations"></a>Other Considerations</h2><h3 id="Prepaging"><a href="#Prepaging" class="headerlink" title="Prepaging"></a>Prepaging</h3><p>An obvious property of pure demand paging is the large number of page faults that occur when a process is <em>started</em>. <strong><em>Prepaging</em></strong> is an attempt to prevent this high level of initial paging. The strategy is to bring some—or all—of the pages that will be needed into memory at one time.</p><p>We remember the working set for a process suspended, when the process is to be resumed, we automatically bring back into memory its entire working set before restarting the process.</p>]]></content>
      
      
      <categories>
          
          <category> Operating system </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch Datasets &amp; DataLoaders 代码分析</title>
      <link href="/posts/2432c26f.html"/>
      <url>/posts/2432c26f.html</url>
      
        <content type="html"><![CDATA[<p>代码内容来自<a href="https://pytorch.org/tutorials/beginner/basics/data_tutorial.html">PyTorch官网</a></p><h2 id="Loading-a-Dataset"><a href="#Loading-a-Dataset" class="headerlink" title="Loading a Dataset"></a>Loading a Dataset</h2><p>首先展示一个从Fashion-MNIST中加载数据集的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> ToTensor</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">training_data = datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train=<span class="literal">True</span>,</span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    transform=ToTensor()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">test_data = datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train=<span class="literal">False</span>,</span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    transform=ToTensor()</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h2 id="Iterating-and-Visualizing-the-Dataset"><a href="#Iterating-and-Visualizing-the-Dataset" class="headerlink" title="Iterating and Visualizing the Dataset"></a>Iterating and Visualizing the Dataset</h2><p>我们可以像 <code>list</code> 一样使用 <code>Datasets</code> : <code>training_data[index]</code>.<br>我们可以用 <code>matplotlib</code> 展示部分数据集中的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">labels_map = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">&quot;T-Shirt&quot;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&quot;Trouser&quot;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&quot;Pullover&quot;</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="string">&quot;Dress&quot;</span>,</span><br><span class="line">    <span class="number">4</span>: <span class="string">&quot;Coat&quot;</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">&quot;Sandal&quot;</span>,</span><br><span class="line">    <span class="number">6</span>: <span class="string">&quot;Shirt&quot;</span>,</span><br><span class="line">    <span class="number">7</span>: <span class="string">&quot;Sneaker&quot;</span>,</span><br><span class="line">    <span class="number">8</span>: <span class="string">&quot;Bag&quot;</span>,</span><br><span class="line">    <span class="number">9</span>: <span class="string">&quot;Ankle Boot&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">figure = plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>)) <span class="comment"># figure()函数用于创建一个新的绘图窗口。</span></span><br><span class="line">cols, rows = <span class="number">3</span>, <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cols * rows + <span class="number">1</span>):</span><br><span class="line">    sample_idx = torch.randint(<span class="built_in">len</span>(training_data), size=(<span class="number">1</span>,)).item() <span class="comment"># 是使用PyTorch张量操作随机选择一个训练样本的索引号。</span></span><br><span class="line">    img, label = training_data[sample_idx]</span><br><span class="line">    figure.add_subplot(rows, cols, i) <span class="comment"># 当前图像添加到指定位置的子图中，其中i表示当前要添加的子图的位置编号</span></span><br><span class="line">    plt.title(labels_map[label]) </span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>) <span class="comment"># 关闭坐标轴显示</span></span><br><span class="line">    <span class="comment"># squeeze()函数将张量形状中的维度为1的维度去掉，</span></span><br><span class="line">    <span class="comment"># 因为imshow()函数只接受二维数组作为输入    </span></span><br><span class="line">    plt.imshow(img.squeeze(), cmap=<span class="string">&quot;gray&quot;</span>) </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="Creating-a-Custom-Dataset-for-your-files"><a href="#Creating-a-Custom-Dataset-for-your-files" class="headerlink" title="Creating a Custom Dataset for your files"></a>Creating a Custom Dataset for your files</h2><p>一个自定义的数据集类(继承自 <code>Dataset</code>)需要有 <code>__init__</code>,<code>__len__</code> 和 <code>__getitem__</code> 这三个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> torchvision.io <span class="keyword">import</span> read_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomImageDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, annotations_file, img_dir, transform=<span class="literal">None</span>, target_transform=<span class="literal">None</span></span>):</span><br><span class="line">        self.img_labels = pd.read_csv(annotations_file)</span><br><span class="line">        self.img_dir = img_dir</span><br><span class="line">        self.transform = transform</span><br><span class="line">        self.target_transform = target_transform</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>): <span class="comment"># 返回数据集中的图像数量</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_labels) </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>): <span class="comment"># 加载和处理单个图像及其标签</span></span><br><span class="line">        img_path = os.path.join(self.img_dir, self.img_labels.iloc[idx, <span class="number">0</span>])</span><br><span class="line">        image = read_image(img_path) <span class="comment"># 读取图像文件，并形成一个PyTorch张量</span></span><br><span class="line">        label = self.img_labels.iloc[idx, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> self.transform:</span><br><span class="line">            image = self.transform(image) <span class="comment"># 对加载的图像进行预处理，例如裁剪、缩放、翻转</span></span><br><span class="line">        <span class="keyword">if</span> self.target_transform:</span><br><span class="line">            label = self.target_transform(label) <span class="comment"># 对加载的标签进行预处理，例如进行独热编码、转换为张量</span></span><br><span class="line">        <span class="keyword">return</span> image, label</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p><code>labels.csv</code> 文件中包含的是图片的名称和label。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tshirt1.jpg, 0</span><br><span class="line">tshirt2.jpg, 0</span><br><span class="line">......</span><br><span class="line">ankleboot999.jpg, 9</span><br></pre></td></tr></table></figure></li><li><p>想要使用上述定义的类，可以使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataset = CustomImageDataset(annotations_file=<span class="string">&#x27;labels.csv&#x27;</span>, img_dir=<span class="string">&#x27;images/&#x27;</span>, transform=transforms.ToTensor())</span><br></pre></td></tr></table></figure><p>来加载数据</p></li></ul><h2 id="Preparing-your-data-for-training-with-DataLoaders"><a href="#Preparing-your-data-for-training-with-DataLoaders" class="headerlink" title="Preparing your data for training with DataLoaders"></a>Preparing your data for training with DataLoaders</h2><p><code>DataLoaders</code> 用于将数据集变成可迭代对象，相当于是处理数据，让训练更加方便。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">train_dataloader = DataLoader(training_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="Iterate-through-the-DataLoader"><a href="#Iterate-through-the-DataLoader" class="headerlink" title="Iterate through the DataLoader"></a>Iterate through the DataLoader</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Display image and label.</span></span><br><span class="line">train_features, train_labels = <span class="built_in">next</span>(<span class="built_in">iter</span>(train_dataloader))</span><br><span class="line"><span class="comment"># train_features是一个batch的图像数据，它是一个四维的张量，第一个维度是batch size，</span></span><br><span class="line"><span class="comment"># 第二个维度是通道数，第三个和第四个维度是图像的高和宽。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Feature batch shape: <span class="subst">&#123;train_features.size()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Labels batch shape: <span class="subst">&#123;train_labels.size()&#125;</span>&quot;</span>)</span><br><span class="line">img = train_features[<span class="number">0</span>].squeeze()</span><br><span class="line">label = train_labels[<span class="number">0</span>] <span class="comment"># 获取一张图像</span></span><br><span class="line">plt.imshow(img, cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Label: <span class="subst">&#123;label&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>薛定谔方程</title>
      <link href="/posts/5d5705d0.html"/>
      <url>/posts/5d5705d0.html</url>
      
        <content type="html"><![CDATA[<p>薛定谔方程不能由其他基本原理推导得到，只是一个基本假设，正确性由实验来检验。</p><h2 id="自由粒子薛定谔方程的建立"><a href="#自由粒子薛定谔方程的建立" class="headerlink" title="自由粒子薛定谔方程的建立"></a>自由粒子薛定谔方程的建立</h2><h3 id="自由粒子波函数"><a href="#自由粒子波函数" class="headerlink" title="自由粒子波函数"></a>自由粒子波函数</h3><script type="math/tex; mode=display">\psi(x,t)=Ae^{\frac{i}{\hbar}(p_{x}x-Et)}</script><p>微分，得到方程</p><script type="math/tex; mode=display">\frac{\partial \psi(x,t)}{\partial t}=-\frac{i}{\hbar}E\psi(x,t)</script><script type="math/tex; mode=display">\frac{\partial \psi(x,t)}{\partial x^{2}}=-\frac{p_{x}^{2}}{\hbar^{2}}</script><p>利用 $E=\frac{p_{x}^{2}}{2m}$ (由此可以看出薛定谔只适用于微观低速情况)</p><script type="math/tex; mode=display">i \hbar \frac{\partial }{\partial t}\psi(x,t)=- \frac{\hbar^{2}}{2m}\frac{\partial ^{2}}{\partial x^{2}}\psi(x,t)</script><h3 id="推广到势场中"><a href="#推广到势场中" class="headerlink" title="推广到势场中"></a>推广到势场中</h3><script type="math/tex; mode=display">i\hbar \frac{\partial }{\partial t}\psi(x,t)=[-\frac{\hbar^{2}}{2m}\frac{\partial ^{2}}{\partial x^{2}}+U(x,t)]\psi(x,t)</script><h3 id="推广到三维"><a href="#推广到三维" class="headerlink" title="推广到三维"></a>推广到三维</h3><script type="math/tex; mode=display">i\hbar \frac{\partial }{\partial t}\psi(x,t)=[-\frac{\hbar^{2}}{2m}\nabla ^{2}+U(\vec{r},t)]\psi(\vec{r},t)</script><h3 id="哈密顿算符"><a href="#哈密顿算符" class="headerlink" title="哈密顿算符"></a>哈密顿算符</h3><script type="math/tex; mode=display">\hat{H}=-\frac{\hbar^{2}}{2m}\nabla ^{2}+U(\vec{r},t)</script><p>则薛定谔方程可写成</p><script type="math/tex; mode=display">i \hbar \frac{\partial}{\partial t}\psi(\vec{r},t)=\hat{H}\psi(\vec{r},t)</script><p>哈密顿算符决定了微观粒子</p><ul><li>波函数随时间的演化</li><li>外界对例子的作用（包括不能用力表达的微观相互作用）</li></ul><h2 id="定态薛定谔方程"><a href="#定态薛定谔方程" class="headerlink" title="定态薛定谔方程"></a>定态薛定谔方程</h2><p>又称不含时薛定谔方程，能量本征方程</p><p>若 $\frac{\partial \hat{H}}{\partial t}=0$，或 $U$ 与时间无关，则薛定谔方程可以<strong>分离变量</strong>。</p><h3 id="分离变量"><a href="#分离变量" class="headerlink" title="分离变量"></a>分离变量</h3><p>设 $\psi(\vec{r},t)=\phi(\vec{r})\cdot T(t)$，将其代入薛定谔方程，得到</p><script type="math/tex; mode=display">i \hbar \phi(\vec{r})\frac{\mathrm{d}T(t)}{\mathrm{d}t}=[\hat{H}\phi(\vec{r})]T(t) \Rightarrow i \hbar \frac{\mathrm{d}T}{\mathrm{d}t}\frac{1}{T(t)}=\frac{1}{\phi(\vec{r})}\hat{H}\phi(\vec{r})\equiv E\ \text{(constant)}</script><p>从而得到两个方程</p><script type="math/tex; mode=display">i \hbar \frac{\mathrm{d}T(t)}{\mathrm{d}t}=E T(t) \tag{1}</script><script type="math/tex; mode=display">\hat{H} \phi(\vec{r})=E \phi(\vec{r}) \tag{2}</script><h3 id="振动因子"><a href="#振动因子" class="headerlink" title="振动因子"></a>振动因子</h3><p>解方程(1)，可以得到</p><script type="math/tex; mode=display">T(t)=Ce^{-i \frac{E}{\hbar}t}</script><p>经量纲分析，知 $E$ 为能量量纲。因此 $E$ 应表示粒子能量。</p><h3 id="定态薛定谔方程-1"><a href="#定态薛定谔方程-1" class="headerlink" title="定态薛定谔方程"></a>定态薛定谔方程</h3><p>将哈密顿算符表达式代入方程(2)，得到</p><script type="math/tex; mode=display">(-\frac{\hbar^{2}}{2m}\nabla ^{2}+U(\vec{r}))\phi(\vec{r})=E\phi(\vec{r})</script><p>该方程即为定态薛定谔方程。</p><p>在物理上，$E$ 只有取一些特定值，方程的解才能满足波函数的条件。</p><ul><li>满足方程的特定的 $E$，成为<strong>能量本征值</strong>。</li><li>$\phi_{E}$ 成为与 $E$ 对应的<strong>本征波函数</strong>。</li></ul><p>最后写出的波函数形式为</p><script type="math/tex; mode=display">\psi_{E}(\vec{r},t)=\phi_{E}(\vec{r})e^{- \frac{i}{\hbar}Et}</script><p>该波函数（定态波函数）描述的态成为<strong>定态</strong>。</p><ul><li>能量($E$)取确定值的状态，薛定谔方程的特解 <!-- TODO 为什么是特解？ --></li><li>粒子在空间出现的概率密度分布是稳定不变的.<script type="math/tex; mode=display">\rho(\vec{r},t)=\left\vert \psi_{E}(\vec{r},t) \right\vert ^{2}=\phi^{*}_{E}(\vec{r})e^{ \frac{i}{\hbar}Et}\cdot \phi_{E}(\vec{r})e^{- \frac{i}{\hbar}Et}=\left\vert \phi_{E}(\vec{r}) \right\vert ^{2}</script></li></ul><h3 id="薛定谔方程的定态解"><a href="#薛定谔方程的定态解" class="headerlink" title="薛定谔方程的定态解"></a>薛定谔方程的定态解</h3><p>对于不同的势能函数和能量区间，能量本征值可以取一系列分立的值，也可以取连续值。为了讨论方便，下面假设它取分立值 $\left{ E<em>n,n=1,2,3\cdots \right}$，对应本征波函数 $\left{ \phi</em>{n},n=1,2,3\cdots \right}$</p><p>得到一系列定态解</p><script type="math/tex; mode=display">\psi_{n}(x,t)=\phi_{n}(x)e^{- \frac{i}{\hbar}E_nt},n=1,2,3\cdots</script><p>通解可写为</p><script type="math/tex; mode=display">\psi(x,t)=\sum_{n}C_n\psi_{n}(x,t)=\sum_{n}C_n\phi_{n}(x)e^{- \frac{i}{\hbar}E_nt}</script><p>系数 $C_n$ 可以按下式计算:（要求知道 $t=0$ 时的波函数）</p><script type="math/tex; mode=display">C_n=\int_{-\infty}^{\infty}\phi_{n}^{*}(x)\psi(x,0)\mathrm{d}x</script><h2 id="关于薛定谔方程的讨论"><a href="#关于薛定谔方程的讨论" class="headerlink" title="关于薛定谔方程的讨论"></a>关于薛定谔方程的讨论</h2><p>薛定谔方程</p><script type="math/tex; mode=display">i \hbar \psi(\vec{r},t)=\hat{H} \psi(\vec{r},t)</script><p>是量子力学的<strong>基本假定</strong></p><ul><li>薛定谔方程是线性偏微分方程，解满足态叠加原理</li><li>关于时间是一阶的，与经典波动方程不同。（经典：$\displaystyle \frac{\partial ^{2}\xi}{\partial t^{2}}=u \nabla ^{2} \xi$） 不同</li></ul><h2 id="几率流密度矢量"><a href="#几率流密度矢量" class="headerlink" title="几率流密度矢量"></a>几率流密度矢量</h2><h3 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h3><p>薛定谔方程</p><script type="math/tex; mode=display">i\hbar \frac{\partial }{\partial t}\psi=[-\frac{\hbar^{2}}{2m}\nabla ^{2}+U]\psi \tag{1}</script><script type="math/tex; mode=display">-i\hbar \frac{\partial }{\partial t}\psi^{*}=[-\frac{\hbar^{2}}{2m}\nabla ^{2}+U]\psi^{*} \tag{2}</script><p>由 $\psi^{*}\times (1)-\psi\times (2)$ 得到：</p><script type="math/tex; mode=display">i \hbar \psi^{*}\frac{\partial \psi}{\partial t} +i \hbar \psi \frac{\partial \psi^{*}}{\partial t}=- \frac{\hbar^{2}}{2m} [\psi^{*} \nabla ^{2}\psi-\psi \nabla ^{2}\psi^{*}]</script><ul><li><p>左侧：</p><script type="math/tex; mode=display">i \hbar \psi^{*}\frac{\partial \psi}{\partial t} +i \hbar \psi \frac{\partial \psi^{*}}{\partial t}=i \hbar \frac{\partial \psi \psi^{*}}{\partial t}</script></li><li><p>右侧：</p><script type="math/tex; mode=display">\begin{aligned}\because \nabla \cdot (\psi \nabla \psi^{*}) &=\frac{\partial }{\partial x}\left( \psi \frac{\partial }{\partial x}\psi^{*} \right) + \frac{\partial }{\partial y}\left( \psi \frac{\partial }{\partial y}\psi^{*} \right) + \frac{\partial }{\partial z}\left( \psi \frac{\partial }{\partial z}\psi^{*} \right) \\&=\frac{\partial \psi}{\partial x}\frac{\partial \psi^{*}}{\partial x}+\psi \frac{\partial ^{2}\psi^{*}}{\partial x^{2}}+ \frac{\partial \psi}{\partial y}\frac{\partial \psi^{*}}{\partial y}+\psi \frac{\partial ^{2}\psi^{*}}{\partial y^{2}}+ \frac{\partial \psi}{\partial z}\frac{\partial \psi^{*}}{\partial z}+\psi \frac{\partial ^{2}\psi^{*}}{\partial z^{2}}\\&=\nabla \psi\cdot \nabla \psi^{*}+\psi \nabla ^{2}\psi^{*}\end{aligned}</script><script type="math/tex; mode=display">\therefore \frac{\hbar^{2}}{2m} (\psi^{*} \nabla ^{2}\psi-\psi \nabla ^{2}\psi^{*})=\frac{\hbar^{2}}{2m}\nabla \cdot (\psi \nabla \psi^{*}-\psi^{*}\nabla \psi)</script></li></ul><p>最后得到：</p><script type="math/tex; mode=display">i \hbar \frac{\partial \psi \psi^{*}}{\partial t}= \frac{\hbar^{2}}{2m}\nabla \cdot (\psi \nabla \psi^{*}-\psi^{*}\nabla \psi)</script><h3 id="含义解释"><a href="#含义解释" class="headerlink" title="含义解释"></a>含义解释</h3><ul><li><strong>几率密度</strong>：$\rho=\psi^{*}\psi$</li><li>定义<strong>几率流密度矢量</strong>：$\vec{J}=\displaystyle  \frac{i \hbar}{2m}(\psi \nabla \psi^{<em>}-\psi^{</em>}\nabla \psi)$</li></ul><script type="math/tex; mode=display">\Rightarrow \frac{\partial \rho}{\partial t}+\nabla \cdot \vec{J}=0</script><p>利用高斯定理得到积分形式</p><script type="math/tex; mode=display">\frac{\mathrm{d}}{\mathrm{d}t} \iiint_{\tau} \rho(\vec{r},t)\mathrm{d}\tau=- \oiint_{S}\vec{J}\cdot \mathrm{d}\vec{S}</script><p>可以看出，左侧是在空间区域 $\tau$ 内的概率变化率，右侧为单位时间流入该区域的概率。可以看出：</p><blockquote><p>几率守恒具有定域性质，当空间某处几率减少了，必然另外一些地方几率增加，使总几率不变，并伴随着某种流来实现这种变化。</p></blockquote><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>对于整个空间而言</p><script type="math/tex; mode=display">\frac{\mathrm{d}}{\mathrm{d}t} \iiint_{\infty} \rho(\vec{r},t)\mathrm{d}\tau=- \oiint_{\infty}\vec{J}\cdot \mathrm{d}\vec{S} \rightarrow 0</script><p>表示全空间总概率不变。</p><p>说明：<br>因为 $\displaystyle \int_{\Omega}\left\vert \psi(\vec{r},t) \right\vert ^{2} \mathrm{d}V$ 可积（薛定谔方程需要的条件），因此当 $r\rightarrow 0$,$\left\vert \psi(\vec{r},t)\rightarrow 0\right\vert$ 快于 $\displaystyle \frac{1}{r^{3 /2}}$，从而 $J\rightarrow 0$ 快于 $\displaystyle \frac{1}{r^{3}}$，得到上面方程积分为 $0$。</p>]]></content>
      
      
      <categories>
          
          <category> 量子力学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch Quickstart 代码分析</title>
      <link href="/posts/f5508786.html"/>
      <url>/posts/f5508786.html</url>
      
        <content type="html"><![CDATA[<p>代码内容来自<a href="https://pytorch.org/tutorials/beginner/basics/quickstart_tutorial.html">PyTorch官网</a></p><h2 id="Wroking-With-data"><a href="#Wroking-With-data" class="headerlink" title="Wroking With data"></a>Wroking With data</h2><p>PyTorch提供了两种数据处理的基本组件：<code>torch.utils.data.DataLoader</code>和<code>torch.utils.data.Dataset</code>。<code>Dataset</code>用来存储样本及其对应的标签，而<code>DataLoader</code>则在<code>Dataset</code>周围封装一个可迭代对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> ToTensor</span><br></pre></td></tr></table></figure><p><code>torchvision.datasets</code> 模块包含许多实际视觉数据的 Dataset 对象，例如 CIFAR、COCO。这里我们将使用 FashionMNIST 数据集。每个 TorchVision Dataset 包括两个参数：<code>transform</code> 和 <code>target_transform</code>，分别用于修改样本和标签。</p><p>一些参数的解释</p><ul><li><code>root</code>：这是数据集将存储的目录。如果数据集已经被下载过，它将不会被重新下载。</li><li><code>transform</code>：这个参数指定了在加载数据集中的图像之前将应用的转换。在本例中，使用了<code>ToTensor()</code>转换，它将图像数据从形状为（H，W，C）的numpy数组转换为形状为（C，H，W）的PyTorch张量，并将值从0到255转换为0到1的范围内。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Download training data from open datasets.</span></span><br><span class="line">training_data = datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train=<span class="literal">True</span>,</span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    transform=ToTensor(),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Download test data from open datasets.</span></span><br><span class="line">test_data = datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">&quot;data&quot;</span>,</span><br><span class="line">    train=<span class="literal">False</span>,</span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    transform=ToTensor(),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们将<code>Dataset</code>作为参数传递给<code>DataLoader</code>。这将在我们的数据集上创建一个可迭代对象，支持自动分批、采样、洗牌和多进程数据加载。更重要的是，<code>DataLoader</code>允许您一次加载一小批数据，处理它，然后继续处理下一批数据。在这里，我们定义了<code>batch</code>大小为64，即<code>dataloader</code>迭代器中的每个元素将返回一个批次包含64个特征和标签.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create data loaders.</span></span><br><span class="line">train_dataloader = DataLoader(training_data, batch_size=batch_size)</span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=batch_size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> test_dataloader:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Shape of X [N, C, H, W]: <span class="subst">&#123;X.shape&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Shape of y: <span class="subst">&#123;y.shape&#125;</span> <span class="subst">&#123;y.dtype&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="Creating-Models"><a href="#Creating-Models" class="headerlink" title="Creating Models"></a>Creating Models</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get cpu or gpu device for training.</span></span><br><span class="line">device = <span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;mps&quot;</span> <span class="keyword">if</span> torch.backends.mps.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Using <span class="subst">&#123;device&#125;</span> device&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define model</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NeuralNetwork</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将形状为(batch_size, num_channels, height, width)的张量reshape为</span></span><br><span class="line">        <span class="comment"># (batch_size, num_channels * height * width)的张量。</span></span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.linear_relu_stack = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">28</span>*<span class="number">28</span>, <span class="number">512</span>), <span class="comment"># 28*28维度的输入,512维的输出</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">10</span>) <span class="comment"># 分类结果,这里分成10类</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        logits = self.linear_relu_stack(x)</span><br><span class="line">        <span class="keyword">return</span> logits</span><br><span class="line"></span><br><span class="line">model = NeuralNetwork().to(device)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure><h2 id="Optimizing-the-Model-Parameters"><a href="#Optimizing-the-Model-Parameters" class="headerlink" title="Optimizing the Model Parameters"></a>Optimizing the Model Parameters</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss_fn = nn.CrossEntropyLoss() <span class="comment"># 用于多分类问题的损失函数。它将softmax激活函数和负对数似然损失结合成一个函数</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">1e-3</span>) <span class="comment">#  stochastic gradient descent (SGD),随机梯度下降算法</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">dataloader, model, loss_fn, optimizer</span>):</span><br><span class="line">    size = <span class="built_in">len</span>(dataloader.dataset) <span class="comment"># 数据集中包含的样本数量</span></span><br><span class="line">    model.train() <span class="comment"># 将model设置为训练模式</span></span><br><span class="line">    <span class="keyword">for</span> batch, (X, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataloader):</span><br><span class="line">        X, y = X.to(device), y.to(device) <span class="comment"># 将数据转移到计算设备上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 输入的数据 X 会被传递给模型的 forward 方法，并返回模型的输出结果 pred</span></span><br><span class="line">        pred = model(X)</span><br><span class="line">        loss = loss_fn(pred, y) <span class="comment"># Compute prediction error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Backpropagation</span></span><br><span class="line">        optimizer.zero_grad() <span class="comment"># 模型参数的梯度设置为0，以避免梯度叠加。</span></span><br><span class="line">        loss.backward() <span class="comment"># 计算损失函数对模型所有参数的梯度</span></span><br><span class="line">        optimizer.step() <span class="comment"># 根据计算出的梯度更新模型的参数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            loss, current = loss.item(), batch * <span class="built_in">len</span>(X)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;loss: <span class="subst">&#123;loss:&gt;7f&#125;</span>  [<span class="subst">&#123;current:&gt;5d&#125;</span>/<span class="subst">&#123;size:&gt;5d&#125;</span>]&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">dataloader, model, loss_fn</span>):</span><br><span class="line">    size = <span class="built_in">len</span>(dataloader.dataset)</span><br><span class="line">    num_batches = <span class="built_in">len</span>(dataloader)</span><br><span class="line">    model.<span class="built_in">eval</span>() <span class="comment"># 将模型设置为测试模式</span></span><br><span class="line">    test_loss, correct = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># torch.no_grad() 表示在不计算梯度的情况下进行前向传递，以避免不必要的计算和内存消耗</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> dataloader:</span><br><span class="line">            X, y = X.to(device), y.to(device)</span><br><span class="line">            pred = model(X)</span><br><span class="line">            test_loss += loss_fn(pred, y).item()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># pred 是模型对输入数据的预测结果，它的形状为 (batch_size, num_classes)</span></span><br><span class="line">            <span class="comment"># 使用 argmax(1) 取出每个样本的预测结果的下标，即预测类别。</span></span><br><span class="line">            correct += (pred.argmax(<span class="number">1</span>) == y).<span class="built_in">type</span>(torch.<span class="built_in">float</span>).<span class="built_in">sum</span>().item()</span><br><span class="line">    test_loss /= num_batches</span><br><span class="line">    correct /= size</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Test Error: \n Accuracy: <span class="subst">&#123;(<span class="number">100</span>*correct):&gt;<span class="number">0.1</span>f&#125;</span>%, Avg loss: <span class="subst">&#123;test_loss:&gt;8f&#125;</span> \n&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">epochs = <span class="number">20</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Epoch <span class="subst">&#123;t+<span class="number">1</span>&#125;</span>\n-------------------------------&quot;</span>)</span><br><span class="line">    train(train_dataloader, model, loss_fn, optimizer)</span><br><span class="line">    test(test_dataloader, model, loss_fn)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter9-Main Memory</title>
      <link href="/posts/69ff1809.html"/>
      <url>/posts/69ff1809.html</url>
      
        <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>We are interested only in the sequence of memory addresses generated by the running program.</p><h3 id="Basic-Hardware"><a href="#Basic-Hardware" class="headerlink" title="Basic Hardware"></a>Basic Hardware</h3><p>We first need to make sure that each process has a separate memory space. Separate per-process memory space protects the processes from each other and is fundamental to having multiple processes loaded in memory for concurrent execution. (进程地址之间相互隔离，保护各个进程不产生冲突，即不会访问到其他进程的地址)</p><p>We can provide this protection by using two registers:</p><ul><li><strong>base register</strong> holds the smallest legal physical memory address; </li><li><strong>limit register</strong> specifies the size of the range.</li></ul><div align=center><img src="../../figure/operating-system/Chapter9-Main-Memory/generate_logical_address.png" width=500></div><p>使用两个register是因为早期CPU只有32位，只能访问4GB空间，所以要用两个寄存器访问全部空间。</p><p>The base and limit registers can be loaded only by the operating system</p><h3 id="Address-Binding"><a href="#Address-Binding" class="headerlink" title="Address Binding"></a>Address Binding</h3><p>Most systems allow a user process to reside in any part of the physical memory.</p><p>Addresses in the source program are generally <strong>symbolic</strong> (such as the variable count). Acompiler typically <strong><em>binds</em></strong> these symbolic addresses to k addresses. Each binding is a mapping from one address space to another.</p><p>Classically, the binding of instructions and data to memory addresses can be done at <em>any</em> step along the way:<br>• Compile time<br>• Load time<br>• Execution time</p><h3 id="Logical-Versus-Physical-Address-Space"><a href="#Logical-Versus-Physical-Address-Space" class="headerlink" title="Logical Versus Physical Address Space"></a>Logical Versus Physical Address Space</h3><p>An address generated by the <em>CPU</em> is commonly referred to as a <strong><em>logical address</em></strong>, whereas an address seen by the memory unit (the one loaded into the <strong><em>memory-address register</em></strong> 应该就是实际访问的) is commonly referred to as a <strong><em>physical address</em></strong>.</p><p>The run-time mapping from virtual to physical addresses is done by a hardware device called the <strong><em>memory-management unit (MMU)</em></strong> .</p><div align=center><img src="../../figure/operating-system/Chapter9-Main-Memory/MMU.png" width=500></div><p>a simple MMU scheme:<br>Use <strong><em>relocation register</em></strong> (The value in the relocation register is added to every address generated by a user process at the time the address is sent to memory)</p><div align=center><img src="../../figure/operating-system/Chapter9-Main-Memory/MMU_relocation_register.png" width=500></div><h2 id="Contiguous-Memory-Allocation"><a href="#Contiguous-Memory-Allocation" class="headerlink" title="Contiguous Memory Allocation"></a>Contiguous Memory Allocation</h2><p>In <strong><em>contiguous memory allocation</em></strong>, each process is contained in a single section of memory that is contiguous to the section containing the next process. </p><h3 id="Memory-Protection"><a href="#Memory-Protection" class="headerlink" title="Memory Protection"></a>Memory Protection</h3><p>使用 relocation register 和 limit register 就能实现。</p><h3 id="Memory-Allocation"><a href="#Memory-Allocation" class="headerlink" title="Memory Allocation"></a>Memory Allocation</h3><p>Initially, all memory is available for user processes and is considered one large block of available memory, a hole. Eventually, as you will see, memory contains a set of holes of various sizes.</p><div align=center><img src="../../figure/operating-system/Chapter9-Main-Memory/variable_partition.png" width=500></div><p>In general, as mentioned, the memory blocks available comprise a set of holes of various sizes scattered throughout memory. When a process arrives and needs memory, there are many solutions.<br>• First fit. (找到能用的就行)<br>• Best fi . (遍历全部，找大小恰好合适或者差别不大的)<br>• Worst fit. (找最大的hole)</p><h3 id="Fragmentation"><a href="#Fragmentation" class="headerlink" title="Fragmentation"></a>Fragmentation</h3><div align=center><img src="../../figure/operating-system/Chapter9-Main-Memory/fragmentation.png" width=500></div><ul><li>在external fragmentation的情况下，process 无法被正常加载运行</li><li>右面那幅图中没用到的2MB就是internal fragmentation.</li></ul><h2 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h2><p><strong><em>Paging</em></strong> is a memory-management scheme that permits a process’s physical address space to be non-contiguous.<br>One of advantages: Paging avoids <em>external fragmentation</em> .</p><h3 id="Basic-Method"><a href="#Basic-Method" class="headerlink" title="Basic Method"></a>Basic Method</h3><ul><li>breaking physical memory into fixed-sized blocks called <strong><em>frames</em></strong></li><li>breaking logical memory into blocks of the same size called <strong><em>pages</em></strong></li></ul><p>Every address generated by the CPU is divided into two parts: a <strong><em>page number (p)</em></strong> and a <strong><em>page offset (d)</em></strong> </p><div align=center><img src="../../figure/operating-system/Chapter9-Main-Memory/logical_address_page.png" width=400></div><p>If the size of page is 4KB in a 32-bits system, then $n=12$, $m-n=20$</p><p>The page number is used as an index into a per-process <strong><em>page table</em></strong>.</p><div align=center><img src="../../figure/operating-system/Chapter9-Main-Memory/paging_hardware.png" width=600></div><p>The following outlines the steps taken by the <em>MMU</em> to translate a <em>logical address</em> generated by the CPU to a <em>physical address</em>:(直接看图也能看出来) </p><ol><li>Extract the page number p and use it as an index into the page table.</li><li>Extract the corresponding frame number f from the page table.</li><li>Replace the page number p in the logical address with the frame number f.</li></ol><p>The paging model of memory:</p><div align=center><img src="../../figure/operating-system/Chapter9-Main-Memory/paging_model.png" width=500></div><p>The size of page and frame is the same.</p><p>Paging scheme can’t avoid <em>internal fragmentation</em>.</p><p>Linux supkports two page sizes: a default page size (typically 4 KB) and an architecture-dependent larger page size called <strong><em>huge pages</em></strong>.(ususally 4KB-2MB)</p><p>An important aspect of paging is the clear separation between the programmer’s view of memory and the actual physical memory. (程序员看到的地址是连续的，但实际上可能是离散的).  This mapping is hidden from the programmer and is controlled by the operating system.<br><strong><em>frame table</em></strong>: has one entry for each physical page frame, indicating whether the latter is free or allocated and, if it is allocated, to which page of which process (or processes).</p><div align=center><img src="../../figure/operating-system/Chapter9-Main-Memory/frame_allocation.png" width=600></div><p>The operating system maintains a copy of the page table for each process, therefore increases the context-switch time.</p><h3 id="Hardware-Support"><a href="#Hardware-Support" class="headerlink" title="Hardware Support"></a>Hardware Support</h3><p>A pointer to the page table is stored with the other register values (like the instruction pointer) in the process control block of each process.(PCB中保存了一个指向page table的指针，PTBR)</p><p>Most contemporary CPUs, however, support much larger page tables (for example, 220 entries). For these machines, the page table is kept in main memory, and a <strong><em>page-table base register (PTBR)</em></strong> points to the page table. (存在memory中的原因是page table 太大，cache放不下)。</p><h4 id="Translation-Look-Aside-Buffer"><a href="#Translation-Look-Aside-Buffer" class="headerlink" title="Translation Look-Aside Buffer"></a>Translation Look-Aside Buffer</h4><p>With normal scheme, <em>two</em> memory accesses are needed to access data </p><ol><li>one for the page-table entry  </li><li>one for the actual data</li></ol><p><strong><em>translation look-aside buffer (TLB)</em></strong> :a special, small, fast-lookup hardware cache to store some <strong>page-frame pair</strong>.(大概能存储1KB的数据)</p><p>A TLB lookup in modern hardware is part of the instruction pipeline, essentially adding no performance penalty.(时间可以忽略不计)</p><div align=center><img src="../../figure/operating-system/Chapter9-Main-Memory/paging_hardware_with_TLB.png" width=600></div><p>When a logical address is generated by the CPU, the MMU first checks if its page number is present in the TLB.</p><ul><li>If the page number is found, its frame number is immediately available and is used to access memory.</li><li>If the page number is not in the TLB (known as a TLB miss),  a memory reference to the page table must be made. <ul><li>In addition, we add the page number and frame number to the TLB</li><li>If the TLB is already full of entries: Replacement policies range from least recently used (LRU) through round-robin to random. </li></ul></li></ul><p>The percentage of times that the page number of interest is found in the TLB is called the <strong><em>hit ratio</em></strong>. (An 80-percent hit ratio and 10 nanoseconds to access memory, for example) To find the <strong><em>effective memory-access time</em></strong>, we weight the case by its probability:<br>effective access time = 0.80 × 10 + 0.20 × 20 = 12 nanoseconds</p><h3 id="Protection"><a href="#Protection" class="headerlink" title="Protection"></a>Protection</h3><p>One additional bit is generally attached to each entry in the page table: a <strong><em>valid–invalid</em></strong> bit. The operating system sets this bit for each page to allow or disallow access to the page.</p><div align=center><img src="../../figure/operating-system/Chapter9-Main-Memory/valid_invalid_bit.png" width=600></div><p>For example, in the figure above, addresses in pages 0, 1, 2, 3, 4, and 5 are mapped normally through the page table. Any attempt to generate an address in pages 6 or 7, however, will find that the valid–invalid bit is set to invalid, and the computer will trap to the operating system (invalid page reference).</p><p>valid-invalid bit 是因为有些逻辑内存和物理内存不能一一对应。这和虚拟内存相关。</p><h3 id="Shared-Pages"><a href="#Shared-Pages" class="headerlink" title="Shared Pages"></a>Shared Pages</h3><div align=center><img src="../../figure/operating-system/Chapter9-Main-Memory/shared_page.png" width=500></div><h2 id="Structure-of-the-Page-Table"><a href="#Structure-of-the-Page-Table" class="headerlink" title="Structure of the Page Table"></a>Structure of the Page Table</h2><h3 id="Hierarchical-Paging"><a href="#Hierarchical-Paging" class="headerlink" title="Hierarchical Paging"></a>Hierarchical Paging</h3><p>For example, consider a system with a 32-bit logical address space. If the page size in such a system is 4 KB ($2^{12}$), then a page table may consist of over 1 million entries ($2^{20}=2^{32}/ 2^{12}$). Clearly, we would not want to allocate the page table contiguously in main memory(太大了不方便查找). One simple solution to this problem is to <strong>divide the page table</strong> into smaller pieces.</p><p>One way is to use a two-level paging algorithm (also known as a <strong><em>forward-mapped</em></strong> page table), in which the page table itself is also paged.</p><div align=center><img src="../../figure/operating-system/Chapter9-Main-Memory/two_level_page_table.png" width=400></div><p>The logical address is as follows:</p><div align=center><img src="../../figure/operating-system/Chapter9-Main-Memory/logical_addr_of_two_level_page.png" width=350></div><p>The address-translation method for this architecture:</p><div align=center><img src="../../figure/operating-system/Chapter9-Main-Memory/address_translation_of_two_level.png" width=550></div><p>For a system with a 64-bit logical address space, a two-level paging scheme is no longer appropriate. (对于一般的台式机来说，切成3层已经足够了，因为前面有很多地址用不到，但是对于差不多用满64位的数据中心而言，可能要分到7层).(hierarchical page tables are generally considered inappropriate.)</p><h3 id="Hashed-Page-Tables"><a href="#Hashed-Page-Tables" class="headerlink" title="Hashed Page Tables"></a>Hashed Page Tables</h3><p>适合数据量比较大的情况</p><div align=center><img src="../../figure/operating-system/Chapter9-Main-Memory/hash_page_table.png" width=550></div>]]></content>
      
      
      <categories>
          
          <category> Operating system </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter8-Deadlocks</title>
      <link href="/posts/ac36b867.html"/>
      <url>/posts/ac36b867.html</url>
      
        <content type="html"><![CDATA[<h2 id="System-Model"><a href="#System-Model" class="headerlink" title="System Model"></a>System Model</h2><p>A system consists of a finite number of resources to be distributed among a number of competing threads. If a thread requests an instance of a resource type, the allocation of <em>any</em> instance of the type should satisfy the request.</p><div align=center><img src="../../figure/operating-system/Chapter8-Deadlocks/system_model.png" width=700></div><p>A thread may utilize a resource in only the following sequence:</p><ol><li><strong>Request</strong></li><li><strong>Use</strong>:  The thread can operate on the resource (for example, if the resource is a mutex lock, the thread can access its critical section).</li><li><strong>Release</strong></li></ol><p>A set of threads is in a deadlocked state when every thread in the set is waiting for an event that can be caused only by another thread in the set. </p><h2 id="Deadlock-Characterization"><a href="#Deadlock-Characterization" class="headerlink" title="Deadlock Characterization"></a>Deadlock Characterization</h2><h3 id="Necessary-Conditions"><a href="#Necessary-Conditions" class="headerlink" title="Necessary Conditions"></a>Necessary Conditions</h3><p>A deadlock situation can arise if the following four conditions hold <em>simultaneously</em> in a system:</p><ol><li><strong>Mutual exclusion</strong></li><li><strong>Hold and wait</strong><ol><li>must be holding at least one resource</li><li>waiting to acquire additional resources that are currently being held by other threads.</li></ol></li><li><strong>No preemption</strong>(优先级相同可能会导致这种情况)</li><li><strong>Circular wait</strong></li></ol><h3 id="Resource-Allocation-Graph"><a href="#Resource-Allocation-Graph" class="headerlink" title="Resource-Allocation Graph"></a>Resource-Allocation Graph</h3><ul><li>Ti → Rj: it signifies that thread Ti has requested an instance of resource type Rj and is currently waiting for that resource. (<strong><em>request edge</em></strong>)</li><li>Rj → Ti: it signifies that an instance of resource type Rj has been allocated to thread Ti.(<strong><em>assignment edge</em></strong>)<div align=center><img src="../../figure/operating-system/Chapter8-Deadlocks/resource_allocation_graph_instance.png" width=500></div></li></ul><p>图上圆点表示资源的实例（instance）</p><p>A basic fact: if a resource-allocation graph does not have a cycle, then the system is not in a deadlocked state. If there is a cycle, then the system may or may not be in a deadlocked state.(没有环（看成有向图）一定不会死锁，但有环也不一定会)</p><div align=center><img src="../../figure/operating-system/Chapter8-Deadlocks/RAG_with_a_deadlock.png" width=300></div><p>有环有死锁</p><div align=center><img src="../../figure/operating-system/Chapter8-Deadlocks/RAG_without_deadlock.png" width=300></div><p>有环但没有死锁</p><h2 id="Deadlock-Prevention"><a href="#Deadlock-Prevention" class="headerlink" title="Deadlock Prevention"></a>Deadlock Prevention</h2><h3 id="Mutual-Exclusion"><a href="#Mutual-Exclusion" class="headerlink" title="Mutual Exclusion"></a>Mutual Exclusion</h3><p>The mutual-exclusion condition must hold.(不能避免)</p><h3 id="Hold-and-Wait"><a href="#Hold-and-Wait" class="headerlink" title="Hold and Wait"></a>Hold and Wait</h3><p>Two <strong>protocols</strong>:</p><ol><li>requires each thread to request and be allocated all its resources before it begins execution. (impractical, for most applications due to the dynamic nature of requesting resources.)</li><li>A thread to request resources only when it has none.That is, before it can request any additional resources, it must release all the resources that it is currently allocated.(请求资源之前先释放所有资源)</li></ol><p><strong>disadvantages</strong>：</p><ul><li>resource utilization may be low</li><li>starvation is possible</li></ul><h3 id="No-Preemption"><a href="#No-Preemption" class="headerlink" title="No Preemption"></a>No Preemption</h3><p>所以可以使用优先级可抢占式<br>A protocol:<br>如果某个线程请求不到资源无法执行，所有在等待的线程释放资源，然后按优先级排列。高优先级的先使用资源。</p><p>This protocol is often applied to resources whose state can be easily saved and restored later, such as CPU registers and database transactions.</p><h3 id="Circular-Wait"><a href="#Circular-Wait" class="headerlink" title="Circular Wait"></a>Circular Wait</h3><p>presents an opportunity for a <em>practical</em> solution by invalidating one of the necessary conditions.</p><p>One way to ensure that this condition never holds is to impose a total ordering of all resource types and to require that each thread requests resources in an increasing order of enumeration.</p><p>Example:<br>Each thread can request resources only in an increasing order of enumeration.(如果有多个锁的话，一定要按顺序拿)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(first_mutex) = <span class="number">1</span></span><br><span class="line">F(second_mutex) = <span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>After that, the thread can request an instance of resource Rj if and only if F(Rj) &gt; F(Ri). Using the function defined above, a thread that wants to use both <code>first_mutex</code> and <code>second_mutex</code> at the same time must first request <code>first_mutex</code> and then <code>second_mutex</code>.</p><h2 id="Deadlock-Avoidance"><a href="#Deadlock-Avoidance" class="headerlink" title="Deadlock Avoidance"></a>Deadlock Avoidance</h2><p>Deadlock-prevention algorithms, as discussed before, are possibly low device utilization and reduced system throughput.</p><p>An alternative method for avoiding deadlocks is to require additional information about how resources are to be requested.(纵览全局)</p><h3 id="Safe-State"><a href="#Safe-State" class="headerlink" title="Safe State"></a>Safe State</h3><p>A state is safe if the system can allocate resources to each thread (up to its maximum) in some order and still avoid a deadlock. More formally, a system is in a safe state <strong>only if there exists a <em>safe sequence</em></strong>.</p><h3 id="Resource-Allocation-Graph-Algorithm"><a href="#Resource-Allocation-Graph-Algorithm" class="headerlink" title="Resource-Allocation-Graph Algorithm"></a>Resource-Allocation-Graph Algorithm</h3><p>we introduce a new type of edge, called a <strong><em>claim edge</em></strong></p><div align=center><img src="../../figure/operating-system/Chapter8-Deadlocks/claim_no_cycle.png" width=400></div>从图中可以看出加了申请边(claim edge)之后不会导致成环(cycle)，所以可以加入这两条边。<div align=center><img src="../../figure/operating-system/Chapter8-Deadlocks/claim_with_cycle.png" width=400></div>从图中可以看出加了申请边(claim edge)之后会导致成环(cycle)，所以不能加入这两条边。<div align=center><img src="../../figure/operating-system/Chapter8-Deadlocks/wait_for_graph.png" width=500></div>从左到右表示对图的化简，看起来更清晰明了，方便看出有没有环。像这种情况导致成环，一般是将T2去掉（因为连了最多的边），然后让其他几个线程并行。### Banker’s AlgorithmWe need the following data structures, where n is the number of threads in the system and m is the number of resource types:* **Available**. If Available[j] equals k, then k instances of resource type Rj are available.* **Max**.If Max[i][j] equals k, then thread Ti may request at most k instances of resource type Rj.* **Allocation**.If Allocation[i][j] equals k, then thread Ti is currently allocated k instances of resource type Rj.* **Need**. Need[i][j] equals Max[i][j] − Allocation[i][j].Available是对系统而言，而Max,Allocation,Need是对单个进程（线程）而言。**Example**:Consider a system with five threads T0 through T4 and three resource types A, B, and C.Suppose that the following snapshot represents the current state of the system:<div align=center><img src="../../figure/operating-system/Chapter8-Deadlocks/bank_algo_current_state.png" width=500></div><p>The content of the matrix Need is defined to be Max − Allocation and is as follows:</p><div align=center><img src="../../figure/operating-system/Chapter8-Deadlocks/bank_algo_needs.png" width=180></div><p>We claim that the system is currently in a safe state. Indeed, the sequence<T1, T3, T4, T2, T0> satisfies the safety criteria.(就是按照常规分析最后能执行完)</p><h2 id="Recovery-from-Deadlock"><a href="#Recovery-from-Deadlock" class="headerlink" title="Recovery from Deadlock"></a>Recovery from Deadlock</h2><h3 id="Process-and-Thread-Termination"><a href="#Process-and-Thread-Termination" class="headerlink" title="Process and Thread Termination"></a>Process and Thread Termination</h3><p>To eliminate deadlocks by aborting a process or thread, we use one of <em>two methods</em>. </p><ul><li>Abort all deadlocked processes.</li><li>Abort one process at a time until the deadlock cycle is eliminated. </li></ul><p>If the partial termination method is used, then we must determine which deadlocked process (or processes) should be terminated. (<em>minimum cost</em>)</p><ol><li>What the priority of the process is</li><li>How long the process has computed and how much longer the process will compute before completing its designated task</li><li>How many and what types of resources the process has used (for example, whether the resources are simple to preempt)</li><li>How many more resources the process needs in order to complete</li><li>How many processes will need to be terminated</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>过程管理</p><ul><li>并行性能<ul><li>Chapter3 IPC/cooperative</li><li>Chapter4 multi-threading</li><li>Chapter5 CPU scheduling</li></ul></li><li>安全可靠(Chapter6~8)<ul><li>Synchronization</li><li>Deadlock</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Operating system </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客文章分类与排序方法</title>
      <link href="/posts/3d9bb40a.html"/>
      <url>/posts/3d9bb40a.html</url>
      
        <content type="html"><![CDATA[<h2 id="本地文章分类"><a href="#本地文章分类" class="headerlink" title="本地文章分类"></a>本地文章分类</h2><p>如果文章太多全都放在 _posts 文件夹中会显得很乱，所以可以在 _posts 文件夹中建立子文件夹，将文章放入。这样操作不会影响文章在网站上的正常显示。</p><h2 id="网站文章排序"><a href="#网站文章排序" class="headerlink" title="网站文章排序"></a>网站文章排序</h2><h3 id="源文件修改"><a href="#源文件修改" class="headerlink" title="源文件修改"></a>源文件修改</h3><p>在博客目录中的 node_modules=&gt;hexo-generate-category=&gt;lib=&gt;generate.js 文件中，修改 <code>const orderBy</code> 为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> orderBy = config.<span class="property">category_generator</span>.<span class="property">order_by</span> || <span class="string">&#x27;-order&#x27;</span>;</span><br></pre></td></tr></table></figure></p><p>就可以手动指定 order 排序，<code>&#39;-order&#39;</code> 中的负号表示降序排序。</p><h3 id="文章标记"><a href="#文章标记" class="headerlink" title="文章标记"></a>文章标记</h3><p>在文章的 front-matter 出添加 <code>order:</code> 就行。如<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Chapter1-Introduction</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">Operating</span> <span class="string">system</span></span><br><span class="line"><span class="attr">abbrlink:</span> <span class="string">a733b7f0</span></span><br><span class="line"><span class="attr">order:</span> <span class="number">1</span> <span class="comment"># 手动指定文章顺序</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2023-03-14 14:21:12</span></span><br><span class="line"><span class="attr">tags:</span></span><br></pre></td></tr></table></figure></p><p>然后文章就会按照设置的方式排序。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IBUFGDS时钟缓冲器</title>
      <link href="/posts/b2b64be7.html"/>
      <url>/posts/b2b64be7.html</url>
      
        <content type="html"><![CDATA[<h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IBUFGDS IBUFGDS_ipist(</span><br><span class="line">    <span class="variable">.O</span>(CLK_i),</span><br><span class="line">    <span class="variable">.I</span>(clk_p),</span><br><span class="line">    <span class="variable">.IB</span>(clk_n)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这段代码定义了一个<code>IBUFGDS</code>实例，IBUFGDS是一种时钟缓冲器，用于将输入的差分时钟信号（即包含正极性时钟信号和负极性时钟信号）转换为单端时钟信号。IBUFGDS模块通常用于FPGA设计中，因为FPGA通常会采用差分时钟。</p><p>在这个实例中，<code>.I(clk_p)</code>和<code>.IB(clk_n)</code>分别连接输入的正极性和负极性时钟信号，<code>.O(CLK_i)</code>连接输出的单端时钟信号。因此，该实例将输入的差分时钟信号转换为单端时钟信号<code>CLK_i</code>，以供后续电路使用。</p><h2 id="单端时钟信号和差分时钟信号"><a href="#单端时钟信号和差分时钟信号" class="headerlink" title="单端时钟信号和差分时钟信号"></a>单端时钟信号和差分时钟信号</h2><p>单端时钟信号指只有一个信号线的时钟信号，这条信号线在每个时钟周期中会从低电平变为高电平或者从高电平变为低电平，来表示一个时钟周期的开始或结束。单端时钟信号常用于单片集成电路（IC）的设计。</p><p>差分时钟信号则是由一对信号线组成的，其中一根线为正极性时钟信号，另一根线为负极性时钟信号。在每个时钟周期中，正极性和负极性时钟信号都会交替地从低电平变为高电平，或者从高电平变为低电平，来表示一个时钟周期的开始或结束。差分时钟信号通常用于高速电路设计，例如芯片级设计和通信系统设计。</p><p>将差分时钟信号转换为单端时钟信号可以使用时钟缓冲器，例如上述提到的IBUFGDS模块。时钟缓冲器可以将两个相位相反的差分信号转换为单端时钟信号，并通过输出引脚将其传递给后续的逻辑电路。</p><h2 id="信号转化处理的原因"><a href="#信号转化处理的原因" class="headerlink" title="信号转化处理的原因"></a>信号转化处理的原因</h2><p>将差分时钟信号转换为单端时钟信号的主要原因是为了简化后续电路的设计和布局，以及提高电路的可靠性。</p><p>在FPGA或ASIC的设计中，为了使时钟信号传输更加稳定可靠，通常会采用差分时钟信号。差分时钟信号具有抗干扰性好、抗电磁辐射干扰能力强、传输距离远等优点，能够有效地提高电路的可靠性。然而，在后续电路中，由于大多数逻辑单元的输入都是单端信号，因此需要将差分时钟信号转换为单端信号，以便与其他单端信号进行逻辑运算和控制。此时，就需要通过时钟缓冲器将差分时钟信号转换为单端信号，使得后续电路能够正常工作。</p><p>除了简化设计和提高可靠性之外，将差分时钟信号转换为单端时钟信号还可以减少电路的成本和功耗。因为单端时钟信号只需要一条信号线，而差分时钟信号需要两条信号线，因此将差分时钟信号转换为单端时钟信号可以节省电路的线路资源，并降低功耗。</p>]]></content>
      
      
      
        <tags>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter2-Operating System Structures</title>
      <link href="/posts/e6abb60.html"/>
      <url>/posts/e6abb60.html</url>
      
        <content type="html"><![CDATA[<h2 id="Operating-System-Services"><a href="#Operating-System-Services" class="headerlink" title="Operating-System Services"></a>Operating-System Services</h2><ul><li><strong>User interface</strong>. graphical user interface (<strong><em>GUI</em></strong>), touch-screen interface, command-line interface (<strong><em>CLI</em></strong>)</li><li><strong>Program execution</strong></li><li><strong>I/O operations</strong></li><li><strong>File-system manipulation</strong></li><li><strong>Communications</strong></li><li><strong>Error detection</strong></li></ul><p>Another set of operating-system functions exists not for helping the user but rather for ensuring the efficient operation of the system itself. </p><ul><li><strong>Resource allocation</strong></li><li><strong>Logging</strong></li><li><strong>Protection and security</strong></li></ul><div align=center><img src="../../figure/operating-system/Chapter2-Operating%20System%20Structures/OS_services.png" width=600></div><h2 id="System-Calls"><a href="#System-Calls" class="headerlink" title="System Calls"></a>System Calls</h2><p><strong><em>System calls</em></strong> provide an <strong>interface</strong> to the services made available by an operating system. </p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Let’s first use an example to illustrate how system calls are used: <code>cp in.txt out.txt</code></p><div align=center><img src="../../figure/operating-system/chapter2/../Chapter2-Operating%20System%20Structures/example_sys_call.png" width=500></div><h3 id="Application-Programming-Interface"><a href="#Application-Programming-Interface" class="headerlink" title="Application Programming Interface"></a>Application Programming Interface</h3><p>Typically, application developers design programs according to an <strong><em>application programming interface (API)</em></strong> .A programmer accesses an API via a library of code provided by the operating system. </p><p>Behind the scenes, the functions that make up an API typically <strong>invoke the actual system calls</strong> on behalf of the application programmer. </p><p>Another important factor in handling system calls is the <strong><em>run-time environment (RTE)</em></strong> (a full suite of software).The RTE provides a <strong><em>system-call interface</em></strong> that intercepts function calls in the API and invokes the necessary system calls within the operating system.Typically, a <strong>number</strong> is associated with each system call, and the system-call interface maintains a <strong>table indexed</strong> according to these numbers.</p><div align=center><img src="../../figure/operating-system/Chapter2-Operating%20System%20Structures/API_sys_call.png" width=600></div><h2 id="Operating-System-Structure"><a href="#Operating-System-Structure" class="headerlink" title="Operating-System Structure"></a>Operating-System Structure</h2><h3 id="Monolithic-Structure"><a href="#Monolithic-Structure" class="headerlink" title="Monolithic Structure"></a>Monolithic Structure</h3><p>The simplest structure, placing all of the functionality of the kernel into a single, static binary file that runs in a single address space.</p><p>Example: original UNIX operating system, which consists of two separable parts: the <strong>kernel</strong> and the <strong>system programs</strong>.<br>The kernel is further separated into a series of interfaces and device drivers, which have been added and expanded over the years as UNIX has evolved. </p><div align=center><img src="../../figure/operating-system/Chapter2-Operating%20System%20Structures/traditional_UNIX_structure.png" width=500></div><h3 id="Layered-Approach"><a href="#Layered-Approach" class="headerlink" title="Layered Approach"></a>Layered Approach</h3><p><strong><em>tightly coupled system</em></strong>: changes to one part of the system can have wide-ranging effects on other parts.<br><strong><em>loosely coupled system</em></strong>: Such a system is divided into separate, smaller components that have specific and limited functionality. </p><p>The advantage of this <strong>modular approach</strong>: changes in one component affect only that component, and no others, allowing system implementers more freedom in creating and changing the inner workings of the system.</p><p>A system can be made modular in many ways. One method is the <strong><em>layered approach</em></strong>.</p><div align=center><img src="../../figure/operating-system/Chapter2-Operating%20System%20Structures/latyered_OS.png" width=350></div><p>Advantage: simplicity of construction and debugging.<br>Disadvantage: the overall performance of such systems is poor (due to the overhead of requiring a user program to traverse through multiple layers to obtain an operating-system service)</p><h3 id="Microkernels"><a href="#Microkernels" class="headerlink" title="Microkernels"></a>Microkernels</h3><p><strong><em>microkernel</em></strong> approach: structures the operating system by removing all nonessential components from the kernel and implementing them as user-level programs that reside in separate address spaces.(移除所有不必要的功能)</p><p>The main function of the microkernel is to provide <strong>communication</strong> between the <strong>client program</strong> and the various <strong>services</strong> that are also running in <strong>user space</strong>.</p><p>Advantage: </p><ul><li>it makes extending the operating system easier.( The resulting operating system is easier to port from one hardware design to another.)</li><li>provides more security and reliability.(most services are running as user—rather than kernel—processes.)</li></ul><p>Disadvantage:</p><ul><li>the performance of microkernels can suffer due to increased system-function overhead. </li></ul><h2 id="Building-and-Booting-an-Operating-System"><a href="#Building-and-Booting-an-Operating-System" class="headerlink" title="Building and Booting an Operating System"></a>Building and Booting an Operating System</h2><h3 id="System-Boot"><a href="#System-Boot" class="headerlink" title="System Boot"></a>System Boot</h3>]]></content>
      
      
      <categories>
          
          <category> Operating system </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>verilog语法简介</title>
      <link href="/posts/e03b3fd8.html"/>
      <url>/posts/e03b3fd8.html</url>
      
        <content type="html"><![CDATA[<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>Verilog语言的一个特点为模块化，一般一个<code>.v</code>文件为一个模块。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flowing_light.v</span></span><br><span class="line"><span class="keyword">module</span> flowing_light(</span><br><span class="line">    <span class="keyword">input</span> clock,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] led</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">23</span>:<span class="number">0</span>] cnt_reg;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] light_reg;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clock) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (reset)</span><br><span class="line">            cnt_reg&lt;=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt_reg==<span class="number">24&#x27;h000001</span>)</span><br><span class="line">            cnt_reg&lt;=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt_reg&lt;=cnt_reg+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clock) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(reset)</span><br><span class="line">            light_reg&lt;=<span class="number">8&#x27;h01</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt_reg==<span class="number">24&#x27;h000001</span>)<span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(light_reg==<span class="number">8&#x27;h80</span>)</span><br><span class="line">                light_reg&lt;=<span class="number">8&#x27;h01</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                light_reg&lt;=light_reg&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> led=light_reg;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flowing_light_tb.v</span></span><br><span class="line"><span class="keyword">module</span> flowing_light_tb(</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"><span class="keyword">reg</span> clock;</span><br><span class="line"><span class="keyword">reg</span> reset;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] led;</span><br><span class="line"></span><br><span class="line">flowing_light u0(</span><br><span class="line">    <span class="variable">.clock</span>(clock),</span><br><span class="line">    <span class="variable">.reset</span>(reset),</span><br><span class="line">    <span class="variable">.led</span>(led)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> PERIOD = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> <span class="variable">#(PERIOD*2)</span> clock=!clock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clock=<span class="number">1&#x27;b0</span>;</span><br><span class="line">    reset=<span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="variable">#(PERIOD*2)</span>reset=<span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="variable">#(PERIOD*4)</span>reset=<span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="模块端口设置"><a href="#模块端口设置" class="headerlink" title="模块端口设置"></a>模块端口设置</h2><p>模块化的特点是将系统抽象成输入和输出的模型。端口定义了输入和输出。<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> flowing_light(</span><br><span class="line">    <span class="keyword">input</span> clock,</span><br><span class="line">    <span class="keyword">input</span> reset,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] led <span class="comment">//定义了一个8位宽的端口</span></span><br><span class="line">    );</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><br>上述代码的括号内部分定义了该模块的输入和输出。端口的设置格式为 <code>&lt;类型&gt;[端口位宽]&lt;端口名称&gt;</code>。各个端口的定义语句之间由逗号隔开，括号后面加分号。</p><h2 id="Verilog语句块"><a href="#Verilog语句块" class="headerlink" title="Verilog语句块"></a>Verilog语句块</h2><h3 id="always语句块"><a href="#always语句块" class="headerlink" title="always语句块"></a>always语句块</h3><p>相当于 <code>while</code> ,<code>@()</code> 内是循环条件。<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (reset)</span><br><span class="line">        cnt_reg&lt;=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt_reg==<span class="number">24&#x27;h000001</span>)</span><br><span class="line">        cnt_reg&lt;=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt_reg&lt;=cnt_reg+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>这段代码中 <code>posedge</code> 指的是时钟上升沿；如果想要时钟下降沿，可以使用 <code>negedge</code>；如果对于一个时钟，既不加 <code>posedge</code> 也不加 <code>negedge</code>，则上升下降沿都能触发。比如说这段代码：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(OpCode) <span class="keyword">begin</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>当 <code>OpCode</code> 发生变化的时候就能触发。</p><p>代码中的 <code>begin</code> 和 <code>end</code> 相当于C语言中的大括号。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> <span class="variable">#(PERIOD*2)</span> clock=!clock;</span><br></pre></td></tr></table></figure><p>则表示每经过 <code>PERIOD*2</code> 的时间，<code>clok</code> 翻转一次。时间的单位也在.v文件中写出，如<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br></pre></td></tr></table></figure><br>则表示时间的单位为1ns，分辨率为1ps。</p><h3 id="initial语句块"><a href="#initial语句块" class="headerlink" title="initial语句块"></a>initial语句块</h3><p>initial语句在程序的最开始执行，且仅执行一次。在执行initial时，always不会执行。<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    a=<span class="number">0</span>;</span><br><span class="line">    b=<span class="number">0</span>;</span><br><span class="line">    ci=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    #<span class="number">100</span>;</span><br><span class="line">    a = <span class="number">4&#x27;b0001</span>;</span><br><span class="line">    b = <span class="number">4&#x27;b0010</span>;</span><br><span class="line"></span><br><span class="line">    #<span class="number">100</span>;</span><br><span class="line">    a = <span class="number">4&#x27;b0010</span>;</span><br><span class="line">    b = <span class="number">4&#x27;b0100</span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>如这里的initial语句的例子，就表示先设置 <code>a,b,ci</code> 的值，然后过100个时钟周期再设置 <code>a,b</code> 的值，再过100个时钟周期再设置……</p><h3 id="case和casex语句块"><a href="#case和casex语句块" class="headerlink" title="case和casex语句块"></a>case和casex语句块</h3><p><code>case</code> 语法大致如下，和C语言中的switch类似：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> (OpCode)</span><br><span class="line">    <span class="number">6&#x27;b000000</span>: <span class="keyword">begin</span> <span class="comment">// R type</span></span><br><span class="line">        RegDst=<span class="number">1</span>;</span><br><span class="line">        ALUSrc=<span class="number">0</span>;</span><br><span class="line">        MemtoReg=<span class="number">0</span>;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="number">6&#x27;b100011</span>: <span class="keyword">begin</span> <span class="comment">// lw</span></span><br><span class="line">        ... </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="number">6&#x27;b101011</span>: <span class="keyword">begin</span> <span class="comment">// sw</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">begin</span> <span class="comment">// invalid opcode</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure></p><p><code>casex</code> 与 <code>case</code> 的区别在于，<code>case</code> 语句是精确匹配输入信号值的，如果输入信号与 <code>case</code> 语句中的任何一个值不匹配，则不会执行任何语句。而 <code>casex</code> 语句则是按位通配符匹配输入信号值的。它允许使用 <code>x</code>（表示未知值）、<code>z</code>（表示高阻值）和 <code>*</code>（表示通配符）等特殊字符，从而可以匹配更多的输入信号模式。</p><p>感觉ChatGPT说的地方好像有点问题，待会再看看语法书。</p><h2 id="Verilog数据类型"><a href="#Verilog数据类型" class="headerlink" title="Verilog数据类型"></a>Verilog数据类型</h2><h3 id="寄存器-register-类型"><a href="#寄存器-register-类型" class="headerlink" title="寄存器(register)类型"></a>寄存器(register)类型</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">23</span>:<span class="number">0</span>] cnt_reg;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] light_reg;</span><br></pre></td></tr></table></figure><p>就是寄存器类型，表示抽象的数据存储单元。除了 <code>reg</code>，还可以使用 <code>integer,real</code> 进行声明。上方的例子定义了24位的 <code>cnt_reg</code> 和8位的 <code>light_reg</code>。寄存器类型可以初始化。</p><h3 id="线网-net-类型"><a href="#线网-net-类型" class="headerlink" title="线网(net)类型"></a>线网(net)类型</h3><p>如<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] led;</span><br></pre></td></tr></table></figure><br>定义了一个8位的 <code>wire</code> 类型。在电路图中wire作用相当于导线。除了 <code>wire</code>，还可以使用 <code>tri</code>,<code>wand</code> 来定义线网类型。</p><h3 id="参数数据类型"><a href="#参数数据类型" class="headerlink" title="参数数据类型"></a>参数数据类型</h3><p>参数类型就相当于常量常量，如<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> PERIOD = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><br>就定义了一个值为10的常量 <code>PERIOD</code>。</p><h3 id="数字格式"><a href="#数字格式" class="headerlink" title="数字格式"></a>数字格式</h3><p>如 <code>24&#39;h000001</code>，第一个数字表示数字在二进制下的位数，<code>&#39;</code> 用于分隔，<code>h</code> 表示后面的数字用16进制表示（<code>b</code>表示二进制,<code>d</code>表示十进制）。同时为方便阅读，后面的数字之间可以加下划线而不影响结果，如该数字还可以写成 <code>24&#39;h00_00_01</code></p><h2 id="模块间引用"><a href="#模块间引用" class="headerlink" title="模块间引用"></a>模块间引用</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> flowing_light_tb(</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">reg</span> clock;</span><br><span class="line"><span class="keyword">reg</span> reset;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] led;</span><br><span class="line"></span><br><span class="line">flowing_light u0(</span><br><span class="line">    <span class="variable">.clock</span>(clock),</span><br><span class="line">    <span class="variable">.reset</span>(reset),</span><br><span class="line">    <span class="variable">.led</span>(led)</span><br><span class="line">);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>这里展示了 <code>flowing_light_tb</code> 模块引用 <code>flowing_light</code> 模块的方式。比如 <code>.clock(clock)</code> 中的 <code>.clock</code> 表示要使用 <code>flowing_light</code> 中 <code>clock</code> 的端口；而括号中 <code>clock</code> 则表示将 <code>flowing_light_tb</code> 中的寄存器变量 <code>clock</code> 接上。</p><div align=center><img src="../../figure/verilog语法简介/input_and_output.png" width=600></div><p>同一个模块可以被多次引用，但是每次实例化的名字要不同<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adder_1bit  a1(<span class="variable">.a</span>(a[<span class="number">0</span>]),<span class="variable">.b</span>(b[<span class="number">0</span>]),<span class="variable">.ci</span>(ci),<span class="variable">.s</span>(s[<span class="number">0</span>]),<span class="variable">.co</span>(ct[<span class="number">0</span>])),</span><br><span class="line">            a2(<span class="variable">.a</span>(a[<span class="number">1</span>]),<span class="variable">.b</span>(b[<span class="number">1</span>]),<span class="variable">.ci</span>(ct[<span class="number">0</span>]),<span class="variable">.s</span>(s[<span class="number">1</span>]),<span class="variable">.co</span>(ct[<span class="number">1</span>])),</span><br><span class="line">            a3(<span class="variable">.a</span>(a[<span class="number">2</span>]),<span class="variable">.b</span>(b[<span class="number">2</span>]),<span class="variable">.ci</span>(ct[<span class="number">1</span>]),<span class="variable">.s</span>(s[<span class="number">2</span>]),<span class="variable">.co</span>(ct[<span class="number">2</span>])),</span><br><span class="line">            a4(<span class="variable">.a</span>(a[<span class="number">3</span>]),<span class="variable">.b</span>(b[<span class="number">3</span>]),<span class="variable">.ci</span>(ct[<span class="number">2</span>]),<span class="variable">.s</span>(s[<span class="number">3</span>]),<span class="variable">.co</span>(co));</span><br></pre></td></tr></table></figure><br>如这段代码就将adder_1bit用了4次，每次实例化的给的名称分别为 <code>a1,a2,a3,a4</code>。（这里类似于cpp中创建了一个类，然后在另一个类中使用这个类）</p>]]></content>
      
      
      
        <tags>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用vivado</title>
      <link href="/posts/c8f9a135.html"/>
      <url>/posts/c8f9a135.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建project"><a href="#创建project" class="headerlink" title="创建project"></a>创建project</h2><p>确定项目地址与名称：路径中不能出现中文，空格也应当避免<br><img src="../../figure/使用vivado/project_name.png" alt=""></p><p>选择项目类型：<br>RTL Project 能自主编辑source，创建、修改IP，支持各种功能。<br><img src="../../figure/使用vivado/project_type.png" alt=""></p><p>选择板子型号（应该是）：<br><img src="../../figure/使用vivado/default_part.png" alt=""><br>从图中看出，可以选择Family,Package(应该指的是型号的一个归类方式),Speed。最后在下面方框中可以选择具体型号(Part)。</p><h2 id="页面概览"><a href="#页面概览" class="headerlink" title="页面概览"></a>页面概览</h2><ol><li>左侧区 Flow Navigator 包含整个开发流程，像 Project Settings、Run Simulation、Run Synthesized 和 Generate Bitstream 等；</li><li>中间区 通常显示当前工程包含的文件树结构，提供工程文件的管理；</li><li>右侧区 会显示工程信息、打开的编辑文件等；</li><li>下部区 显示各种信息状态。</li></ol><p><img src="../../figure/使用vivado/overall_view.png" alt=""></p><h2 id="添加源文件"><a href="#添加源文件" class="headerlink" title="添加源文件"></a>添加源文件</h2><p>可以在左侧 Flow Navigator-&gt;PROJECT MANAGER-&gt;Add Scource处或者在中间的Sources下按“+”号。<br><img src="../../figure/使用vivado/add_source_file.png" alt=""><br>然后可以选择添加文件的类型<br><img src="../../figure/使用vivado/add_source_cat.png" alt=""></p><ul><li>constraints应该是管脚约束文件</li><li>design source文件就是写Verilog的地方</li><li>simulation source也是创建.v文件，但这个应该还与run simulation有关</li></ul><p><img src="../../figure/使用vivado/add_source_choice.png" alt=""><br>然后可以选择从其他地方添加文件、文件夹，或者直接新建文件。</p><h2 id="代码编辑"><a href="#代码编辑" class="headerlink" title="代码编辑"></a>代码编辑</h2><p>双击左侧的source中的文件，就能在右侧的编辑器中打开文件。<br><img src="../../figure/使用vivado/code_edit.png" alt=""><br>同时这些生成的文件路径就在项目文件夹的.srcs文件夹中。可以用其他文本编辑器打开文件进行编辑，保存后在vivado中也会显示。<br><img src="../../figure/使用vivado/file_path.png" alt=""></p><h2 id="代码仿真-Simulation"><a href="#代码仿真-Simulation" class="headerlink" title="代码仿真(Simulation)"></a>代码仿真(Simulation)</h2><p>点击SIMUALTION-&gt;Run Simulation-&gt;Behavioral Simulation就可以展示图右图simulation的窗口。<br><img src="../../figure/使用vivado/run_simulation.png" alt=""></p><h2 id="添加管脚约束文件"><a href="#添加管脚约束文件" class="headerlink" title="添加管脚约束文件"></a>添加管脚约束文件</h2><h3 id="通过图形化界面添加"><a href="#通过图形化界面添加" class="headerlink" title="通过图形化界面添加"></a>通过图形化界面添加</h3><p>点击左侧Flow Navigator-&gt;SYNTHESIS-&gt;Run Synthesis</p><p>Synthesis完成后出现如图界面，选择Open Synthesis Design.<br><img src="../../figure/使用vivado/synthesis_completed.png" alt=""></p><p>完成后在右上角选择I/O Planning，下方会出现如图管脚信息。然后选择Package Pin和I/O Std完成设置。点击保存，即可保存管脚信息。<br><img src="../../figure/使用vivado/IO_prots_gui.png" alt=""></p><h3 id="通过代码添加"><a href="#通过代码添加" class="headerlink" title="通过代码添加"></a>通过代码添加</h3><p>和添加源文件的方式相同，选择create constraints就行。然后新建的.xdc文件同样可以用文本编辑器进行编辑。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vivado </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>operating-system/Chapter1-Introduction</title>
      <link href="/posts/a733b7f0.html"/>
      <url>/posts/a733b7f0.html</url>
      
        <content type="html"><![CDATA[<h2 id="What-Operating-Systems-Do"><a href="#What-Operating-Systems-Do" class="headerlink" title="What Operating Systems Do"></a>What Operating Systems Do</h2><h3 id="User-View"><a href="#User-View" class="headerlink" title="User View"></a>User View</h3><p>The user’s view of the computer varies according to the interface being used.</p><ul><li>a laptop or in front of a PC consisting of a monitor, keyboard, and mouse.</li><li>mobile devices with touch screen or voice recognition.</li><li>emmbedded computers have little or no user view.</li></ul><h3 id="System-View"><a href="#System-View" class="headerlink" title="System View"></a>System View</h3><ul><li><strong>resource allocator</strong>: Facing numerous and possibly conflicting requests for resources, the operating system must decide how to allocate them to specific programs and users</li><li><strong>control program</strong>: manages the execution of user programs to prevent errors and improper use of the computer.</li></ul><h3 id="Defining-Operating-Systems"><a href="#Defining-Operating-Systems" class="headerlink" title="Defining Operating Systems"></a>Defining Operating Systems</h3><p>In summary, the operating system includes:</p><ul><li>the always running kernel</li><li>middleware frameworks that ease application development and provide features</li><li>system programs that aid in managing the system while it is running</li></ul><h2 id="Computer-System-Organization"><a href="#Computer-System-Organization" class="headerlink" title="Computer-System Organization"></a>Computer-System Organization</h2><h3 id="Interrupts"><a href="#Interrupts" class="headerlink" title="Interrupts"></a>Interrupts</h3><p>To handle the program performing I/O.</p><p>The basic interrupt mechanism works as follows.</p><ol><li><strong><em>interrupt-request</em></strong> line: the CPU senses after executing every instruction.(检测信号)</li><li>CPU detects that a controller has asserted a signal on the interrupt-request line(检测到信号)</li><li>reads the interrupt number and jumps to the <strong><em>interrupt-handler routine</em></strong> by using that interrupt number as an index into the interrupt vector.(跳转到中断指令处)</li><li>starts execution at the address associated with that index.(执行中断处理命令)</li><li>interrupt handler saves any state it will be changing during its operation…,executes a <code>return_from_interrupt</code> instruction to return the CPU to the execution state prior to the interrupt.(回到正常执行状态)</li></ol><div align=center><img src="../../figure/operating-system/Chapter1-Introduction/interrupt_IO_cycle.png" width=600></div><p>We say that the device controller <strong>raises</strong> an interrupt by asserting a signal on the interrupt request line, the CPU <strong>catches</strong> the interrupt and <strong>dispatches</strong> it to the interrupt handler, and the handler <strong>clears</strong> the interrupt by servicing the device.</p><p><em>In summary</em>, </p><ul><li>interrupts are used throughout modern operating systems to handle asynchronous events. </li><li>Device controllers and hardware faults raise interrupts.</li><li>To enable the most urgent work to be done first, modern computers use a system of interrupt priorities. </li></ul><h3 id="Storage-Structure"><a href="#Storage-Structure" class="headerlink" title="Storage Structure"></a>Storage Structure</h3><p>General-purpose computers run most of their programs from rewritable memory, called </p><ul><li>main memory(<strong><em>random-access memory</em></strong>, or <strong><em>RAM</em></strong>).</li><li>commonly <strong><em>dynamic random-access memory</em></strong>: <strong><em>(DRAM)</em></strong></li><li>RAM is <strong><em>volatile—loses</em></strong> its content when power is turned off or otherwise lost</li></ul><p>To store the <strong><em>bootstrap program</em></strong>,the computer uses: </p><ul><li>electrically <strong><em>erasable programmable read-only memory</em></strong> (<strong><em>EEPROM</em></strong>) and other forms of <strong><em>firmwar</em></strong> </li><li>storage that is infrequently written to and is nonvolatile.</li><li>In addition, it is low speed, and so it contains mostly static programs and data that aren’t frequently used.</li></ul><p>Most computer systems provide <strong><em>secondary storage</em></strong> as an extension of main memory. </p><ul><li>most common secondary-storage devices are <strong><em>hard-disk drives (HDDs)</em></strong> and <strong><em>nonvolatile memory (NVM)</em></strong> devices</li></ul><div align=center><img src="../../figure/operating-system/Chapter1-Introduction/storage_hierarchy.png" width=700></div><p>In general, we will use the following terminology:</p><ul><li><strong>Volatile storage</strong> will be referred to simply as <strong>memory</strong>. If we need to emphasize a particular type of storage device (for example, a register),we will do so explicitly.</li><li>Nonvolatile storage retains its contents when power is lost. It will be referred to as <strong><em>NVS</em></strong>. The vast majority of the time we spend on NVS will be on <strong>secondary storage</strong>. This type of storage can be classified into <strong>two distinct types</strong>:<ul><li><strong>Mechanical</strong>. A few examples of such storage systems are HDDs, optical disks, holographic storage, and magnetic tape. </li><li>Electrical. A few examples of such storage systems are flash memory, FRAM, NRAM, and SSD. Electrical storage will be referred to as <strong>NVM</strong>.</li></ul></li></ul><h3 id="I-O-Structure"><a href="#I-O-Structure" class="headerlink" title="I/O Structure"></a>I/O Structure</h3><p>It can produce high overhead when CPU used for bulk data movement such as NVS I/O. To solve this problem, <strong><em>direct memory access (DMA)</em></strong> is used.</p><p>device controller transfers an entire block of data directly to or from the device and main memory, with no intervention by the CPU</p><div align=center><img src="../../figure/operating-system/Chapter1-Introduction/DMA.png" width=500></div>]]></content>
      
      
      <categories>
          
          <category> Operating system </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter7-Synchronization Examples</title>
      <link href="/posts/fe04cff6.html"/>
      <url>/posts/fe04cff6.html</url>
      
        <content type="html"><![CDATA[<h2 id="Classic-Problems-of-Synchronization"><a href="#Classic-Problems-of-Synchronization" class="headerlink" title="Classic Problems of Synchronization"></a>Classic Problems of Synchronization</h2><h3 id="The-Bounded-Buffer-Problem"><a href="#The-Bounded-Buffer-Problem" class="headerlink" title="The Bounded-Buffer Problem"></a>The Bounded-Buffer Problem</h3><p>In our problem, the producer and consumer processes share the following data structures:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 用于保证互斥</span></span><br><span class="line">semaphore empty = n; <span class="comment">// 防空转（buffer中没有内容，但是消费者依然要消费）</span></span><br><span class="line">semaphore full = <span class="number">0</span>; <span class="comment">// 防溢出</span></span><br></pre></td></tr></table></figure></p><p>The structure of the producer process.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        . . .</span><br><span class="line">    <span class="comment">/* produce an item in next produced */</span></span><br><span class="line">        . . .</span><br><span class="line">    wait(empty);</span><br><span class="line">    wait(mutex);</span><br><span class="line">        . . .   </span><br><span class="line">    <span class="comment">/* add next produced to the buffer */</span></span><br><span class="line">        . . .</span><br><span class="line">    signal(mutex);</span><br><span class="line">    signal(full); <span class="comment">// signal to comsumer there has resource to comsume</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>The structure of the consumer process.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        . . .</span><br><span class="line">    <span class="comment">/* produce an item in next produced */</span></span><br><span class="line">        . . .</span><br><span class="line">    wait(full);</span><br><span class="line">    wait(mutex);</span><br><span class="line">        . . .   </span><br><span class="line">    <span class="comment">/* add next produced to the buffer */</span></span><br><span class="line">        . . .</span><br><span class="line">    signal(mutex);</span><br><span class="line">    signal(empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="The-Readers–Writers-Problem"><a href="#The-Readers–Writers-Problem" class="headerlink" title="The Readers–Writers Problem"></a>The Readers–Writers Problem</h3><p>readers and writers are not symmetric (read操作可以同时进行，但是write不行)<br>Obviously, if two readers access the shared data simultaneously, no adverse effects will result. However, if a writer and some other process (either a reader or a writer) access the database simultaneously, chaos may ensue.</p><p>In the solution to the first readers–writers problem, the reader processes share the following data structures:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw_mutex = <span class="number">1</span>; <span class="comment">// mutex for read and write</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// mutex for read_count</span></span><br><span class="line"><span class="type">int</span> read_count = <span class="number">0</span>; <span class="comment">// the number of reader</span></span><br></pre></td></tr></table></figure></p><p>The structure of a writer process.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    wait(rw_mutex);</span><br><span class="line">        . . .</span><br><span class="line">    <span class="comment">/* writing is performed */</span></span><br><span class="line">        . . .</span><br><span class="line">    signal(rw_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>The structure of a reader process.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    wait(mutex); <span class="comment">// avoid violation between readers when excuting read_count++</span></span><br><span class="line">    read_count++;</span><br><span class="line">    <span class="keyword">if</span> (read_count == <span class="number">1</span>) <span class="comment">// only the first reader should consider the rw_mutex</span></span><br><span class="line">        wait(rw_mutex);</span><br><span class="line">    signal(mutex);</span><br><span class="line">        . . .</span><br><span class="line">    <span class="comment">/* reading is performed */</span></span><br><span class="line">        . . .</span><br><span class="line">    wait(mutex);</span><br><span class="line">    read_count--;</span><br><span class="line">    <span class="keyword">if</span> (read_count == <span class="number">0</span>) <span class="comment">// unclock when no reader left</span></span><br><span class="line">        signal(rw_mutex);</span><br><span class="line">    signal(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另一种处理readers—writers problem的方法：read copy update（RCU）<br>把数据复制多份，就不会产生冲突</p><h3 id="The-Dining-Philosophers-Problem"><a href="#The-Dining-Philosophers-Problem" class="headerlink" title="The Dining-Philosophers Problem"></a>The Dining-Philosophers Problem</h3><h4 id="Semaphore-Solution"><a href="#Semaphore-Solution" class="headerlink" title="Semaphore Solution"></a>Semaphore Solution</h4><p>One simple solution is to represent each chopstick with a semaphore. <code>semaphore chopstick[5];</code> are set as shared data, where all the elements of <code>chopstick</code> are initialized to 1.</p><p>The structure of philosopher i:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    wait(chopstick[i]);</span><br><span class="line">    wait(chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    . . .</span><br><span class="line">    <span class="comment">/* eat for a while */</span></span><br><span class="line">    . . .</span><br><span class="line">    signal(chopstick[i]);</span><br><span class="line">    signal(chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    . . .</span><br><span class="line">    <span class="comment">/* think for a while */</span></span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>The solution could create a deadlock. When each philosopher tries to grab her right chopstick, she will be delayed forever.</p><h4 id="Monitor-Solution"><a href="#Monitor-Solution" class="headerlink" title="Monitor Solution"></a>Monitor Solution</h4><p>This solution imposes the restriction that a philosopher may pick up her chopsticks only if <em>both of them are available</em>. To code this solution, we need to distinguish among three states: <code>enum &#123;THINKING, HUNGRY, EATING&#125; state[5];</code></p><p>We also need to declare <code>condition self[5]</code>. This allows philosopher i to <em>delay herself</em> when she is hungry but is unable to obtain the chopsticks she needs.</p><p>The distribution of the chopsticks is controlled by the <strong>monitor</strong> <code>DiningPhilosophers</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">monitor DiningPhilosophers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>THINKING, HUNGRY, EATING&#125; state[<span class="number">5</span>];</span><br><span class="line">    condition self[<span class="number">5</span>];</span><br><span class="line">    <span class="type">void</span> <span class="title function_">pickup</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        state[i] = HUNGRY;</span><br><span class="line">        test(i);</span><br><span class="line">        <span class="keyword">if</span> (state[i] != EATING)</span><br><span class="line">            self[i].wait(); <span class="comment">// 说明旁边有人在吃饭，所以要 suspend,直到旁边的人吃完调用 test(i)，再尝试 EATING。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">putdown</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        state[i] = THINKING;</span><br><span class="line">        test((i + <span class="number">4</span>) % <span class="number">5</span>);</span><br><span class="line">        test((i + <span class="number">1</span>) % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((state[(i + <span class="number">4</span>) % <span class="number">5</span>] != EATING) &amp;&amp;(state[i] == HUNGRY) &amp;&amp;(state[(i + <span class="number">1</span>) % <span class="number">5</span>] != EATING)) &#123;</span><br><span class="line">            state[i] = EATING;</span><br><span class="line">            self[i].signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    initialization <span class="title function_">code</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            state[i] = THINKING;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Each philosopher, before starting to eat, must invoke the operation <code>pickup()</code>. This act may result in the <strong>suspension</strong> of the philosopher process. The whole process:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DiningPhilosophers.pickup(i);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* eat */</span></span><br><span class="line">    ...</span><br><span class="line">DiningPhilosophers.putdown(i);</span><br></pre></td></tr></table></figure></p><h2 id="Synchronization-within-the-Kernel"><a href="#Synchronization-within-the-Kernel" class="headerlink" title="Synchronization within the Kernel"></a>Synchronization within the Kernel</h2><h3 id="Synchronization-in-Windows"><a href="#Synchronization-in-Windows" class="headerlink" title="Synchronization in Windows"></a>Synchronization in Windows</h3><p>When the Windows kernel accesses a global resource</p><ul><li>on a single-processor system: it temporarily <em>masks interrupts</em> for all interrupt handlers that may also access the global resource.</li><li>On a multiprocessor system: <em>spinlock</em> (Furthermore, for reasons of efficiency, the kernel ensures that a thread will never be preempted while holding a spinlock.)</li></ul><p>For thread synchronization outside the kernel, Windows provides <strong><em>dispatcher objects</em></strong>. Using a dispatcher object, threads synchronize according to several different mechanisms, including <strong>mutex locks</strong>, <strong>semaphores</strong>, <strong>events</strong>, and <strong>timers</strong>. </p><!--TODO 还有一点没看 --><h3 id="Synchronization-in-Linux"><a href="#Synchronization-in-Linux" class="headerlink" title="Synchronization in Linux"></a>Synchronization in Linux</h3><p>The <em>simplest</em> synchronization technique within the Linux kernel is an atomic integer, which is represented using the opaque data type <code>atomic_t</code>.<br>To illustrate, consider a program that consists of an atomic integer counter and an integer value.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_t</span> counter;</span><br><span class="line"><span class="type">int</span> value;</span><br></pre></td></tr></table></figure></p><p>The following code illustrates the effect of performing various atomic operations:</p><div align=center><img src="../../figure/operating-system/Chapter7-Synchronization-Examples/atomic_operation.png" width=600></div><p>Atomic integers are particularly <em>efficient</em> in situations where an integer variable—such as a counter—needs to be updated, since atomic operations <strong>do not require the overhead of locking mechanisms</strong>. However, their use is limited to these sorts of scenarios.</p><p>Mutex locks are available in Linux for protecting critical sections within the kernel.</p><p>Linux also provides spinlocks and semaphores (as well as reader–writer versions of these two locks) for locking in the kernel.</p><p>Spinlocks—along with enabling and disabling kernel preemption—are used in the kernel only when a lock (or disabling kernel preemption) is held for a <strong>short duration</strong>. When a lock must be held for a longer period, semaphores or mutex locks are appropriate for use.</p><h2 id="POSIX-Synchronization"><a href="#POSIX-Synchronization" class="headerlink" title="POSIX Synchronization"></a>POSIX Synchronization</h2><h3 id="POSIX-Mutex-Locks"><a href="#POSIX-Mutex-Locks" class="headerlink" title="POSIX Mutex Locks"></a>POSIX Mutex Locks</h3><p>Mutex locks represent the fundamental synchronization technique used with Pthreads.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* create and initialize the mutex lock */</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/* acquire the mutex lock */</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* critical section */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* release the mutex lock */</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure></p><h3 id="POSIX-Semaphores"><a href="#POSIX-Semaphores" class="headerlink" title="POSIX Semaphores"></a>POSIX Semaphores</h3><p>POSIX specifies two types of semaphores—<strong>named</strong> and <strong>unnamed</strong>.</p><h4 id="POSIX-Named-Semaphores"><a href="#POSIX-Named-Semaphores" class="headerlink" title="POSIX Named Semaphores"></a>POSIX Named Semaphores</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> *sem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create the semaphore and initialize it to 1 */</span></span><br><span class="line">sem = sem_open(<span class="string">&quot;SEM&quot;</span>, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>In this instance, we are naming the semaphore <code>SEM</code>. </p><ul><li>The <code>O_CREAT</code> flag indicates that the semaphore will be created if it does not already exist. </li><li>Additionally, the semaphore has read and write access for <strong>other processes</strong> (via the parameter 0666) </li><li>and is initialized to 1.</li></ul><p>Advantage: multiple unrelated processes can easily use a common semaphore as a synchronization mechanism by simply referring to the semaphore’s name. (In the example above, once the semaphore SEM has been created, subsequent calls to <code>sem_open()</code> with the <strong>same parameters</strong> by <strong>other processes</strong> return a descriptor to the existing semaphore.)</p>]]></content>
      
      
      <categories>
          
          <category> Operating system </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter6-Synchronization tools</title>
      <link href="/posts/7b7788cf.html"/>
      <url>/posts/7b7788cf.html</url>
      
        <content type="html"><![CDATA[<p>A <strong><em>cooperating process</em></strong> is one that can affect or be affected by other processes executing in the system. Cooperating processes can either directly share a logical address space (that is, both code and data) or be allowed to share data only through shared memory or message passing.(就是有些程序并行的时候会相互影响，感觉有点像data hazard?)</p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>We illustrated this model with the producer–consumer problem</p><p>The code for the producer process can be modified as follows:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">/* produce an item in next produced */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count == BUFFER_SIZE)</span><br><span class="line">        ; <span class="comment">/* do nothing */</span></span><br><span class="line"></span><br><span class="line">    buffer[in] = next_produced;</span><br><span class="line">    in = (in + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>The code for the consumer process can be modified as follows:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        ; <span class="comment">/* do nothing */</span></span><br><span class="line"></span><br><span class="line">    next_consumed = buffer[out];</span><br><span class="line">    out = (out + <span class="number">1</span>) % BUFFER SIZE;</span><br><span class="line">    count--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consume the item in next consumed */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div align=center><img src="../../figure/operating-system/Chapter6-Synchronization_tools/producer_consumer_problem.png" width=500></div><p>Note that the statement <code>count++</code> may be implemented in machine language (on a typical machine) as follows:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">register1 = count</span><br><span class="line">register1 = register1 + 1</span><br><span class="line">count = register1</span><br></pre></td></tr></table></figure><br>Similarly, the statement <code>count--</code> is implemented as follows:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">register2 = count</span><br><span class="line">register2 = register2 − 1</span><br><span class="line">count = register2</span><br></pre></td></tr></table></figure><br>The concurrent execution of “count++” and “count—” is equivalent to a sequential execution in which the lower-level statements presented previously are interleaved in some arbitrary order. One such interleaving is the following:</p><div align=center><img src="../../figure/operating-system/Chapter6-Synchronization_tools/interleaved_code.png" width=500></div><p><strong><em>race condition</em></strong>(竞态):several processes access and manipulate the same data concurrently and the outcome of the execution depends on the particular order in which the access takes place.</p><p>总的来说，就是两段并行代码同时访问同一段内存，所以出bug了。</p><p>Because of the importance of this issue, we devote a major portion of this chapter to <strong>process synchronization</strong> and coordination among cooperating processes.</p><h2 id="The-Critical-Section-Problem"><a href="#The-Critical-Section-Problem" class="headerlink" title="The Critical-Section Problem"></a>The Critical-Section Problem</h2><p>Consider a system consisting of n processes {P0, P1, …, Pn−1}. Each process has a segment of code, called a <strong><em>critical section</em></strong>(临界区), in which the process may be accessing — and updating — data that is shared with at least one other process. </p><div align=center><img src="../../figure/operating-system/Chapter6-Synchronization_tools/critical-section.png" width=300></div><p>The general structure of a typical process：</p><div align=center><img src="../../figure/operating-system/Chapter6-Synchronization_tools/general_stracture_of_typical_process.png" width=500></div><p>A solution to the critical-section problem must satisfy the following three requirements:</p><ol><li><strong>Mutual exclusion</strong>. If process Pi is executing in its critical section, then no other processes can be executing in their critical sections.</li><li><strong>Progress</strong>. decide which will enter its critical section next, and this selection cannot be postponed indefinitely.(决定下一个执行critical section的程序)</li><li><strong>Bounded waiting</strong>. There exists a bound, or limit, on the number of times that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted.(有限等待，防止 starving)</li></ol><p>Another example:<br>In this example, there is a race condition on the variable kernel variable <code>next_available_pid</code>which represents the value of the next available process identifier. Unless mutual exclusion is provided, it is possible the same process identifier number could be assigned to two separate processes.</p><div align=center><img src="../../figure/operating-system/Chapter6-Synchronization_tools/race_condition-pid.png" width=500></div><p>Two approaches depending on if kernel is preemptive or non-preemptive</p><ul><li>Preemptive – allows preemption of process when running in kernel mode</li><li>Non-preemptive – runs until exits kernel mode, blocks, or voluntarily yields CPU<ul><li>Essentially free of race conditions in kernel mode, as only one process is active in the kernel at a time.</li></ul></li></ul><p>A preemptive kernel may be more responsive. Furthermore, a preemptive kernel is more suitable for real-time programming.</p><h2 id="Peterson’s-Solution"><a href="#Peterson’s-Solution" class="headerlink" title="Peterson’s Solution"></a>Peterson’s Solution</h2><h3 id="Assumption"><a href="#Assumption" class="headerlink" title="Assumption"></a>Assumption</h3><ul><li>Peterson’s solution is restricted to two processes that alternate execution between their critical sections and remainder sections.(两个进程)</li><li>Assume that the load and store machine-language instructions are atomic; that is, cannot be interrupted.</li><li>Peterson’s solution requires the two processes to share two data items:<code>int turn;</code>,<code>boolean flag[2];</code></li></ul><h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>The structure of process $P_i$ in Peterson’s solution.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    flag[i] = <span class="literal">true</span>;</span><br><span class="line">    turn = j;</span><br><span class="line">    <span class="keyword">while</span> (flag[j] &amp;&amp; turn == j)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*remainder section */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>We now prove that this solution is correct. We need to show that:</p><ol><li>Mutual exclusion is preserved.<code>while (flag[j] &amp;&amp; turn == j)</code></li><li>The progress requirement is satisfied.<code>flag[i] = false;</code></li><li>The bounded-waiting requirement is met.(一个进程的critical section只会执行一次)</li></ol><h3 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h3><p>Processors and/or compilers may reorder read and write operations that have no dependencies. For a multithreaded application with shared data, the reordering of instructions may render inconsistent or unexpected results.(为了优化编译器的调换代码顺序的操作会导致问题)</p><p>Example:<br>Consider the following data that are shared between two threads:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean flag = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>where Thread 1 performs the statements<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!flag)</span><br><span class="line">;</span><br><span class="line">print x;</span><br></pre></td></tr></table></figure></p><p>and Thread 2 performs<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">100</span>;</span><br><span class="line">flag = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><ul><li>It is possible that a processor may reorder the instructions for Thread 2 so that flag is assigned true before assignment of <code>x = 100</code>. In this situation, it is possible that Thread 1 would output 0 for variable <code>x</code>. </li><li>The processor may also reorder the statements issued by Thread 1 and load the variable <code>x</code> before loading the value of <code>flag</code>.</li></ul><p>Consider what happens if the assignments of the first two statements that appear in the entry section of Peterson’s solution are reordered(<code>turn</code>和<code>flag</code>对应操作调换顺序); it is possible that <strong>both threads may be active in their critical sections at the same time</strong>, as shown in Figure 6.4.</p><div align=center><img src="../../figure/operating-system/Chapter6-Synchronization_tools/reordering_in_peterson_sol.png" width=500></div><p>The only way to preserve mutual exclusion is by using proper synchronization tools.</p><div align=center><img src="../../figure/operating-system/Chapter6-Synchronization_tools/synchro_tool.png" width=400></div><h2 id="Hardware-Support-for-Synchronization"><a href="#Hardware-Support-for-Synchronization" class="headerlink" title="Hardware Support for Synchronization"></a>Hardware Support for Synchronization</h2><p>As discussed, software-based solutions are not guaranteed to work on modern computer architectures. In this section, we present three hardware instructions that provide support for solving the critical-section problem. (单独软件无法解决问题，需要硬件协同)</p><h3 id="Memory-Barriers"><a href="#Memory-Barriers" class="headerlink" title="Memory Barriers"></a>Memory Barriers</h3><p><strong><em>memory model</em></strong>: How a computer architecture determines what memory guarantees it will provide to an application program.</p><ol><li><strong>Strongly ordered</strong>, where a memory modification on one processor is immediately visible to all other processors.</li><li><strong>Weakly ordered</strong>, where modifications to memory on one processor may not be immediately visible to other processors.</li></ol><p><strong><em>memory barriers</em></strong>(memory fences): can force any changes in memory to be propagated to all other processors, thereby ensuring that memory modifications are visible to threads running on other processors. </p><p>When a memory barrier instruction is performed, the system ensures that all loads and stores are completed before any subsequent load or store operations are performed.</p><div align=center><img src="../../figure/operating-system/Chapter6-Synchronization_tools/memory_fence.png" width=500></div><p>Example:<br>If we add a memory barrier operation to Thread 1<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!flag)</span><br><span class="line">    memory_barrier();</span><br><span class="line">print x;</span><br></pre></td></tr></table></figure></p><p>we guarantee that the value of <code>flag</code> is loaded before the value of <code>x</code>.<br>Similarly, if we place a memory barrier between the assignments performed by Thread 2<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">100</span>;</span><br><span class="line">    memory_barrier();</span><br><span class="line">flag = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>we ensure that the assignment to <code>x</code> occurs before the assignment to <code>flag</code>.</p><p>Memory barriers are considered very low-level operations and are typically only used by kernel developers when writing specialized code that ensures mutual exclusion.(通常作为底层被调用)</p><h3 id="Hardware-Instructions"><a href="#Hardware-Instructions" class="headerlink" title="Hardware Instructions"></a>Hardware Instructions</h3><p>Many modern computer systems provide <em>special hardware instructions</em> that allow us either to test and modify the content of a word or to swap the contents of two words <strong><em>atomically</em></strong>—that is, as one <strong>uninterruptible unit</strong>.</p><p>The definition of the atomic <code>test_and_set()</code> instruction<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean <span class="title function_">test_and_set</span><span class="params">(boolean *target)</span> &#123;</span><br><span class="line">    boolean rv = *target;</span><br><span class="line">    *target = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>If the machine supports the <code>test_and_set()</code> instruction, then we can implement mutual exclusion by declaring a boolean variable lock, initialized to <code>false</code>.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (test_and_set(&amp;lock))</span><br><span class="line">        ; <span class="comment">/* do nothing */</span></span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">    lock = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">/* remainder section */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><p><strong>Another instruction</strong><br>The definition of the <em>atomic</em> <code>compare_and_swap()</code> instruction (CAS).<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compare_and_swap</span><span class="params">(<span class="type">int</span> *value, <span class="type">int</span> expected, <span class="type">int</span> new_value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*value == expected)</span><br><span class="line">    *value = new_value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Mutual exclusion with the <code>compare_and_swap()</code> instruction.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (compare_and_swap(&amp;lock, <span class="number">0</span>, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">        ; <span class="comment">/* do nothing */</span></span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">    lock = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* remainder section */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Bounded-waiting</strong> mutual exclusion with <code>compare_and_swap()</code>, can satisfies <em>all the critical-section</em> requirements.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    waiting[i] = <span class="literal">true</span>;</span><br><span class="line">    key = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (waiting[i] &amp;&amp; key == <span class="number">1</span>)</span><br><span class="line">        key = compare_and_swap(&amp;lock,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    waiting[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line"></span><br><span class="line">    j = (i + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">while</span> ((j != i) &amp;&amp; !waiting[j])</span><br><span class="line">        j = (j + <span class="number">1</span>) % n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == i)</span><br><span class="line">        lock = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        waiting[j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* remainder section */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Atomic-Variables"><a href="#Atomic-Variables" class="headerlink" title="Atomic Variables"></a>Atomic Variables</h3><p><strong><em>atomic variable</em></strong>: provides atomic operations on basic data types such as integers and booleans. </p><p>Most systems that support atomic variables provide special atomic data types.(These functions are often implemented using <code>compare_and_swap()</code> operations.)</p><p>For example:<code>increment(&amp;sequence);</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">atomic_int</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        temp = *v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (temp != compare_and_swap(v, temp, temp+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Do not entirely solve race conditions in all circumstances.</p><h2 id="Mutex-Locks"><a href="#Mutex-Locks" class="headerlink" title="Mutex Locks"></a>Mutex Locks</h2><p>Operating-system designers build higher-level software tools to solve the <em>critical-section problem</em>.The simplest of these tools is the <strong><em>mutex lock</em></strong>. (In fact, the term mutex is short for mutual exclusion.)</p><div align=center><img src="../../figure/operating-system/Chapter6-Synchronization_tools/mutex_locks.png" width=500></div><p>The definition of <code>acquire()</code> is as follows:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">acquire() &#123;</span><br><span class="line">    <span class="keyword">while</span> (!available)</span><br><span class="line">    ; <span class="comment">/* busy wait */</span></span><br><span class="line">    available = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>The definition of <code>release()</code> is as follows:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">release() &#123;</span><br><span class="line">    available = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Calls to either <code>acquire()</code> or <code>release()</code> must be performed <em>atomically</em>.(Thus, mutex locks can be implemented using the CAS operation)</p><p>The main disadvantage:<br><strong><em>busy waiting</em></strong>: While a process is in its critical section, any other process that tries to enter its critical section must loop continuously in the call to <code>acquire()</code>.(会导致其他CPU需要一直等待)</p><p>The type of mutex lock we have been describing is also called a <strong><em>spin-lock</em></strong>(自旋锁) because the process “spins” while waiting for the lock to become available. </p><div align=center><img src="../../figure/operating-system/Chapter6-Synchronization_tools/spin-lock.png" width=400></div><h2 id="Semaphores"><a href="#Semaphores" class="headerlink" title="Semaphores"></a>Semaphores</h2><p>A <strong><em>semaphore</em></strong> S is an integer variable that, apart from initialization, is accessed only through two standard atomic operations: <code>wait()</code> and <code>signal()</code>.</p><p>The definition of <code>wait()</code> is as follows:(相当于<code>acquire()</code>)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wait(S) &#123;</span><br><span class="line">    <span class="keyword">while</span> (S &lt;= <span class="number">0</span>)</span><br><span class="line">        ; <span class="comment">// busy wait</span></span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>The definition of <code>signal()</code> is as follows:(相当于<code>release()</code>)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(S) &#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>All modifications to the integer value of the semaphore in the <code>wait()</code> and <code>signal()</code> operations must be executed <em>atomically</em>.</p><h3 id="Semaphore-Usage"><a href="#Semaphore-Usage" class="headerlink" title="Semaphore Usage"></a>Semaphore Usage</h3><p>Operating systems often distinguish between counting and binary semaphores.<br><strong><em>counting semaphore</em></strong>: The value can range over an unrestricted domain.<br><strong><em>binary semaphore</em></strong>: The value can range only between 0 and 1. </p><p>Counting semaphores can be used to control access to a given resource consisting of a finite number of instances.</p><h3 id="Semaphore-Implementation"><a href="#Semaphore-Implementation" class="headerlink" title="Semaphore Implementation"></a>Semaphore Implementation</h3><p>The definitions of the <code>wait()</code> and <code>signal()</code> semaphore operations just described suffers from busy waiting. To overcome this problem, we can modify the definition of the <code>wait()</code> and <code>signal()</code> operations as follows: Rather than engaging in busy waiting, the process can <em>suspend</em> itself when excuting <code>wait()</code>.</p><div align=center><img src="../../figure/operating-system/Chapter6-Synchronization_tools/semaphore_implementation.png" width=600></div><p>To implement semaphores under this definition, we define a semaphore as follows:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">list</span>;</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure></p><p>Now, the <code>wait()</code> semaphore operation can be defined as<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wait(semaphore *S) &#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        add this process to S-&gt;<span class="built_in">list</span>;</span><br><span class="line">        sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>and the <code>signal()</code> semaphore operation can be defined as<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">signal(semaphore *S) &#123;</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        remove a process P from S-&gt;<span class="built_in">list</span>;</span><br><span class="line">        wakeup(P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><h3 id="Monitor-Usage"><a href="#Monitor-Usage" class="headerlink" title="Monitor Usage"></a>Monitor Usage</h3><p>The monitor construct:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">monitor monitor_name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* shared variable declarations */</span></span><br><span class="line">    function <span class="title function_">P1</span> <span class="params">( . . . )</span> &#123;</span><br><span class="line">        . . .</span><br><span class="line">    &#125;</span><br><span class="line">    function <span class="title function_">P2</span> <span class="params">( . . . )</span> &#123;</span><br><span class="line">        . . .</span><br><span class="line">    &#125;</span><br><span class="line">        . . .</span><br><span class="line">    function <span class="title function_">Pn</span> <span class="params">( . . . )</span> &#123;</span><br><span class="line">        . . .</span><br><span class="line">    &#125;</span><br><span class="line">    initialization <span class="title function_">code</span> <span class="params">( . . . )</span> &#123;</span><br><span class="line">        . . .</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>The monitor construct ensures that only one process at a time is active within the monitor. </p><div align=center><img src="../../figure/operating-system/Chapter6-Synchronization_tools/simple_monitor.png" width=400></div><p>However, the monitor construct, as defined so far, is not sufficiently powerful for modeling some synchronization schemes.(一次只能执行一个进程)</p><p>For this purpose, we need to define additional synchronization mechanisms. These mechanisms are provided by the <strong>condition</strong> construct.</p><div align=center><img src="../../figure/operating-system/Chapter6-Synchronization_tools/monitor_with_conditional_variable.png" width=500></div><p>一个monitor中有</p><ul><li>多个进程（线程），它们可能要访问相同的资源(shared data)。这些进程就是图中的entry queue。</li><li>一个或多个condition variable，每个condition variable会和一把锁相关联。</li></ul><p>执行过程为：entry queue中的进程拿到锁（mutex），进入shared data，如果该进程需要等待某个条件成立 <code>x</code> 才能继续执行(比如生产者-消费者问题中，生产者需要buffer不为满，才能继续执行)，那么该进程就会释放锁，并执行 <code>x.wait()</code> 将自己挂在 <code>x</code> 对应的队列上。直到其他进程执行了 <code>x.signal()</code>，<code>x</code> 对应的队列才会逐个释放元素。</p><p>例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓冲区大小</span></span><br><span class="line">BUFFER_SIZE = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局变量</span></span><br><span class="line">buffer = []</span><br><span class="line">lock = threading.Lock()</span><br><span class="line">not_full = threading.Condition(lock)</span><br><span class="line">not_empty = threading.Condition(lock)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产者线程函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>():</span><br><span class="line">    <span class="keyword">global</span> buffer</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)  <span class="comment"># 模拟生产过程</span></span><br><span class="line">        <span class="keyword">with</span> not_full:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(buffer) == BUFFER_SIZE:</span><br><span class="line">                not_full.wait()</span><br><span class="line">            buffer.append(<span class="string">&#x27;item&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Producer produces an item, buffer size: <span class="subst">&#123;<span class="built_in">len</span>(buffer)&#125;</span>&#x27;</span>)</span><br><span class="line">            not_empty.notify()  <span class="comment"># 唤醒消费者线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者线程函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>():</span><br><span class="line">    <span class="keyword">global</span> buffer</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">with</span> not_empty:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(buffer) == <span class="number">0</span>:</span><br><span class="line">                not_empty.wait()</span><br><span class="line">            buffer.pop()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Consumer consumes an item, buffer size: <span class="subst">&#123;<span class="built_in">len</span>(buffer)&#125;</span>&#x27;</span>)</span><br><span class="line">            not_full.notify()  <span class="comment"># 唤醒生产者线程</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)  <span class="comment"># 模拟消费过程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建生产者和消费者线程</span></span><br><span class="line">t1 = threading.Thread(target=producer)</span><br><span class="line">t2 = threading.Thread(target=consumer)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动线程</span></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待线程结束</span></span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></table></figure></p><p>这段代码中并没有显式地使用 monitor，而是使用了 Python 中提供的锁对象 <code>Lock</code> 和条件变量对象 <code>Condition</code>，通过这两个对象可以实现监视器模式的基本功能。<br>同时在这个例子中，<code>not_full</code> 是一个条件变量对象，使用 <code>with not_full</code>: 就可以保证在进入 <code>with</code> 代码块前调用 <code>not_full.acquire()</code> 进行获取锁，在代码块执行完毕后自动调用 <code>not_full.release()</code> 进行释放锁，无需手动编写这些代码。</p>]]></content>
      
      
      <categories>
          
          <category> Operating system </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多模态代码运行踩坑</title>
      <link href="/posts/9f0c726.html"/>
      <url>/posts/9f0c726.html</url>
      
        <content type="html"><![CDATA[<p>在跑GitHub上<a href="https://github.com/declare-lab/multimodal-deep-learning/tree/main/MISA">MISA</a>代码的时候遇到了不少问题。这里记录一下踩过的坑。</p><h3 id="python虚拟环境问题"><a href="#python虚拟环境问题" class="headerlink" title="python虚拟环境问题"></a>python虚拟环境问题</h3><p>在跑别人的代码的时候，环境中的包的版本一定要严格一致，不然就会出现各种各样奇怪的bug。。。</p><p>最开始按照READEME.md中的教程安装python包的时候，因为出了问题，最后有几个包没装上，后来就直接用<code>pip install</code>安装了，没有确定版本，结果代码就直接跑不出来。<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError:&#x27;lengths&#x27; argument should be a 1D CPU int64 tensor, but got 1D cuda:0 Long tensor</span><br></pre></td></tr></table></figure></p><h3 id="爆内存问题解决"><a href="#爆内存问题解决" class="headerlink" title="爆内存问题解决"></a>爆内存问题解决</h3><p>主要问题应该是模型太大，需要加载的东西太多，所以最后炸了。<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: CUDA out of memory. Tried to allocate 32.00 MiB (GPU 0; 10.76 GiB total capacity; 7.91 GiB already allocated; 45.12 MiB free; 1020.08 MiB cached)</span><br></pre></td></tr></table></figure></p><p>解决方法就是减小训练的<code>batchsize</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> multimodal </tag>
            
            <tag> conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本命令</title>
      <link href="/posts/4b6ea061.html"/>
      <url>/posts/4b6ea061.html</url>
      
        <content type="html"><![CDATA[<p>内容来源：<a href="https://gnu-linux.readthedocs.io/zh/latest/index.html">这个网站</a></p><h3 id="cat-查看和连接文件内容"><a href="#cat-查看和连接文件内容" class="headerlink" title="cat 查看和连接文件内容"></a>cat 查看和连接文件内容</h3><p>cat 命令用于连接文件并打印到标准输出设备上。</p><p>命令格式：<code>cat [OPTION]... [FILE]...</code></p><p>常用选项：</p><ul><li><code>-b, --number-nonblank</code>：和 <code>-n</code> 相似，只不过对于空白行不编号。</li><li><code>-n, --number</code>：由 1 开始对所有输出的行数编号</li><li><code>-s, --squeeze-blank</code>：当遇到有连续两行以上的空白行，就代换为一行的空白行</li></ul><p>使用实例：<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">cat</span> a.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /usr/bin/bash</span></span><br><span class="line">echo &quot;Hello world !&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">cat</span> a.sh b.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /usr/bin/bash</span></span><br><span class="line">echo &quot;Hello world !&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /usr/bin/bash</span></span><br><span class="line">name=&quot;Linus Benedict Torvalds&quot;</span><br><span class="line">echo $name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">cat</span> -n a.sh b.sh</span></span><br><span class="line">     1      #! /usr/bin/bash</span><br><span class="line">     2      echo &quot;Hello world !&quot;</span><br><span class="line">     3      #! /usr/bin/bash</span><br><span class="line">     4      name=&quot;Linus Benedict Torvalds&quot;</span><br><span class="line">     5      echo $name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">利用重定向功能，另存为拼接文件</span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">cat</span> -n a.sh b.sh &gt; all.sh</span></span><br></pre></td></tr></table></figure></p><h3 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp 复制文件或目录"></a>cp 复制文件或目录</h3><p>cp（copy）用来复制文件（或目录）到指定的路径，可同时复制多个文件和目录。</p><p>命令格式：<code>cp [OPTION]... [-T] SOURCE DEST</code></p><p>常用选项：</p><ul><li><code>-f, --force</code>：强制复制，覆盖已经存在的文件时不提示</li><li><code>-i, --interactive</code>：在覆盖已经存在的文件时给出提示，要求用户确认是否覆盖</li><li><code>-n, --no-clobber</code>：不覆盖已经存在的文件</li><li><code>-R, -r, --recursive</code>：递归处理，将指定目录下的文件与子目录一并复制</li></ul><p>使用实例：<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">a.sh  demo.md   example.sh  hello1.txt  hello_rep.txt  nohup.out  sigint.py</span><br><span class="line">b.sh  demo_dir  gituse      hello2.txt  mcd.sh         remote</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制文件并重命名</span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">cp</span> a.sh demo_dir/aaa.sh</span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">ls</span> demo_dir/</span></span><br><span class="line">aaa.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制多个文件到文件夹</span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">cp</span> a.sh example.sh demo_dir/</span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">ls</span> demo_dir/</span></span><br><span class="line">a.sh  aaa.sh  example.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">递归复制整个文件目录</span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">cp</span> -r remote/ demo_dir/</span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">ls</span> demo_dir/</span></span><br><span class="line">a.sh  aaa.sh  example.sh  remote</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交互式地复制文件</span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">cp</span> -i a.sh demo_dir/</span></span><br><span class="line">cp: overwrite &#x27;demo_dir/a.sh&#x27;? n</span><br></pre></td></tr></table></figure></p><h3 id="rm-删除文件或目录"><a href="#rm-删除文件或目录" class="headerlink" title="rm 删除文件或目录"></a>rm 删除文件或目录</h3><p>rm（remove）删除文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除。</p><p><strong><em>使用 rm 命令要格外小心。因为一旦删除了一个文件，就无法再恢复它。</em></strong></p><p>命令格式：<code>rm [OPTION]... FILE...</code></p><p>常用选项：</p><ul><li><code>-d, --dir</code>：删除空目录</li><li><code>-f, --force</code>：强制删除文件或目录，不给出提示</li><li><code>-i</code>：删除文件或目录之前先询问用户</li><li><code>-r, -R, --recursive</code>：递归处理，将指定目录下的所有文件与子目录一并删除</li></ul><p>使用实例：<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">a.sh  demo.md   example.sh  hello1.txt  hello_rep.txt  nohup.out  sigint.py</span><br><span class="line">b.sh  demo_dir  gituse      hello2.txt  mcd.sh         remote</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除文件</span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">rm</span> a.sh</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除文件前先确认</span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">rm</span> -i b.sh</span></span><br><span class="line">rm: remove regular file &#x27;b.sh&#x27;? n</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">递归删除文件夹</span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">ls</span> -F</span></span><br><span class="line">b.sh*     demo_dir/    gituse/      hello2.txt*     mcd.sh*     remote/</span><br><span class="line">demo.md*  example.sh*  hello1.txt*  hello_rep.txt*  nohup.out*  sigint.py*</span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">rm</span> -r demo_dir/</span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">b.sh     example.sh  hello1.txt  hello_rep.txt  nohup.out  sigint.py</span><br><span class="line">demo.md  gituse      hello2.txt  mcd.sh         remote</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制递归删除文件夹（非常危险的命令）</span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">rm</span> -rf remote/</span></span><br></pre></td></tr></table></figure></p><h3 id="ls-显示目录中的文件"><a href="#ls-显示目录中的文件" class="headerlink" title="ls 显示目录中的文件"></a>ls 显示目录中的文件</h3><p>ls（list）用来显示目录所含的文件及子目录，在 Linux 中是使用率较高的命令。</p><p>命令格式：<code>ls [OPTION]... [FILE]...</code><br>常用选项：</p><ul><li><code>-a, --all</code>：显示所有的文件，包括隐藏文件（以 <code>.</code> 开头的文件）</li><li><code>-F, --classify</code><br>在每个输出项后追加文件的类型标识符<ul><li>“*”表示具有可执行权限的普通文件</li><li>“/”表示目录</li><li>“@”表示符号链接</li><li>“|”表示命令管道 FIFO</li><li>“=”表示 sockets 套接字</li><li>当文件为普通文件时，不输出任何标识符</li></ul></li><li><code>-i, --inode</code>：列出文件的索引节点号（inode）</li><li><code>-l</code>：以长格式显示目录下的内容列表。</li><li><code>-R, --recursive</code>：递归处理，将指定目录下的所有文件及子目录一并处理</li></ul><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">b.sh     example.sh  hello1.txt  hello_rep.txt  nohup.out  sigint.py</span><br><span class="line">demo.md  gituse      hello2.txt  mcd.sh         remote</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示所有的文件，包括隐藏文件</span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">ls</span> -a</span></span><br><span class="line">.   b.sh     example.sh  hello1.txt  hello_rep.txt  nohup.out  sigint.py</span><br><span class="line">..  demo.md  gituse      hello2.txt  mcd.sh         remote</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在每个输出项后追加文件的类型标识符</span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">ls</span> -F</span></span><br><span class="line">b.sh*     example.sh*  hello1.txt*  hello_rep.txt*  nohup.out*  sigint.py*</span><br><span class="line">demo.md*  gituse/      hello2.txt*  mcd.sh*         remote/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示文件的索引节点号</span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">ls</span> -i</span></span><br><span class="line"> 1970324838295833 b.sh         2251799814827352 hello1.txt      7318349395395220 nohup.out</span><br><span class="line"> 5629499535130883 demo.md       844424931274074 hello2.txt      3659174697243803 remote</span><br><span class="line"> 9570149209075706 example.sh   1125899907984731 hello_rep.txt  13510798883029637 sigint.py</span><br><span class="line"> 6755399441974060 gituse       5066549581705135 mcd.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">显示长格式列表,并将文件大小转换为更加人性化的表示方法（默认的以字节为单位）</span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">ls</span> -lh</span></span><br><span class="line">total 0</span><br><span class="line">-rwxrwxrwx 1 root root   59 Mar  8 17:03 b.sh</span><br><span class="line">-rwxrwxrwx 1 root root  385 Sep 25 23:38 demo.md</span><br><span class="line">-rwxrwxrwx 1 root root  282 Sep 25 19:53 example.sh</span><br><span class="line">drwxrwxrwx 1 root root 4.0K Feb 20 08:43 gituse</span><br><span class="line">-rwxrwxrwx 1 root root   12 Feb 21 19:16 hello1.txt</span><br><span class="line">-rwxrwxrwx 1 root root    6 Feb 21 19:15 hello2.txt</span><br><span class="line">-rwxrwxrwx 1 root root   24 Feb 21 19:17 hello_rep.txt</span><br><span class="line">-rwxrwxrwx 1 root root   41 Sep 25 19:53 mcd.sh</span><br><span class="line">-rwxrwxrwx 1 root root    0 Sep 27 13:59 nohup.out</span><br><span class="line">drwxrwxrwx 1 root root 4.0K Feb 20 08:20 remote</span><br><span class="line">-rwxrwxrwx 1 root root  246 Sep 27 13:28 sigint.py</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示目录下所有的 txt 文件</span></span><br><span class="line"><span class="meta prompt_">[Linux]$ </span><span class="language-bash"><span class="built_in">ls</span> -l *txt</span></span><br><span class="line">-rwxrwxrwx 1 root root 12 Feb 21 19:16 hello1.txt</span><br><span class="line">-rwxrwxrwx 1 root root  6 Feb 21 19:15 hello2.txt</span><br><span class="line">-rwxrwxrwx 1 root root 24 Feb 21 19:17 hello_rep.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用conda管理虚拟环境</title>
      <link href="/posts/757571af.html"/>
      <url>/posts/757571af.html</url>
      
        <content type="html"><![CDATA[<h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><ol><li><p><code>conda list</code>查看安装了哪些包</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">Blog&gt; </span><span class="language-bash">conda list</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">packages <span class="keyword">in</span> environment at D:\anaconda3:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Name                    Version                   Build  Channel</span></span>   </span><br><span class="line">_anaconda_depends         2022.10                  py39_2    defaults</span><br><span class="line">_ipyw_jlab_nb_ext_conf    0.1.0            py39haa95532_0    defaults</span><br><span class="line">_tflow_select             2.3.0                       mkl    defaults</span><br><span class="line">absl-py                   1.3.0            py39haa95532_0    defaults</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注：文中的<code>...</code>表示此处只截取了控制台中的部分内容。</p></li><li><p><code>conda env list</code> 或 <code>conda info -e</code> 查看存在哪些虚拟环境</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conda env list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">conda environments:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">base                  *  D:\anaconda3</span></span><br><span class="line">pyforcvx                 D:\anaconda3\envs\pyforcvx   </span><br><span class="line">sklearn-env              D:\anaconda3\envs\sklearn-env</span><br></pre></td></tr></table></figure><p>其中*表示正在使用的环境。</p></li><li><p><code>conda update conda</code> 检查更新当前conda</p></li></ol><h3 id="创建python虚拟环境"><a href="#创建python虚拟环境" class="headerlink" title="创建python虚拟环境"></a>创建python虚拟环境</h3><ol><li><code>conda create -n &lt;your_env_name&gt; python=X.X</code> 命令创建python版本为X.X、名字为your_env_name的虚拟环境。</li></ol><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">Blog&gt; </span><span class="language-bash">conda create -n demo1 python=3.7</span></span><br><span class="line">Retrieving notices: ...working... done</span><br><span class="line">Collecting package metadata (current_repodata.json): done</span><br><span class="line">Solving environment: done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Package Plan ##</span></span></span><br><span class="line"></span><br><span class="line">  environment location: D:\anaconda3\envs\demo1</span><br><span class="line"></span><br><span class="line">  added / updated specs:</span><br><span class="line">    - python=3.7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The following packages will be downloaded:</span><br><span class="line"></span><br><span class="line">    package                    |            build</span><br><span class="line">    ---------------------------|-----------------</span><br><span class="line">    certifi-2022.12.7          |   py37haa95532_0         149 KB  defaults</span><br><span class="line">    openssl-1.1.1t             |       h2bbff1b_0         5.5 MB  defaults</span><br><span class="line">    ...</span><br><span class="line">    ------------------------------------------------------------</span><br><span class="line">                                           Total:        26.8 MB</span><br><span class="line"></span><br><span class="line">The following NEW packages will be INSTALLED:</span><br><span class="line"></span><br><span class="line">  ca-certificates    anaconda/pkgs/main/win-64::ca-certificates-2023.01.10-haa95532_0</span><br><span class="line">  certifi            anaconda/pkgs/main/win-64::certifi-2022.12.7-py37haa95532_0  </span><br><span class="line">  openssl            anaconda/pkgs/main/win-64::openssl-1.1.1t-h2bbff1b_0</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">Proceed ([y]/n)?</span><br></pre></td></tr></table></figure><p>输入<code>y</code>，之后是<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Downloading and Extracting Packages</span><br><span class="line"></span><br><span class="line">Preparing transaction: done</span><br><span class="line">Verifying transaction: done</span><br><span class="line">Executing transaction: done</span><br></pre></td></tr></table></figure></p><h3 id="激活、退出虚拟环境"><a href="#激活、退出虚拟环境" class="headerlink" title="激活、退出虚拟环境"></a>激活、退出虚拟环境</h3><p>使用 <code>conda activate &lt;your_env_name&gt;</code> 激活虚拟环境<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activete demo1</span><br></pre></td></tr></table></figure><br>使用 <code>conda deactivate</code> 退出当前虚拟环境<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure></p><h3 id="在虚拟环境中安装、删除包"><a href="#在虚拟环境中安装、删除包" class="headerlink" title="在虚拟环境中安装、删除包"></a>在虚拟环境中安装、删除包</h3><p>可以使用 <code>conda install &lt;package_name&gt;</code> 安装包<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">Blog&gt; </span><span class="language-bash">conda install numpy</span></span><br><span class="line">Collecting package metadata (current_repodata.json): done</span><br><span class="line">Solving environment: failed with initial frozen solve. Retrying with flexible solve.</span><br><span class="line">Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.</span><br><span class="line">Collecting package metadata (repodata.json): done</span><br><span class="line">Solving environment: done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Package Plan ##</span></span></span><br><span class="line"></span><br><span class="line">  environment location: D:\anaconda3\envs\demo1</span><br><span class="line"></span><br><span class="line">  added / updated specs:</span><br><span class="line">    - numpy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The following NEW packages will be INSTALLED:</span><br><span class="line"></span><br><span class="line">  blas               anaconda/pkgs/main/win-64::blas-1.0-mkl</span><br><span class="line">  intel-openmp       anaconda/pkgs/main/win-64::intel-openmp-2021.4.0-haa95532_3556</span><br><span class="line">  mkl                anaconda/pkgs/main/win-64::mkl-2021.4.0-haa95532_640</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">Proceed ([y]/n)?</span><br></pre></td></tr></table></figure><br>安装时也可以指定包的版本号 <code>conda install &lt;package_name&gt;==&lt;version&gt;</code>，安装流程同上。</p><p>安装包的时候还可以指定环境名称。<code>conda install -n &lt;your_env_name&gt; [package]</code><br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">Blog&gt; </span><span class="language-bash">conda install -n demo2 numpy</span></span><br><span class="line">Collecting package metadata (current_repodata.json): done</span><br><span class="line">Solving environment: done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Package Plan ##</span></span></span><br><span class="line"></span><br><span class="line">  environment location: D:\anaconda3\envs\demo2</span><br><span class="line"></span><br><span class="line">  added / updated specs:</span><br><span class="line">    - numpy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The following packages will be downloaded:</span><br><span class="line"></span><br><span class="line">    package                    |            build</span><br><span class="line">    ---------------------------|-----------------</span><br><span class="line">    mkl-service-2.4.0          |   py38h2bbff1b_0          51 KB  defaults</span><br><span class="line">    mkl_fft-1.3.1              |   py38h277e83a_0         139 KB  defaults</span><br><span class="line">    ...</span><br><span class="line">    ------------------------------------------------------------</span><br><span class="line">                                           Total:         6.4 MB</span><br><span class="line"></span><br><span class="line">The following NEW packages will be INSTALLED:</span><br><span class="line"></span><br><span class="line">  blas               anaconda/pkgs/main/win-64::blas-1.0-mkl</span><br><span class="line">  intel-openmp       anaconda/pkgs/main/win-64::intel-openmp-2021.4.0-haa95532_3556</span><br><span class="line">  mkl                anaconda/pkgs/main/win-64::mkl-2021.4.0-haa95532_640</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><br>虽然使用命令是这里的环境还是<code>demo1</code>,但是<code>numpy</code>包被装到了<code>demo2</code>中。</p><p>想要删除包，可以使用 <code>conda remove &lt;package_name&gt;</code>。<br>如果想一次同时删除多个包，则使用形如 <code>conda remove &lt;package_name1&gt; &lt;package_name2&gt; &lt;package_name3&gt;</code> 的命令。<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">Blog&gt; </span><span class="language-bash">conda remove numpy</span></span><br><span class="line">Collecting package metadata (repodata.json): done</span><br><span class="line">Solving environment: done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Package Plan ##</span></span></span><br><span class="line"></span><br><span class="line">  environment location: D:\anaconda3\envs\demo2</span><br><span class="line"></span><br><span class="line">  removed specs:</span><br><span class="line">    - numpy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The following packages will be REMOVED:</span><br><span class="line"></span><br><span class="line">  blas-1.0-mkl</span><br><span class="line">  intel-openmp-2021.4.0-haa95532_3556</span><br><span class="line">  mkl-2021.4.0-haa95532_640</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Proceed ([y]/n)?</span><br></pre></td></tr></table></figure></p><p>同样也可以删除其他环境中的包 <code>conda remove --name &lt;your_env_name&gt; &lt;package_name&gt;</code></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">Blog&gt; </span><span class="language-bash">conda remove --name demo1 numpy</span></span><br><span class="line">Collecting package metadata (repodata.json): done</span><br><span class="line">Solving environment: done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Package Plan ##</span></span></span><br><span class="line"></span><br><span class="line">  environment location: D:\anaconda3\envs\demo1</span><br><span class="line"></span><br><span class="line">  removed specs:</span><br><span class="line">    - numpy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The following packages will be REMOVED:</span><br><span class="line"></span><br><span class="line">  blas-1.0-mkl</span><br><span class="line">  intel-openmp-2021.4.0-haa95532_3556</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Proceed ([y]/n)?</span><br></pre></td></tr></table></figure><p>(使用这段代码是处于<code>demo2</code>环境下)</p><h3 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h3><p><code>conda remove -n  &lt;your_env_name&gt; --all</code></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">Blog&gt; </span><span class="language-bash">conda remove -n demo1 --all</span></span><br><span class="line"></span><br><span class="line">Remove all packages in environment D:\anaconda3\envs\demo1:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Package Plan ##</span></span></span><br><span class="line"></span><br><span class="line">  environment location: D:\anaconda3\envs\demo1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The following packages will be REMOVED:</span><br><span class="line"></span><br><span class="line">  ca-certificates-2023.01.10-haa95532_0</span><br><span class="line">  certifi-2022.12.7-py37haa95532_0</span><br><span class="line">  openssl-1.1.1t-h2bbff1b_0</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">Proceed ([y]/n)? </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> conda </tag>
            
            <tag> python </tag>
            
            <tag> 虚拟环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter5-CPU Scheduling</title>
      <link href="/posts/53eb9bb1.html"/>
      <url>/posts/53eb9bb1.html</url>
      
        <content type="html"><![CDATA[<h2 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><p>In a system with a single CPU core, only one process can run at a time.</p><ul><li>Maximum CPU utilization obtained with multiprogramming</li><li>CPU–I/O Burst Cycle -Process execution consists of a cycle of CPU execution and I/O wait</li><li>CPU burst followed by I/O burst</li><li>CPU burst distribution is of main concern</li></ul><h3 id="CPU–I-O-Burst-Cycle"><a href="#CPU–I-O-Burst-Cycle" class="headerlink" title="CPU–I/O Burst Cycle"></a>CPU–I/O Burst Cycle</h3><p>Process execution begins with a CPU burst. That is followed by an I/O burst, which is followed by another CPU burst, then another I/O burst, and so on.</p><div align=center><img src="../../figure/operating-system/Chapter5-CPU-Scheduling/alter_seq.png" width=300></div><h3 id="CPU-Scheduler"><a href="#CPU-Scheduler" class="headerlink" title="CPU Scheduler"></a>CPU Scheduler</h3><p>Whenever the CPU becomes idle, the operating system must select one of the processes in the ready queue to be executed. The selection process is carried out by the <strong><em>CPU scheduler</em></strong>.</p><h3 id="Preemptive-and-Nonpreemptive-Scheduling"><a href="#Preemptive-and-Nonpreemptive-Scheduling" class="headerlink" title="Preemptive and Nonpreemptive Scheduling"></a>Preemptive and Nonpreemptive Scheduling</h3><p>CPU-scheduling decisions may take place under the following four circumstances:</p><ol><li>When a process switches from the running state to the waiting state (for example, as the result of an I/O request or an invocation of <code>wait()</code> for the termination of a child process)</li><li>When a process switches from the running state to the ready state (for example, when an interrupt occurs)</li><li>When a process switches from the waiting state to the ready state (for example, at completion of I/O)</li><li>When a process terminates</li></ol><p>When scheduling takes place only under circumstances 1 and 4, we say that the scheduling scheme is <strong><em>nonpreemptive</em></strong>(非抢占式) or <em>cooperative</em>. Otherwise, it is <strong><em>preemptive</em></strong>(抢占式). </p><p>Virtually all modern operating systems including Windows, macOS, Linux, and UNIX use <strong>preemptive</strong> scheduling algorithms.</p><h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>(调度程序)<br>The <strong><em>dispatcher</em></strong> is the module that gives control of the CPU’s core to the process selected by the CPU scheduler. This function involves the following:<br>• Switching context from one process to another<br>• Switching to user mode<br>• Jumping to the proper location in the user program to resume that program</p><p>The time it takes for the dispatcher to stop one process and start another running is known as the <strong><em>dispatch latency</em></strong>.</p><div align=center><img src="../../figure/operating-system/Chapter5-CPU-Scheduling/role_of_dispatcher.png" width=300></div><h2 id="Scheduling-Criteria"><a href="#Scheduling-Criteria" class="headerlink" title="Scheduling Criteria"></a>Scheduling Criteria</h2><ul><li><strong>CPU utilization.</strong></li><li><strong>Throughput.</strong>(吞吐率) One measure of work is the number of processes that are completed per time unit, called throughput.</li><li><strong>Turnaround time.</strong>（周转时间）The interval from the time of submission of a process to the time of completion is the turnaround time. </li><li><strong>Waiting time.</strong>(等待时间) Waiting time is the sum of the periods spent waiting in the ready queue.</li><li><strong>Response time.</strong>(响应时间)This measure, called response time, is the time it takes to start responding, not the time it takes to output the response.</li></ul><div align=center><img src="../../figure/operating-system/Chapter5-CPU-Scheduling/CPU-scheduling_time.png" width=500></div><h2 id="Scheduling-Algorithms"><a href="#Scheduling-Algorithms" class="headerlink" title="Scheduling Algorithms"></a>Scheduling Algorithms</h2><p>Although most modern CPU architectures have multiple processing cores, we describe these scheduling algorithms in the context of <strong>only one processing core available.</strong> </p><h3 id="First-Come-First-Served-Scheduling-FCFS"><a href="#First-Come-First-Served-Scheduling-FCFS" class="headerlink" title="First-Come, First-Served Scheduling(FCFS)"></a>First-Come, First-Served Scheduling(FCFS)</h3><p>Also fist-in, first-out.(FIFO)</p><p>优点：容易实现<br>缺点：长任务在前面会占用太多时间</p><h3 id="Shortest-Job-First-Scheduling-SJF"><a href="#Shortest-Job-First-Scheduling-SJF" class="headerlink" title="Shortest-Job-First Scheduling(SJF)"></a>Shortest-Job-First Scheduling(SJF)</h3><p>非抢占式<br>When the CPU is available, it is assigned to the process that has the smallest next CPU burst. </p><p>Preemptive SJF scheduling is sometimes called <strong><em>shortest-remaining-time-first scheduling</em></strong>.(SRTF,考虑剩余时间，抢占式)</p><h3 id="Round-Robin-Scheduling-RR"><a href="#Round-Robin-Scheduling-RR" class="headerlink" title="Round-Robin Scheduling(RR)"></a>Round-Robin Scheduling(RR)</h3><p>轮转/轮循；适用于前端应用，平均响应时间最短；类似CPU并发。<br>A small unit of time, called a <strong><em>time quantum</em></strong> or <em>time slice</em>, is defined. A time quantum is generally from 10 to 100 milliseconds in length.</p><p>The performance of the RR algorithm depends heavily on the size of the time quantum.</p><div align=center><img src="../../figure/operating-system/Chapter5-CPU-Scheduling/turnaround_time_quantum.png" width=400></div><p>We want the time quantum to be large with respect to the context-switch time.A rule of thumb is that <strong>80 percent</strong> of the CPU bursts should be shorter than the time quantum.</p><h3 id="Priority-Scheduling"><a href="#Priority-Scheduling" class="headerlink" title="Priority Scheduling"></a>Priority Scheduling</h3><p>A priority is associated with each process, and the CPU is allocated to the process with the highest priority.(The SJF algorithm is a <em>special</em> case of the general priority-scheduling algorithm.)</p><p>Priority scheduling can be either preemptive or nonpreemptive.(但大多数是抢占式)</p><p>A major problem with priority scheduling algorithms is indefinit blocking, or <strong><em>starvation</em></strong>.(某些程序因为有限集过低而一直无法被执行)A solution to the problem of indefinite blockage of low-priority processes is <strong><em>aging</em></strong>. Aging involves gradually increasing the priority of processes that wait in the system for a long time.(让优先级随着等待时间的延长而增加)</p><h3 id="Multilevel-Queue-Scheduling"><a href="#Multilevel-Queue-Scheduling" class="headerlink" title="Multilevel Queue Scheduling"></a>Multilevel Queue Scheduling</h3><p>使用多种算法<br>This approach—known as <strong><em>multilevel queue</em></strong>—also works well when <strong>priority scheduling</strong> is combined with <strong>round-robin</strong>.</p><div align=center><img src="../../figure/operating-system/Chapter5-CPU-Scheduling/multilevel_queue.png" width=300></div><p>Prioritization based upon process type</p><div align=center><img src="../../figure/operating-system/Chapter5-CPU-Scheduling/prior_based_pro_type.png" width=500></div><h3 id="Multilevel-Feedback-Queue-Scheduling"><a href="#Multilevel-Feedback-Queue-Scheduling" class="headerlink" title="Multilevel Feedback Queue Scheduling"></a>Multilevel Feedback Queue Scheduling</h3><p>Multilevel-feedback-queue scheduler defined by the following parameters:</p><ul><li>number of queues</li><li>scheduling algorithms for each queue</li><li>method used to determine when to upgrade a process</li><li>method used to determine when to demote a process</li><li>method used to determine which queue a process will enter when that process needs service</li></ul><p>Example:</p><div align=center><img src="../../figure/operating-system/Chapter5-CPU-Scheduling/multilevel_feedback_queue.png" width=400></div><p>Scheduling</p><ul><li>A new job enters queue $Q_0$ which is served FCFS<ul><li>When it gains CPU, job receives 8 milliseconds</li><li>If it does not finish in 8 milliseconds, job is moved to queue $Q_1$</li></ul></li><li>At $Q_1$ job is again served FCFS and receives 16 additional milliseconds<ul><li>If it still does not complete, it is preempted and moved to queue $Q_2$</li></ul></li></ul><h2 id="Thread-Scheduling"><a href="#Thread-Scheduling" class="headerlink" title="Thread Scheduling"></a>Thread Scheduling</h2><h3 id="Contention-Scope"><a href="#Contention-Scope" class="headerlink" title="Contention Scope"></a>Contention Scope</h3><p>Known as <strong><em>process-contention scope (PCS)</em></strong> since scheduling competition is within the process</p><p>Kernel thread scheduled onto available CPU is <strong><em>system-contention scope (SCS)</em></strong> – competition among all threads in system</p><h3 id="Pthread-Scheduling"><a href="#Pthread-Scheduling" class="headerlink" title="Pthread Scheduling"></a>Pthread Scheduling</h3><p>(老师讲的太快了)</p><h2 id="Multi-Processor-Scheduling"><a href="#Multi-Processor-Scheduling" class="headerlink" title="Multi-Processor Scheduling"></a>Multi-Processor Scheduling</h2><p><strong><em>asymmetric multiprocessing</em></strong>:所有工作交给master server<br><strong><em>symmetric multiprocessing (SMP)</em></strong> :where each processor is self-scheduling.</p><p>two possible strategies for organizing the threads eligible to be scheduled:</p><ol><li>All threads may be in a common ready queue.</li><li>Each processor may have its own private queue of threads.</li></ol><div align=center><img src="../../figure/operating-system/Chapter5-CPU-Scheduling/org_of_ready_queue.png" width=500></div><p>Virtually all modern operating systems support SMP</p><h3 id="Multicore-Processors"><a href="#Multicore-Processors" class="headerlink" title="Multicore Processors"></a>Multicore Processors</h3><p>Each core maintains its architectural state and thus appears to the operating system to be a separate <strong>logical CPU</strong>.</p><p>When a processor accesses memory, it spends a significant amount of time waiting for the data to become available. This situation, known as a <strong><em>memory stall</em></strong>. (就是等数据要花很长时间)The processor can spend up to 50 percent of its time waiting for data to become available from memory.</p><div align=center><img src="../../figure/operating-system/Chapter5-CPU-Scheduling/memory_stall.png" width=500></div><p>To remedy this situation, many recent hardware designs have implemented <strong>multithreaded processing cores</strong> in which two (or more) <strong><em>hardware threads</em></strong> are assigned to each core. That way, if one hardware thread stalls while waiting for memory, the core can switch to another thread.</p><div align=center><img src="../../figure/operating-system/Chapter5-CPU-Scheduling/multithread_multicore.png" width=500></div><p>From an operating system perspective, each hardware thread  appears as a logical CPU that is available to run a software thread.This technique known as <strong><em>chip multithreading</em></strong> (CMT).</p><div align=center><img src="../../figure/operating-system/Chapter5-CPU-Scheduling/chip_multithreading.png" width=300></div><p>It is important to note that the resources of the physical core (such as caches and pipelines) must be shared among its hardware threads, and therefore a processing core can <strong>only execute one hardware thread at a time</strong>.</p><h3 id="Load-Balancing"><a href="#Load-Balancing" class="headerlink" title="Load Balancing"></a>Load Balancing</h3><p><strong><em>push migration</em></strong><br><strong><em>Pull migration</em></strong></p><h3 id="Processor-Affinity"><a href="#Processor-Affinity" class="headerlink" title="Processor Affinity"></a>Processor Affinity</h3><p>(讲的很草率)</p><h2 id="Operating-System-Examples"><a href="#Operating-System-Examples" class="headerlink" title="Operating-System Examples"></a>Operating-System Examples</h2><h3 id="Linux-Scheduling"><a href="#Linux-Scheduling" class="headerlink" title="Linux Scheduling"></a>Linux Scheduling</h3><ul><li>Prior to Version 2.5:traditional UNIX scheduling algorithm. poor performance.</li><li>With Version 2.5 of the kernel:scheduling algorithm—known as O(1),increased support for SMP systems,poor response times<br>for the interactive processes</li><li>in release 2.6.23 of the kernel:<strong><em>Completely Fair Scheduler (CFS)</em></strong> became the default Linux scheduling algorithm.</li></ul><h2 id="Algorithm-Evaluation"><a href="#Algorithm-Evaluation" class="headerlink" title="Algorithm Evaluation"></a>Algorithm Evaluation</h2><h3 id="Deterministic-Modeling、Queueing-Models"><a href="#Deterministic-Modeling、Queueing-Models" class="headerlink" title="Deterministic Modeling、Queueing Models"></a>Deterministic Modeling、Queueing Models</h3><p>建模</p><h3 id="Simulations"><a href="#Simulations" class="headerlink" title="Simulations"></a>Simulations</h3><p>仿真</p><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>实现</p>]]></content>
      
      
      <categories>
          
          <category> Operating system </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter4-Thread</title>
      <link href="/posts/cb3de908.html"/>
      <url>/posts/cb3de908.html</url>
      
        <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>Most software applications that run on modern computers and mobile devices are multithreaded.<br>Example:A word processor may have a thread for displaying graphics, another thread for responding to keystrokes from the user, and a third thread for performing spelling and grammar checking in the background.</p><div align=center><img src="../../figure/operating-system/Chapter4-Thread/single_and_multiple_threaded.png" width=500></div><p>创建新的线程不用重新分配memory。</p><p>Application:<br>A busy web server may have several (perhaps thousands of) clients concurrently accessing it. Process creation is time consuming and resource intensive, however. It is generally more efficient to use one process that contains multiple threads.When a request is made, rather than creating another process, the server creates a new thread to service the request and resumes listening for additional requests.（就是说对于这种相同的task，使用thread来处理任务更加合理）</p><div align=center><img src="../../figure/operating-system/Chapter4-Thread/multithreaded_server.png" width=500></div><p>Most operating system kernels are also typically multithreaded.</p><h3 id="Benifits"><a href="#Benifits" class="headerlink" title="Benifits"></a>Benifits</h3><ul><li><strong>Responsiveness</strong>.</li><li><strong>Resource sharing</strong>. threads share the memory and the resources of the process to which they belong by default.</li><li><strong>Economy</strong>.</li><li><strong>Scalability</strong>.The benefits of multithreading can be even greater in a multiprocessor architecture, where threads may be running in parallel on different processing cores. </li></ul><h2 id="Multicore-Programming"><a href="#Multicore-Programming" class="headerlink" title="Multicore Programming"></a>Multicore Programming</h2><p>Multicore and multiprocessor:</p><div align=center><img src="../../figure/operating-system/Chapter4-Thread/multiprocessor-multicore.png" width=600></div><p>The distinction between concurrency and parallelism:</p><div align=center><img src="../../figure/operating-system/Chapter4-Thread/concurrent.png" width=500><img src="../../figure/operating-system/Chapter4-Thread/parallel.png" width=400></div><h3 id="Programming-Challenges"><a href="#Programming-Challenges" class="headerlink" title="Programming Challenges"></a>Programming Challenges</h3><ul><li><strong>Identifying tasks</strong>. find areas that can be divided into separate, concurrent tasks.</li><li><strong>Balance</strong>. ensure that the tasks perform equal work of equal value.</li><li><strong>Data splitting</strong>.</li><li><strong>Data dependency</strong>.When one task depends on data from another, programmers must ensure that the execution of the tasks is synchronized to accommodate the data dependency. </li><li><strong>Testing and debugging</strong>.</li></ul><h3 id="Types-of-Parallelism"><a href="#Types-of-Parallelism" class="headerlink" title="Types of Parallelism"></a>Types of Parallelism</h3><p>In general, there are two types of parallelism: <strong><em>data parallelism</em></strong> and <strong><em>task parallelism</em></strong>.</p><div align=center><img src="../../figure/operating-system/Chapter4-Thread/data_and_task_parallelism.png" width=500></div><h2 id="Multithreading-Models"><a href="#Multithreading-Models" class="headerlink" title="Multithreading Models"></a>Multithreading Models</h2><p>However, support for threads may be provided either at the user level, for <strong><em>user threads</em></strong>, or by the kernel, for <strong><em>kernel threads</em></strong>. User threads are supported above the kernel and are managed without kernel support, whereas kernel threads are supported and managed directly by the operating system.</p><ul><li><strong>Many-to-One Model</strong>: It’s efficient. However, the entire process will block if a thread makes a blocking system call. And multiple threads are unable to run in parallel on multicore systems. </li><li><strong>One-to-One Model</strong>: <ul><li>The only drawback to this model is that creating a user thread requires creating the corresponding kernel thread, and a large number of kernel threads may burden the performance of a system. </li><li>Linux, along with the family of Windows operating systems, implement the one-to-one model.</li></ul></li><li><strong>Many-to-Many Model</strong></li><li><strong>Two-level model</strong></li></ul><h2 id="Thread-Libraries"><a href="#Thread-Libraries" class="headerlink" title="Thread Libraries"></a>Thread Libraries</h2><p>There are two primary ways of implementing a thread library.</p><ul><li>provide a library entirely in user space with no kernel support.</li><li>implement a kernel-level library supported directly by the operating system.(Invoking a function in the API for the library typically results in a system call to the kernel.)</li></ul><p>Three main thread libraries are in use today: POSIX Pthreads, Windows, and Java.<br>Java: implemente using </p><ul><li>Windows<ul><li>kernel-level</li></ul></li><li>POSIX<ul><li>user-level</li><li>kernel-level</li></ul></li></ul><p>Two general strategies for creating multiple threads: </p><ul><li><strong>asynchronous threading</strong>: the parent resumes its execution, typically little data sharing between parent and child.</li><li><strong>synchronous threading</strong>: occurs when the parent thread creates one or more children and then must wait for all of its children to terminate before it resumes. Typically, synchronous threading involves significant data sharing among threads.</li></ul><h3 id="Pthreads"><a href="#Pthreads" class="headerlink" title="Pthreads"></a>Pthreads</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> <span class="comment">// thread library</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> sum; <span class="comment">/* this data is shared by the thread(s) */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">runner</span><span class="params">(<span class="type">void</span> *param)</span>; <span class="comment">/* threads call this function */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pthread_t</span> tid; <span class="comment">/* the thread identifier */</span></span><br><span class="line">  <span class="type">pthread_attr_t</span> attr; <span class="comment">/* set of thread attributes */</span></span><br><span class="line">  <span class="comment">/* set the default attributes of the thread */</span></span><br><span class="line">  pthread_attr_init(&amp;attr); <span class="comment">// default attributes</span></span><br><span class="line">  <span class="comment">/* create the thread */</span></span><br><span class="line">  pthread_create(&amp;tid, &amp;attr, runner, argv[<span class="number">1</span>]); <span class="comment">// pass the identifier, attributes, </span></span><br><span class="line">  <span class="comment">// where new thread will begin, the parameter provieded by the command line.</span></span><br><span class="line">  <span class="comment">// only one thread is created there</span></span><br><span class="line">  <span class="comment">/* wait for the thread to exit */</span></span><br><span class="line">  pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sum = %d∖n&quot;</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* The thread will execute in this function */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">runner</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, upper = atoi(param);</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= upper; i++)</span><br><span class="line">    sum += i;</span><br><span class="line">  pthread <span class="title function_">exit</span><span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This example program above creates only a single thread.</p><p>A simple method for waiting on several threads using the pthread join() function is to enclose the operation within a simple for loop.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* an array of threads to be joined upon */</span></span><br><span class="line"><span class="type">pthread_t</span> workers[NUM_THREADS];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++)</span><br><span class="line">  pthread_join(workers[i], <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p><h2 id="Implicit-Threading"><a href="#Implicit-Threading" class="headerlink" title="Implicit Threading"></a>Implicit Threading</h2><h3 id="Thread-Pools"><a href="#Thread-Pools" class="headerlink" title="Thread Pools"></a>Thread Pools</h3><p>线程池<br>The general idea behind a thread pool is to create a number of threads at start-up and place them into a pool, where they sit and wait for work. </p><div align=center><img src="../../figure/operating-system/Chapter4-Thread/thread_pool.png" width=400></div><p>benefits:</p><ol><li>often faster than waiting to create a thread.</li><li>limits the number of threads that exist at any one point. </li><li>allows us to use different strategies for running the task. For example, the task could be scheduled to execute after a time delay or to execute periodically.</li></ol><h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork Join"></a>Fork Join</h3><p>Recall that with this method, the main parent thread creates (<strong><em>forks</em></strong>) one or more child threads and then waits for the children to terminate and <strong><em>join</em></strong> with it, at which point it can retrieve and combine their results. </p><div align=center><img src="../../figure/operating-system/Chapter4-Thread/fork-join_parallelism.png" width=600></div><p>Fork-join in java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Task(problem)</span><br><span class="line">    <span class="keyword">if</span> problem is small enough</span><br><span class="line">      solve the problem directly</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        subtask1 = fork(<span class="keyword">new</span> <span class="title class_">Task</span>(subset of problem)</span><br><span class="line">        subtask2 = fork(<span class="keyword">new</span> <span class="title class_">Task</span>(subset of problem)</span><br><span class="line"></span><br><span class="line">        result1 = join(subtask1)</span><br><span class="line">        result2 = join(subtask2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> combined results</span><br></pre></td></tr></table></figure></p><div align=center><img src="../../figure/operating-system/Chapter4-Thread/fork-join_in_java.png" width=400></div>]]></content>
      
      
      <categories>
          
          <category> Operating system </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>latex-vscode文件配置</title>
      <link href="/posts/90e9784e.html"/>
      <url>/posts/90e9784e.html</url>
      
        <content type="html"><![CDATA[<p>这里主要讲解vscode配置latex时配置文件的内容。配置完成后可以实现latex源码和生成的pdf文件正反向搜索的功能。这里使用的外部pdf浏览器是Sumatrapdf。</p><p>配置代码的地方如图，通过<code>ctrl+shift+P</code>打开：</p><div align=center><img src="../../figure/latex-vscode文件配置/config_json.png" width=450></div><h3 id="完整配置代码"><a href="#完整配置代码" class="headerlink" title="完整配置代码"></a>完整配置代码</h3><p>以下是本人的配置文件的代码：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ======================== LaTeX 设置 BEGIN  ========================</span></span><br><span class="line"> <span class="attr">&quot;workbench.editorAssociations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;*.pdf&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latex-workshop-pdf-hook&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">//&quot;latex-workshop.view.pdf.viewer&quot;: &quot;tab&quot;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 latex-workshop 的 PDF　预览程序，external　指的是外部程序</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.viewer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;external&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.ref.viewer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;external&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.external.viewer.command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\Users\\zhu&#x27;xiao&#x27;zhi\\AppData\\Local\\SumatraPDF\\SumatraPDF.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.external.viewer.args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;%PDF%&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置正向、反向搜索：.tex -&gt; .pdf</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.external.synctex.command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\Users\\zhu&#x27;xiao&#x27;zhi\\AppData\\Local\\SumatraPDF\\SumatraPDF.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.external.synctex.args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="comment">// 正向搜索</span></span><br><span class="line">    <span class="string">&quot;-forward-search&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;%TEX%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;%LINE%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-reuse-instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 反向搜索</span></span><br><span class="line">    <span class="string">&quot;-inverse-search&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;\&quot;D:\\Program file\\Microsoft VS Code\\Code.exe\&quot; \&quot;D:\\Program file\\Microsoft VS Code\\resources\\app\\out\\cli.js\&quot; --ms-enable-electron-run-as-node -r -g \&quot;%f:%l\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;%PDF%&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一些独立的编译选项，可以作为工具被编译方案调用</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一些编译方案，会出现在 GUI 菜单里</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.recipes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;bibtex&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex*2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex ➞ bibtex ➞ pdflatex`×2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;pdflatex&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex ➞ bibtex ➞ xeflatex`×2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.clean.fileTypes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  <span class="comment">//设定清理文件的类型  </span></span><br><span class="line">  <span class="string">&quot;*.aux&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.bbl&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.blg&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.idx&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.ind&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.lof&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.lot&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.out&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.toc&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.acn&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.acr&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.alg&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.glg&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.glo&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.gls&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.ist&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.fls&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.log&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.fdb_latexmk&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.nav&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="string">&quot;*.snm&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="comment">//&quot;*.synctex.gz&quot;  </span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.autoClean.run&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onBuilt&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.recipe.default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lastUsed&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.autoBuild.run&quot;</span><span class="punctuation">:</span> <span class="string">&quot;never&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// ======================== LaTeX 设置 END ========================</span></span><br></pre></td></tr></table></figure></p><p>文件的第一段内容我也不知道在干什么，所以直接从下一段开始</p><h3 id="pdf打开方式"><a href="#pdf打开方式" class="headerlink" title="pdf打开方式"></a>pdf打开方式</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 latex-workshop 的 PDF　预览程序，external　指的是外部程序</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.viewer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;external&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.ref.viewer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;external&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.external.viewer.command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\Users\\zhu&#x27;xiao&#x27;zhi\\AppData\\Local\\SumatraPDF\\SumatraPDF.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.external.viewer.args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;%PDF%&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>这里的前两行应该是设置默认pdf打开方式，我这里选择了<code>exernal</code>，表示外部程序打开。如果不用默认方式打开的话，也可以在command这里自行选择。</p><p><div align=center><img src="../../figure/latex-vscode文件配置/pdf_viewer.png" width=300></div><br>第三行是外部打开程序的路径。第四行不太清楚。</p><h3 id="正反向搜索"><a href="#正反向搜索" class="headerlink" title="正反向搜索"></a>正反向搜索</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置正向、反向搜索：.tex -&gt; .pdf</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.external.synctex.command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\Users\\zhu&#x27;xiao&#x27;zhi\\AppData\\Local\\SumatraPDF\\SumatraPDF.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.external.synctex.args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="comment">// 正向搜索</span></span><br><span class="line">    <span class="string">&quot;-forward-search&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;%TEX%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;%LINE%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-reuse-instance&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 反向搜索</span></span><br><span class="line">    <span class="string">&quot;-inverse-search&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;\&quot;D:\\Program file\\Microsoft VS Code\\Code.exe\&quot; \&quot;D:\\Program file\\Microsoft VS Code\\resources\\app\\out\\cli.js\&quot; --ms-enable-electron-run-as-node -r -g \&quot;%f:%l\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;%PDF%&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>这里改一下外部打开程序的路径就行了，后面直接复制粘贴。然后<code>&quot;-inverse-research&quot;</code>这一段好像没啥用，反向搜索得到Sumatrapdf的配置文件里配置。</p><h3 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一些独立的编译选项，可以作为工具被编译方案调用</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>这一段也直接复制吧，这里配置大概的作用就是当你使用vscode进行编译的时候，事实上vscode会帮你调用命令行。然后<code>&quot;command&quot;</code>就是会在命令行中输入的命令，<code>&quot;args&quot;</code>就是会用到的参数。然后最前面的<code>&quot;name&quot;</code>无关紧要，只是说后面在调用这些编译选项的时候需要使用这些名字。</p><h3 id="编译方案"><a href="#编译方案" class="headerlink" title="编译方案"></a>编译方案</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一些编译方案，会出现在 GUI 菜单里</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.recipes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;bibtex&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex*2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex ➞ bibtex ➞ pdflatex`×2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;pdflatex&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex ➞ bibtex ➞ xeflatex`×2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>这里的编译方案用到的就是前面的编译选项。然后<code>&quot;name&quot;</code>依然是可以随便命名的，<code>tool</code>里用到的就是前面编译选项的名字。编译方案的作用在于，有些时候需要多次编译，直接使用整个编译方案就可以一次完成多次编译。</p><p>比如说这里的<code>&quot;pdflatex ➞ bibtex ➞ pdflatex×2&quot;</code>，就是先调用一次<code>pdflatex</code>，再调用一次<code>bibtex</code>，再调用两次<code>pdflatex</code>，这是因为如果使用了<code>.bib</code>文件用于引用的话，就要先编译文章，再编译bib文件，再编译文章将bib文件编译出来的东西加到文章里，最后一次编译是保证文章中使用<code>\cite</code>的部分能正常引用。</p><h3 id="文件清理"><a href="#文件清理" class="headerlink" title="文件清理"></a>文件清理</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;latex-workshop.latex.clean.fileTypes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  <span class="comment">//设定清理文件的类型  </span></span><br><span class="line">    <span class="string">&quot;*.aux&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.bbl&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.blg&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.idx&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.ind&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.lof&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.lot&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.out&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.toc&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.acn&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.acr&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.alg&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.glg&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.glo&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.gls&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.ist&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.fls&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.log&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.fdb_latexmk&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.nav&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="string">&quot;*.snm&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="comment">//&quot;*.synctex.gz&quot;  </span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.autoClean.run&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onBuilt&quot;</span><span class="punctuation">,</span> </span><br></pre></td></tr></table></figure><p>最后这个是用于文件清理的。因为vscode编译latex总是会生成很多看起来没什么用的文件，如果不需要的话可以清理掉，只留下.pdf和.tex文件，还有用于正反向搜索的.gz文件。</p><!-- 反向搜索的配置就先不说了，刚刚自己试了一下，发现反向搜索又抽风了QAQ。 --><h3 id="反向搜索配置"><a href="#反向搜索配置" class="headerlink" title="反向搜索配置"></a>反向搜索配置</h3><p>打开Sumatrapdf中的高级设置(可以使用<code>Alt,S,A</code>打开)，然后加入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InverseSearchCmdLine = &quot;D:\Program file\Microsoft VS Code\Code.exe&quot;  --ms-enable-electron-run-as-node -r -g &quot;%f:%l&quot;</span><br><span class="line">EnableTeXEnhancements = true</span><br></pre></td></tr></table></figure><br><code>InverseSearchCmdLine</code>那里要改成自己VSCode的路径。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>先要用反向搜索，在pdf内容鼠标左键双击，vscode的光标就会跳到对应位置处。<br>然后要用正向搜索的话，就在源码里选中，按<code>ctrl+alt+J</code>就行了。</p>]]></content>
      
      
      <categories>
          
          <category> latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter3-Process</title>
      <link href="/posts/98ec3252.html"/>
      <url>/posts/98ec3252.html</url>
      
        <content type="html"><![CDATA[<h2 id="Process-Concept"><a href="#Process-Concept" class="headerlink" title="Process Concept"></a>Process Concept</h2><p>jobs $\leftrightarrow$ processes</p><p>In time-shared systems, many user programs can be run.<br>并发：一个CPU，多个程序。分时系统中每个程序执行一个小时间段。</p><h3 id="The-process"><a href="#The-process" class="headerlink" title="The process"></a>The process</h3><p><em>Process</em> – a program in execution; (process execution must progress in sequential fashion)</p><p>The status of the current activity of a process is represented by the value of the <em>program counter</em> and the contents of the processor’s registers. </p><p>The memory layout of a process is typically divided into multiple sections:</p><ul><li><strong><em>Text section</em></strong>: the executable code</li><li><strong><em>Data section</em></strong>: global variables</li><li><strong><em>Heap section</em></strong>: memory that is dynamically allocated during program run time</li><li><strong><em>Stack section</em></strong>: containing temporary data<ul><li>Function parameters, return addresses, local variables</li></ul></li></ul><div align=center><img src="../../figure/operating-system/Chapter3-Process/layout_of_process.png" width=300></div><p>differences between program and process:</p><ul><li>Program: passive entity stored on disk (executable file)</li><li>Process: active</li></ul><p>Program becomes process when executable file loaded into memory</p><p>Although two processes may be associated with the same program, they are nevertheless considered two separate execution sequences.(One process can be several processes.)</p><div align=center><img src="../../figure/operating-system/Chapter3-Process/program-process.png" width=200></div><h3 id="Process-State"><a href="#Process-State" class="headerlink" title="Process State"></a>Process State</h3><p>As a process executes, it changes state</p><ul><li><strong>New</strong>: The process is being created</li><li><strong>Running</strong>: Instructions are being executed</li><li><strong>Waiting</strong>: The process is waiting for some event to occur</li><li><strong>Ready</strong>: The process is waiting to be assigned to a processor</li><li><strong>Terminated</strong>: The process has finished execution</li></ul><div align=center><img src="../../figure/operating-system/Chapter3-Process/diagram%20of%20process%20state.png" width=500></div><h3 id="Process-Control-Block"><a href="#Process-Control-Block" class="headerlink" title="Process Control Block"></a>Process Control Block</h3><p>进程控制块</p><p>Each process is represented in the operating system by a <em>process control block</em> (PCB)—also called a task control block.</p><ul><li><strong>Process id</strong> .就是PID.每个Process都有独立的PID.</li><li><strong>Process state</strong>. The state may be new, ready, running, waiting, halted, and so on.</li><li><strong>Program counter</strong>. The counter indicates the address of the next instruction to be executed for this process.（从其他process转到这个process的时候，PC需要知道应该从哪条指令开始执行）</li><li><strong>CPU registers</strong> . contents of all process-centric registers</li><li><strong>Accounting information</strong>.:有关用户信息的</li><li><strong>I/O status information</strong>. This information includes the list of I/O devices allocated to the process, a list of open files, and so on.</li></ul><p>In brief, the PCB simply serves as the repository for all the data needed to start, or restart, a process, along with some accounting data.(储存和进程相关的信息)</p><h3 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h3><p>把一个Process拆分成很多Thread在多核执行.</p><p>Most modern operating systems have extended the process concept to allow a process to have multiple threads of execution and thus to perform more than one task at a time.</p><p>This feature is especially beneficial on multicore systems, where multiple threads can run in parallel. </p><p>The PCB is expanded to include information for each thread.</p><h2 id="Process-Scheduling"><a href="#Process-Scheduling" class="headerlink" title="Process Scheduling"></a>Process Scheduling</h2><p>The process control block in the Linux operating system is represented by the C structure <code>task_struct</code>. Some of these fields include:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> state; <span class="comment">/* state of the process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span> <span class="comment">/* scheduling information */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span> <span class="comment">/* this process’s parent */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span> <span class="comment">/* this process’s children */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span> <span class="comment">/* list of open files */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span> <span class="comment">/* address space */</span></span><br></pre></td></tr></table></figure></p><p>Within the Linux kernel, all active processes are represented using a doubly linked list of <code>task_struct</code>.</p><div align=center><img src="../../figure/operating-system/Chapter3-Process/process_link.png" width=500></div><h3 id="Scheduling-Queues"><a href="#Scheduling-Queues" class="headerlink" title="Scheduling Queues"></a>Scheduling Queues</h3><p>As processes enter the system, they are put into a <em>ready queue</em>.<br>The system also includes other queues. When a process is allocated a CPU core, it executes for a while and eventually <em>terminates</em>, is interrupted, or <em>waits</em> for the occurrence of a particular event.</p><p>A common representation of process scheduling is a queueing diagram. Two types of queues are present.</p><div align=center><img src="../../figure/operating-system/Chapter3-Process/queque_diagram.png" width=500></div><p>In the first two cases, the process eventually switches from the waiting state to the ready state and is then put back in the ready queue. A process continues this cycle until it terminates.</p><h3 id="Context-Switch"><a href="#Context-Switch" class="headerlink" title="Context Switch"></a>Context Switch</h3><p>Save the current <em>context</em> of the process running on the CPU core so that it can restore that context when its processing is done.</p><p>The context is represented in the PCB of the process. (和前面的PCB内容相照应.)</p><p>Context-switch time is pure overhead, because the system does no useful work while switching.(切换需要浪费一定时间)</p><div align=center><img src="../../figure/operating-system/Chapter3-Process/context_switch.png" width=500></div><p>Also, the more complex the operating system, the greater the amount of work that must be done during a context switch.</p><h2 id="Operation-on-Process"><a href="#Operation-on-Process" class="headerlink" title="Operation on Process"></a>Operation on Process</h2><h3 id="Process-Creation"><a href="#Process-Creation" class="headerlink" title="Process Creation"></a>Process Creation</h3><p>Parent process create children processes, which, in turn create other processes, forming a tree of processes</p><p>Generally, process identified and managed via a process identifier (pid)</p><div align=center><img src="../../figure/operating-system/Chapter3-Process/process_tree.png" width=500></div><p>Resource sharing options</p><ul><li>Parent and children share all resources</li><li>Children share subset of parent’s resources</li><li>Parent and child share no resources</li></ul><p>Execution options</p><ul><li>Parent and children execute concurrently</li><li>Parent waits until children terminate</li></ul><p>(上面两段老师没讲)</p><p>Address space</p><ul><li>Child duplicate of parent.(使用相同的程序和数据)</li><li>Child has a program loaded into it.(重新加载)</li></ul><p>A new process is created by the <code>fork()</code> system call.The new process consists of a copy of the address space of the original process.(复制地址空间?)</p><p>Both processes (the parent and the child) continue execution at the instruction after the <code>fork()</code>, with one difference:</p><ul><li>child: return zero</li><li>parent: return nonzero</li></ul><p>After a <code>fork()</code> system call, one of the two processes typically uses the <code>exec()</code> system call to replace the process’s memory space with a new program.(在fork之后使用exec,用于重新加载一个程序进来.)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fork a child process */</span></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123; <span class="comment">/* error occurred */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork Failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* child process */</span></span><br><span class="line">        execlp(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="literal">NULL</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* parent process */</span></span><br><span class="line">        <span class="comment">/* parent will wait for the child to complete */</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child Complete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The child process then overlays its address space with the UNIX command <code>/bin/ls</code> (used to get a directory listing)(这里执行了一个新的process) using the <code>execlp()</code> system call (<code>execlp()</code> is a version of the <code>exec()</code> system call).  The parent waits for the child process to complete with the <code>wait()</code> system call.(然后父程序<code>wait()</code>等待子程序完成)</p><div align=center><img src="../../figure/operating-system/Chapter3-Process/process_creation_fork.png" width=600></div><h3 id="Process-Termination"><a href="#Process-Termination" class="headerlink" title="Process Termination"></a>Process Termination</h3><p>Process executes last statement and then asks the operating system to delete it using the <code>exit()</code> system call.</p><ul><li>Returns <em>status data</em> from child to parent (via <code>wait()</code>)</li><li>Process’ resources are deallocated by operating system</li></ul><p>A parent may terminate the execution of one of its children using the <code>abort()</code> system call for a variety of reasons, such as these:(父进程终止子进程原因)</p><ul><li>The child has exceeded its usage of some of the resources that it has been allocated. (To determine whether this has occurred, the parent must have a mechanism to inspect the state of its children.)</li><li>The task assigned to the child is no longer required.</li><li>The parent is exiting, and the operating system does not allow a child to continue if its parent terminates.</li></ul><div align=center><img src="../../figure/operating-system/Chapter3-Process/terminate_illustrate.png" width=400></div><p><em>cascading termination</em>: Some systems do not allow a child to exist if its parent has terminated.(父进程停止,子进程也停止,大多数操作系统如Linux,Windows是如此)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">int</span> status;</span><br><span class="line">...</span><br><span class="line">pid = wait(&amp;status);</span><br></pre></td></tr></table></figure><p>This system call also returns the process identifier of the terminated child so that the parent can tell which of its children has terminated $\Uparrow$</p><ul><li><em>zombie process</em>: A process that has terminated, but whose parent has not yet called <code>wait()</code>.</li><li><em>orphans</em>: Now consider what would happen if a parent did not invoke <code>wait()</code> and instead terminated</li></ul><h2 id="Interprocess-Communication"><a href="#Interprocess-Communication" class="headerlink" title="Interprocess Communication"></a>Interprocess Communication</h2><p>Processes within a system may be independent or cooperating(&gt;95\%)</p><!-- * Cooperating process can affect or be affected by other processes, including sharing data --><p>Reasons for cooperating processes:</p><ul><li><strong>Information sharing</strong>: several applications may be interested in the same piece of information</li><li><strong>Computation speedup</strong>: break a task into subtasks, each of which will be executing in parallel with the others.(achieved only if the computer has multiple processing cores.)</li><li><strong>Modularity</strong></li></ul><p>Cooperating processes need <em>interprocess communication (IPC)</em></p><p>Two models of IPC</p><ul><li>Shared memory(共享内容): faster, for system calls are required only to establish shared-memory regions, without kernel intervention.</li><li>Message passing(消息传递): useful for exchanging smaller amounts of data。（内核管理消息传递）</li></ul><div align=center><img src="../../figure/operating-system/Chapter3-Process/communication_model.png" width=500></div><h2 id="IPC-in-Shared-Memory-Systems"><a href="#IPC-in-Shared-Memory-Systems" class="headerlink" title="IPC in Shared-Memory Systems"></a>IPC in Shared-Memory Systems</h2><p><em>Producer-Consumer Problem</em>:</p><div align=center><img src="../../figure/operating-system/Chapter3-Process/producer_consumer_problem.png" width=500></div><ul><li><strong>unbounded-buffer</strong> places no practical limit on the size of the buffer</li><li><strong>bounded-buffer</strong> assumes that there is a fixed buffer size(实际情况)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">. . .</span><br><span class="line">&#125; item;</span><br><span class="line">item buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> out = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>The producer process:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">item next_produced;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">/* produce an item in next produced */</span></span><br><span class="line">    <span class="keyword">while</span> (((in + <span class="number">1</span>) % BUFFER_SIZE) == out)</span><br><span class="line">        ; <span class="comment">/* do nothing */</span></span><br><span class="line">    buffer[in] = next_produced;</span><br><span class="line">    in = (in + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>The consumer process:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">item next_consumed;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (in == out)</span><br><span class="line">        ; <span class="comment">/* do nothing */</span></span><br><span class="line">    next_consumed = buffer[out];</span><br><span class="line">    out = (out + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">    <span class="comment">/* consume the item in next consumed */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>One issue this illustration does not address concerns the situation in which both the producer process and the consumer process attempt to access the shared buffer concurrently. (但老师说的好像是多个producer同时access同一个buffer的情况？)</p><h2 id="IPC-in-Message-Passing-Systems"><a href="#IPC-in-Message-Passing-Systems" class="headerlink" title="IPC in Message-Passing Systems"></a>IPC in Message-Passing Systems</h2><p>（主流使用）<br>Mechanism for processes to communicate and to synchronize their actions</p><p>IPC facility provides two operations:</p><ul><li>send(message)</li><li>receive(message)</li></ul><p>If processes P and Q wish to communicate, they need to:</p><ul><li>Establish a <em>communication link</em> between them（通信的时候建立，不通信的时候回收）</li><li>Exchange messages via send/receive</li></ul><p>We are concerned here not with the link’s physical implementation but rather with its logical implementation.<br>• Direct or indirect communication<br>• Synchronous(并发性好，但是资源消耗快) or asynchronous(大量用户并发时，只能一个个响应) communication<br>• Automatic or explicit buffering</p><h3 id="Naming"><a href="#Naming" class="headerlink" title="Naming"></a>Naming</h3><p><strong><em>direct communication</em></strong>:<br>each process that wants to communicate must explicitly name the recipient or sender of the communication<br>In this scheme, the <code>send()</code> and <code>receive()</code> primitives are defined as:<br>• <code>send(P, message)</code>—Send a message to process P.<br>• <code>receive(Q, message)</code>—Receive a message from process Q.</p><p>Properties:<br>• A link is established automatically between every pair of processes that want to communicate. The processes <strong>need to know only each other’s identity</strong> to communicate.<br>• A link is associated with exactly two processes.<br>• Between each pair of processes, there <strong>exists exactly one link</strong>.</p><p><strong><em>indirect communication</em></strong>:<br>the messages are sent to and received from <strong><em>mailboxes</em></strong>, or <strong><em>ports</em></strong>.Each mailbox has a unique identification.</p><p>The <code>send()</code> and <code>receive()</code> primitives are defined as follows:<br>• <code>send(A, message)</code>—Send a message to mailbox A.<br>• <code>receive(A, message)</code>—Receive a message from mailbox A.</p><p>Properties:<br>• A link is established between a pair of processes only if both members of the pair have a shared mailbox.<br>• A link may be associated with more than two processes.<br>• Between each pair of communicating processes, a number of different links may exist, with each link corresponding to one mailbox.</p><div align=center><img src="../../figure/operating-system/Chapter3-Process/indirect_communicaton.png" width=600></div><p>Now suppose that processes P1, P2, and P3 all share mailbox A. Process P1 sends a message to A, while both P2 and P3 execute a <code>receive()</code> from A. Which process will receive the message sent by P1?(通信间相互影响：谁来接受信息？)<br>• Allow a link to be associated with two processes at most.<br>• Allow at most one process at a time to execute a <code>receive()</code> operation.<br>• Allow the system to select arbitrarily which process will receive the message。</p><p>A mailbox may be owned either by a process or by the operating system.</p><h3 id="Synchronization"><a href="#Synchronization" class="headerlink" title="Synchronization"></a>Synchronization</h3><p>Message passing may be either <em>blocking</em> or <em>nonblocking</em>—also known as <em>synchronous</em> and <em>asynchronous</em>.<br>• <strong>Blocking send</strong>. The sending process is blocked until the message is received by the receiving process or by the mailbox.<br>• <strong>Nonblocking send</strong>. The sending process sends the message and resumes operation.<br>• <strong>Blocking receive</strong>. The receiver blocks until a message is available.<br>• <strong>Nonblocking receive</strong>. The receiver retrieves either a valid message or a null.<br>Blocking 能保证某个消息的实时性，但是会影响到其他消息的发送与接受。</p><h2 id="Examples-of-IPC-Systems"><a href="#Examples-of-IPC-Systems" class="headerlink" title="Examples of IPC Systems"></a>Examples of IPC Systems</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows provides support for multiple operating environments, or <em>subsystems</em>.Application programs can be considered clients of a subsystem server.</p><p>The message-passing facility in Windows is called the <strong><em>advanced local procedure call (ALPC)</em></strong> facility.(本地通信)<br>Windows uses <strong>a port object</strong> to establish and maintain a connection between two processes. Windows uses two types of ports: <strong><em>connection ports</em></strong> and <strong><em>communication ports</em></strong>.</p><div align=center><img src="../../figure/operating-system/Chapter3-Process/ALPC.png" width=600></div><p>LPC和RPC主要用于处理message,更大的file和stream需要使用pipe传输。</p><h3 id="Pipes"><a href="#Pipes" class="headerlink" title="Pipes"></a>Pipes</h3><h4 id="Ordinary-Pipes"><a href="#Ordinary-Pipes" class="headerlink" title="Ordinary Pipes"></a>Ordinary Pipes</h4><p>Ordinary Pipes allow communication in standard <strong>producer- consumer style</strong>.Producer writes to one end (the write-end of the pipe).Consumer reads from the other end (the read-end of the pipe).Ordinary pipes are therefore unidirectional.</p><p>Typically, a parent process creates a pipe and uses it to communicate with a child process that it creates via <code>fork()</code>.</p>]]></content>
      
      
      <categories>
          
          <category> Operating system </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开始使用latex</title>
      <link href="/posts/9247393f.html"/>
      <url>/posts/9247393f.html</url>
      
        <content type="html"><![CDATA[<p>一个简单的例子<br><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;report&#125;</span><br><span class="line"><span class="comment">% preamble </span></span><br><span class="line"><span class="keyword">\title</span>&#123;A starter of latex&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;Zhu Xiaozhi&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="comment">% all the information we set before(title,date,author) can only be presented when using \maketitle</span></span><br><span class="line"><span class="keyword">\maketitle</span></span><br><span class="line"><span class="comment">% This is my first Latex document. More to be added. </span></span><br><span class="line"><span class="keyword">\section</span>&#123;Section 1&#125;</span><br><span class="line">This is section 1.  </span><br><span class="line"><span class="keyword">\subsection</span>&#123;subsection 1.1&#125;</span><br><span class="line">This is subsection 1.1. Notice the differences in the font headings. </span><br><span class="line"><span class="keyword">\section</span>&#123;Section 2&#125;</span><br><span class="line">This is section 2. </span><br><span class="line"><span class="keyword">\section</span>*&#123;Section 3&#125;</span><br><span class="line">But I don&#x27;t want my section to be numbered. </span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure></p><p>编译结果如下（pdf分了两页）：</p><p><img src="../../figure/开始使用latex/title.png" alt=""><br><img src="../../figure/开始使用latex/content.png" alt=""></p><h2 id="documentclass"><a href="#documentclass" class="headerlink" title="documentclass"></a>documentclass</h2><p>首先考虑第一行代码<br><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;report&#125;</span><br></pre></td></tr></table></figure><br>其基本格式为 <code>\documentclass[]&#123;&#125;</code>，大括号中表示的是文档类型，中括号中表示的是文档类选项。文档类选项不是必须的，因此可以只用 <code>\documentclass&#123;&#125;</code>。</p><p>文档类型</p><ul><li>article：排版科学期刊、 演示文档、 短报告、 程序文档、 邀请函……</li><li>proc：一个基于 article 的会议文集类</li><li>minimal：非常小的文档类。只设置了页面尺寸和基本字体。主要用来查错。</li><li>report：排版多章节长报告、短篇书籍、博士论文……</li><li>book：排版书籍。</li><li>slides：排版幻灯片。该文档类使用大号 <code>sans serif</code> 字体。也可以选用 <code>FoilTEXa</code> 来得到相同的效果。</li></ul><p>文档类选项</p><ul><li>10pt, 11pt, 12pt：设置文档中所使用的字体的大小。如果该项没有指定，默认使用10pt 字体。</li><li>a4paper, letterpaper, . . .：定义纸张的尺寸。缺省设置为letterpaper。此外，还可以使用a5paper, b5paper, executivepaper 以及legalpaper。</li><li>fleqn：设置行间公式为左对齐，而不是居中对齐。</li><li>leqno：设置行间公式的编号为左对齐，而不是右对齐。</li><li>titlepage, notitlepage：指定是否在文档标题(document title) 后另起一页。<code>article</code> 文档类缺省设置为不开始新页，<code>report</code> 和<code>book</code> 类则相反。</li><li>onecolumn, twocolumn：latex 以单栏(one column) 或双栏(two column) 的方式来排版文档。</li><li>twoside, oneside：指定文档为双面或单面打印格式。<code>article</code>和<code>report</code>类为单面(single sided) 格式，<code>book</code>类缺省为双面(double sided)格式。注意该选项只是作用于文档样式， 而不会通知打印机以双面格式打印文档。</li><li>landscape：将文档的打印输出布局设置为 landscape 模式。</li><li>openright, openany：决定新的一章仅在奇数页开始还是在下一页开始。 在文档类型为<code>article</code>时该选项不起作用， 因为该类中没有定义“章” (chapter)。 <code>report</code>类默认在下一页开始新一章而<code>book</code>类的新一章总是在奇数页开始。</li></ul><h2 id="title-date-author"><a href="#title-date-author" class="headerlink" title="title, date, author"></a>title, date, author</h2><p>对于这几行代码<br><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\title</span>&#123;A starter of latex&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;Zhu Xiaozhi&#125;</span><br></pre></td></tr></table></figure><br>就是用来写明标题、日期、作者。</p><p><code>\title&#123;&#125;</code> 括号中就是要用的标题。如果想要设置副标题，一种可行的方式是<br><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\title</span>&#123;A starter of latex<span class="keyword">\\</span>&#123;<span class="keyword">\small</span> a subheading&#125;&#125;</span><br></pre></td></tr></table></figure><br>这能够在标题的下一行有一个字号小一些的标题。</p><p><code>\date&#123;&#125;</code> 的括号中是显示的时间。如果使用 <code>\today</code> 就是显示今天的时间。但也可以自己输入时间。</p><p>同时需要注意，想要在文章中显示以上内容，必须在 <code>document</code> 中使用 <code>\maketitle</code><br><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\maketitle</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure></p><h2 id="section"><a href="#section" class="headerlink" title="section"></a>section</h2><p><code>\section&#123;&#125;</code>, <code>\subsection&#123;&#125;</code>,<code>\subsubsection&#123;&#125;</code>用于划分章节。括号中使用的是标题的名字，同时标题会自动编号。</p><p>如果不希望使用自动标号的功能，则可以使用如 <code>\section*&#123;&#125;</code> 的格式。</p>]]></content>
      
      
      <categories>
          
          <category> latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
