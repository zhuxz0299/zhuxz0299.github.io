<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Chapter9-Main Memory | Zhuxz's Blog</title><meta name="author" content="Zhuxz"><meta name="copyright" content="Zhuxz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="操作系统笔记——主存">
<meta property="og:type" content="article">
<meta property="og:title" content="Chapter9-Main Memory">
<meta property="og:url" content="http://zhuxz0299.github.io/posts/69ff1809.html">
<meta property="og:site_name" content="Zhuxz&#39;s Blog">
<meta property="og:description" content="操作系统笔记——主存">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://source.fomal.cc/img/default_cover_72.webp">
<meta property="article:published_time" content="2023-03-21T08:49:55.000Z">
<meta property="article:modified_time" content="2025-12-15T13:36:10.703Z">
<meta property="article:author" content="Zhuxz">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://source.fomal.cc/img/default_cover_72.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Chapter9-Main Memory",
  "url": "http://zhuxz0299.github.io/posts/69ff1809.html",
  "image": "https://source.fomal.cc/img/default_cover_72.webp",
  "datePublished": "2023-03-21T08:49:55.000Z",
  "dateModified": "2025-12-15T13:36:10.703Z",
  "author": [
    {
      "@type": "Person",
      "name": "Zhuxz",
      "url": "http://zhuxz0299.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/zxz.ico"><link rel="canonical" href="http://zhuxz0299.github.io/posts/69ff1809.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: false,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Chapter9-Main Memory',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/only_bg_img.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/cursor.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/nav_bar.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/page_border.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/font.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/scroll_bar.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 8.1.1"></head><body><div id="web_bg" style="background-image: url(/img/violet_light.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/raiden.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">187</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">88</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">42</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comment-dots"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/my-profile/"><i class="fa-fw fas fa-graduation-cap"></i><span> 学术主页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://source.fomal.cc/img/default_cover_72.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Zhuxz's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Chapter9-Main Memory</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comment-dots"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/my-profile/"><i class="fa-fw fas fa-graduation-cap"></i><span> 学术主页</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Chapter9-Main Memory</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-21T08:49:55.000Z" title="发表于 2023-03-21 16:49:55">2023-03-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-15T13:36:10.703Z" title="更新于 2025-12-15 21:36:10">2025-12-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Lecture-Notes/">Lecture Notes</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Lecture-Notes/Operating-System/">Operating System</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">1.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="Background">Background</h2>
<p>We are interested only in the sequence of memory addresses generated by the running program.</p>
<h3 id="Basic-Hardware">Basic Hardware</h3>
<p>We first need to make sure that each process has a separate memory space. Separate per-process memory space protects the processes from each other and is fundamental to having multiple processes loaded in memory for concurrent execution. (进程地址之间相互隔离，保护各个进程不产生冲突，即不会访问到其他进程的地址)</p>
<p>We can provide this protection by using two registers:</p>
<ul>
<li><strong>base register</strong> holds the smallest legal physical memory address;</li>
<li><strong>limit register</strong> specifies the size of the range.</li>
</ul>
<div align=center>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../../figure/operating-system/Chapter9-Main-Memory/generate_logical_address.png" width=500>
</div>
<p>使用两个register是因为早期CPU只有32位，只能访问4GB空间，所以要用两个寄存器访问全部空间。</p>
<p>The base and limit registers can be loaded only by the operating system</p>
<h3 id="Address-Binding">Address Binding</h3>
<p>Most systems allow a user process to reside in any part of the physical memory.</p>
<p>Addresses in the source program are generally <strong>symbolic</strong> (such as the variable count). Acompiler typically <em><strong>binds</strong></em> these symbolic addresses to k addresses. Each binding is a mapping from one address space to another.</p>
<p>Classically, the binding of instructions and data to memory addresses can be done at <em>any</em> step along the way:<br>
• Compile time<br>
• Load time<br>
• Execution time</p>
<h3 id="Logical-Versus-Physical-Address-Space">Logical Versus Physical Address Space</h3>
<p>An address generated by the <em>CPU</em> is commonly referred to as a <em><strong>logical address</strong></em>, whereas an address seen by the memory unit (the one loaded into the <em><strong>memory-address register</strong></em> 应该就是实际访问的) is commonly referred to as a <em><strong>physical address</strong></em>.</p>
<p>The run-time mapping from virtual to physical addresses is done by a hardware device called the <em><strong>memory-management unit (MMU)</strong></em> .</p>
<div align=center>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../../figure/operating-system/Chapter9-Main-Memory/MMU.png" width=500>
</div>
<p>a simple MMU scheme:<br>
Use <em><strong>relocation register</strong></em> (The value in the relocation register is added to every address generated by a user process at the time the address is sent to memory)</p>
<div align=center>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../../figure/operating-system/Chapter9-Main-Memory/MMU_relocation_register.png" width=500>
</div>
<h2 id="Contiguous-Memory-Allocation">Contiguous Memory Allocation</h2>
<p>In <em><strong>contiguous memory allocation</strong></em>, each process is contained in a single section of memory that is contiguous to the section containing the next process.</p>
<h3 id="Memory-Protection">Memory Protection</h3>
<p>使用 relocation register 和 limit register 就能实现。</p>
<h3 id="Memory-Allocation">Memory Allocation</h3>
<p>Initially, all memory is available for user processes and is considered one large block of available memory, a hole. Eventually, as you will see, memory contains a set of holes of various sizes.</p>
<div align=center>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../../figure/operating-system/Chapter9-Main-Memory/variable_partition.png" width=500>
</div>
<p>In general, as mentioned, the memory blocks available comprise a set of holes of various sizes scattered throughout memory. When a process arrives and needs memory, there are many solutions.<br>
• First fit. (找到能用的就行)<br>
• Best fi . (遍历全部，找大小恰好合适或者差别不大的)<br>
• Worst fit. (找最大的hole)</p>
<h3 id="Fragmentation">Fragmentation</h3>
<div align=center>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../../figure/operating-system/Chapter9-Main-Memory/fragmentation.png" width=500>
</div>
<ul>
<li>在external fragmentation的情况下，process 无法被正常加载运行</li>
<li>右面那幅图中没用到的2MB就是internal fragmentation.</li>
</ul>
<h2 id="Paging">Paging</h2>
<p><em><strong>Paging</strong></em> is a memory-management scheme that permits a process’s physical address space to be non-contiguous.<br>
One of advantages: Paging avoids <em>external fragmentation</em> .</p>
<h3 id="Basic-Method">Basic Method</h3>
<ul>
<li>breaking physical memory into fixed-sized blocks called <em><strong>frames</strong></em></li>
<li>breaking logical memory into blocks of the same size called <em><strong>pages</strong></em></li>
</ul>
<p>Every address generated by the CPU is divided into two parts: a <em><strong>page number (p)</strong></em> and a <em><strong>page offset (d)</strong></em></p>
<div align=center>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../../figure/operating-system/Chapter9-Main-Memory/logical_address_page.png" width=400>
</div>
<p>If the size of page is 4KB in a 32-bits system, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">n=12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>−</mo><mi>n</mi><mo>=</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">m-n=20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span></p>
<p>The page number is used as an index into a per-process <em><strong>page table</strong></em>.</p>
<div align=center>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../../figure/operating-system/Chapter9-Main-Memory/paging_hardware.png" width=600>
</div>
<p>The following outlines the steps taken by the <em>MMU</em> to translate a <em>logical address</em> generated by the CPU to a <em>physical address</em>:(直接看图也能看出来)</p>
<ol>
<li>Extract the page number p and use it as an index into the page table.</li>
<li>Extract the corresponding frame number f from the page table.</li>
<li>Replace the page number p in the logical address with the frame number f.</li>
</ol>
<p>The paging model of memory:</p>
<div align=center>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../../figure/operating-system/Chapter9-Main-Memory/paging_model.png" width=500>
</div>
<p>The size of page and frame is the same.</p>
<p>Paging scheme can’t avoid <em>internal fragmentation</em>.</p>
<p>Linux supkports two page sizes: a default page size (typically 4 KB) and an architecture-dependent larger page size called <em><strong>huge pages</strong></em>.(ususally 4KB-2MB)</p>
<p>An important aspect of paging is the clear separation between the programmer’s view of memory and the actual physical memory. (程序员看到的地址是连续的，但实际上可能是离散的).  This mapping is hidden from the programmer and is controlled by the operating system.<br>
<em><strong>frame table</strong></em>: has one entry for each physical page frame, indicating whether the latter is free or allocated and, if it is allocated, to which page of which process (or processes).</p>
<div align=center>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../../figure/operating-system/Chapter9-Main-Memory/frame_allocation.png" width=600>
</div>
<p>The operating system maintains a copy of the page table for each process, therefore increases the context-switch time.</p>
<h3 id="Hardware-Support">Hardware Support</h3>
<p>A pointer to the page table is stored with the other register values (like the instruction pointer) in the process control block of each process.(PCB中保存了一个指向page table的指针，PTBR)</p>
<p>Most contemporary CPUs, however, support much larger page tables (for example, 220 entries). For these machines, the page table is kept in main memory, and a <em><strong>page-table base register (PTBR)</strong></em> points to the page table. (存在memory中的原因是page table 太大，cache放不下)。</p>
<h4 id="Translation-Look-Aside-Buffer">Translation Look-Aside Buffer</h4>
<p>With normal scheme, <em>two</em> memory accesses are needed to access data</p>
<ol>
<li>one for the page-table entry</li>
<li>one for the actual data</li>
</ol>
<p><em><strong>translation look-aside buffer (TLB)</strong></em> :a special, small, fast-lookup hardware cache to store some <strong>page-frame pair</strong>.(大概能存储1KB的数据)</p>
<p>A TLB lookup in modern hardware is part of the instruction pipeline, essentially adding no performance penalty.(时间可以忽略不计)</p>
<div align=center>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../../figure/operating-system/Chapter9-Main-Memory/paging_hardware_with_TLB.png" width=600>
</div>
<p>When a logical address is generated by the CPU, the MMU first checks if its page number is present in the TLB.</p>
<ul>
<li>If the page number is found, its frame number is immediately available and is used to access memory.</li>
<li>If the page number is not in the TLB (known as a TLB miss),  a memory reference to the page table must be made.
<ul>
<li>In addition, we add the page number and frame number to the TLB</li>
<li>If the TLB is already full of entries: Replacement policies range from least recently used (LRU) through round-robin to random.</li>
</ul>
</li>
</ul>
<p>The percentage of times that the page number of interest is found in the TLB is called the <em><strong>hit ratio</strong></em>. (An 80-percent hit ratio and 10 nanoseconds to access memory, for example) To find the <em><strong>effective memory-access time</strong></em>, we weight the case by its probability:<br>
effective access time = 0.80 × 10 + 0.20 × 20 = 12 nanoseconds</p>
<h3 id="Protection">Protection</h3>
<p>One additional bit is generally attached to each entry in the page table: a <em><strong>valid–invalid</strong></em> bit. The operating system sets this bit for each page to allow or disallow access to the page.</p>
<div align=center>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../../figure/operating-system/Chapter9-Main-Memory/valid_invalid_bit.png" width=600>
</div>
<p>For example, in the figure above, addresses in pages 0, 1, 2, 3, 4, and 5 are mapped normally through the page table. Any attempt to generate an address in pages 6 or 7, however, will find that the valid–invalid bit is set to invalid, and the computer will trap to the operating system (invalid page reference).</p>
<p>valid-invalid bit 是因为有些逻辑内存和物理内存不能一一对应。这和虚拟内存相关。</p>
<h3 id="Shared-Pages">Shared Pages</h3>
<div align=center>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../../figure/operating-system/Chapter9-Main-Memory/shared_page.png" width=500>
</div>
<h2 id="Structure-of-the-Page-Table">Structure of the Page Table</h2>
<h3 id="Hierarchical-Paging">Hierarchical Paging</h3>
<p>For example, consider a system with a 32-bit logical address space. If the page size in such a system is 4 KB (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span>), then a page table may consist of over 1 million entries (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup><mo>=</mo><msup><mn>2</mn><mn>32</mn></msup><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}=2^{32}/ 2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span>). Clearly, we would not want to allocate the page table contiguously in main memory(太大了不方便查找). One simple solution to this problem is to <strong>divide the page table</strong> into smaller pieces.</p>
<p>One way is to use a two-level paging algorithm (also known as a <em><strong>forward-mapped</strong></em> page table), in which the page table itself is also paged.</p>
<div align=center>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../../figure/operating-system/Chapter9-Main-Memory/two_level_page_table.png" width=400>
</div>
<p>The logical address is as follows:</p>
<div align=center>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../../figure/operating-system/Chapter9-Main-Memory/logical_addr_of_two_level_page.png" width=350>
</div>
<p>The address-translation method for this architecture:</p>
<div align=center>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../../figure/operating-system/Chapter9-Main-Memory/address_translation_of_two_level.png" width=550>
</div>
<p>For a system with a 64-bit logical address space, a two-level paging scheme is no longer appropriate. (对于一般的台式机来说，切成3层已经足够了，因为前面有很多地址用不到，但是对于差不多用满64位的数据中心而言，可能要分到7层).(hierarchical page tables are generally considered inappropriate.)</p>
<h3 id="Hashed-Page-Tables">Hashed Page Tables</h3>
<p>适合数据量比较大的情况</p>
<div align=center>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../../figure/operating-system/Chapter9-Main-Memory/hash_page_table.png" width=550>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://zhuxz0299.github.io">Zhuxz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://zhuxz0299.github.io/posts/69ff1809.html">http://zhuxz0299.github.io/posts/69ff1809.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://zhuxz0299.github.io" target="_blank">Zhuxz's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://source.fomal.cc/img/default_cover_72.webp" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Background"><span class="toc-number">1.</span> <span class="toc-text">Background</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-Hardware"><span class="toc-number">1.1.</span> <span class="toc-text">Basic Hardware</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Address-Binding"><span class="toc-number">1.2.</span> <span class="toc-text">Address Binding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Logical-Versus-Physical-Address-Space"><span class="toc-number">1.3.</span> <span class="toc-text">Logical Versus Physical Address Space</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Contiguous-Memory-Allocation"><span class="toc-number">2.</span> <span class="toc-text">Contiguous Memory Allocation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Protection"><span class="toc-number">2.1.</span> <span class="toc-text">Memory Protection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Allocation"><span class="toc-number">2.2.</span> <span class="toc-text">Memory Allocation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fragmentation"><span class="toc-number">2.3.</span> <span class="toc-text">Fragmentation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Paging"><span class="toc-number">3.</span> <span class="toc-text">Paging</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-Method"><span class="toc-number">3.1.</span> <span class="toc-text">Basic Method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hardware-Support"><span class="toc-number">3.2.</span> <span class="toc-text">Hardware Support</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Translation-Look-Aside-Buffer"><span class="toc-number">3.2.1.</span> <span class="toc-text">Translation Look-Aside Buffer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Protection"><span class="toc-number">3.3.</span> <span class="toc-text">Protection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shared-Pages"><span class="toc-number">3.4.</span> <span class="toc-text">Shared Pages</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Structure-of-the-Page-Table"><span class="toc-number">4.</span> <span class="toc-text">Structure of the Page Table</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hierarchical-Paging"><span class="toc-number">4.1.</span> <span class="toc-text">Hierarchical Paging</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashed-Page-Tables"><span class="toc-number">4.2.</span> <span class="toc-text">Hashed Page Tables</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By Zhuxz</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-api-mu-three.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo-api-mu-three.vercel.app/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script defer src="/js/cursor.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v7.3.0" title=""><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.7.0" title=""><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><!-- hexo injector body_end end --></body></html>